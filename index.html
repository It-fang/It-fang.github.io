<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>It-fang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="A blog for discussing Java background development, which will regularly publish some bloggers in the learning process of their own experience and confusion, I hope that we can learn from each other he">
<meta property="og:type" content="website">
<meta property="og:title" content="It-fang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="It-fang">
<meta property="og:description" content="A blog for discussing Java background development, which will regularly publish some bloggers in the learning process of their own experience and confusion, I hope that we can learn from each other he">
<meta property="article:author" content="It-fang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="It-fang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">It-fang</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">It-fang</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JUC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/08/JUC/" class="article-date">
  <time datetime="2021-08-08T05:42:30.000Z" itemprop="datePublished">2021-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/08/JUC/">JUC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="一，Java多线程"><a href="#一，Java多线程" class="headerlink" title="一，Java多线程"></a>一，Java多线程</h2><h3 id="1-1-创建和运行线程"><a href="#1-1-创建和运行线程" class="headerlink" title="1.1 创建和运行线程"></a>1.1 创建和运行线程</h3><h4 id="方法一，直接使用-Thread"><a href="#方法一，直接使用-Thread" class="headerlink" title="方法一，直接使用 Thread"></a><strong>方法一，直接使用 Thread</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法的参数是给线程指定名字，推荐</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"t1"</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// run 方法内实现了要执行的任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p><code>19:19:00 [t1] c.ThreadStarter - hello</code></p>
</blockquote>
<h4 id="方法二，使用-Runnable-配合Thread"><a href="#方法二，使用-Runnable-配合Thread" class="headerlink" title="方法二，使用 Runnable 配合Thread"></a><strong>方法二，使用 Runnable 配合Thread</strong></h4><blockquote>
<p>把【线程】和【任务】（要执行的代码）分开</p>
<ul>
<li><p>Thread 代表线程</p>
</li>
<li><p>Runnable 可运行的任务（线程要执行的代码）</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread( runnable );</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">Runnable task2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(task2, <span class="string">"t2"</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p><code>19:19:00 [t1] c.ThreadStarter - hello</code></p>
</blockquote>
<p>Java 8 以后可以使用 lambda 精简代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">Runnable task2 = () -&gt; log.debug(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(task2, <span class="string">"t2"</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>小结</strong><ul>
<li>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合</li>
<li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
</li>
</ul>
<h4 id="方法三，FutureTask-配合-Thread"><a href="#方法三，FutureTask-配合-Thread" class="headerlink" title="方法三，FutureTask 配合 Thread"></a><strong>方法三，FutureTask 配合 Thread</strong></h4><blockquote>
<p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="keyword">new</span> Thread(task3, <span class="string">"t3"</span>).start();	</span><br><span class="line"><span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line">Integer result = task3.get();</span><br><span class="line">log.debug(<span class="string">"结果是:&#123;&#125;"</span>, result);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p><code>19:22:27 [t3] c.ThreadStarter - hello</code></p>
<p><code>19:22:27 [main] c.ThreadStarter - 结果是:100</code></p>
</blockquote>
<h3 id="1-2-观察多个线程同时运行"><a href="#1-2-观察多个线程同时运行" class="headerlink" title="1.2 观察多个线程同时运行"></a><strong>1.2</strong> <strong>观察多个线程同时运行</strong></h3><blockquote>
<p>主要是理解</p>
<ul>
<li>交替执行</li>
<li>谁先谁后，不由我们控制</li>
</ul>
</blockquote>
<h3 id="1-3-查看进程线程的方法"><a href="#1-3-查看进程线程的方法" class="headerlink" title="1.3 查看进程线程的方法"></a>1.3 查看进程线程的方法</h3><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li>
<li><code>tasklist</code>：查看进程</li>
<li><code>taskkill</code>：杀死进程</li>
</ul>
<h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><ul>
<li><code>ps -fe</code> ：查看所有进程</li>
<li><code>ps -fT -p &lt;PID&gt;</code>： 查看某个进程（PID）的所有线程</li>
<li><code>kill</code>： 杀死进程</li>
<li><code>top</code>：按大写 H 切换是否显示线程</li>
<li><code>top -H -p &lt;PID&gt;</code>：查看某个进程（PID）的所有线程</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ul>
<li><code>jps</code>：命令查看所有 Java 进程</li>
<li><code>jstack &lt;PID&gt;</code>： 查看某个 Java 进程（PID）的所有线程状态</li>
<li><code>jconsole</code>：来查看某个 Java 进程中线程的运行情况（图形界面）</li>
</ul>
<p>jconsole 远程监控配置</p>
<blockquote>
<ul>
<li><p>需要以如下方式运行你的 java 类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname&#x3D;&#96;ip地址&#96; -Dcom.sun.management.jmxremote -</span><br><span class="line">Dcom.sun.management.jmxremote.port&#x3D;&#96;连接端口&#96; -Dcom.sun.management.jmxremote.ssl&#x3D;是否安全连接 -</span><br><span class="line">Dcom.sun.management.jmxremote.authenticate&#x3D;是否认证 java类</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 /etc/hosts 文件将 127.0.0.1 映射至主机名</p>
</li>
</ul>
<p>如果要认证访问，还需要做如下步骤</p>
<ul>
<li>复制 jmxremote.password 文件</li>
<li>修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写</li>
<li>连接时填入 controlRole（用户名），R&amp;D（密码）</li>
</ul>
</blockquote>
<h3 id="1-4-原理之线程运行"><a href="#1-4-原理之线程运行" class="headerlink" title="1.4  原理之线程运行"></a>1.4  原理之线程运行</h3><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><ul>
<li>Java Virtual Machine Stacks （Java 虚拟机栈）我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
</li>
</ul>
<h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch<strong>）</strong></h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li><p>线程的 cpu 时间片用完</p>
</li>
<li><p>垃圾回收</p>
</li>
<li><p>有更高优先级的线程需要运行</p>
</li>
<li><p>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</p>
</li>
</ul>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念</p>
<p>就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch 频繁发生会影响性能</li>
</ul>
<h3 id="1-5-常见方法"><a href="#1-5-常见方法" class="headerlink" title="1.5 常见方法"></a>1.5 常见方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能说明</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>start()</td>
<td></td>
<td>启动一个新线程，在新的线程运行run方法中的代码</td>
<td>start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法<strong>只能调用一次</strong>，如果调用了多次会出现<code>IllegalThreadStateException</code></td>
</tr>
<tr>
<td>run()</td>
<td></td>
<td>新线程启动后调用的方法</td>
<td>如果在构造Thread对象时传递了Runable参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何操作，但可以创建Thread的子类对象类覆盖默认行为</td>
</tr>
<tr>
<td>join()</td>
<td></td>
<td>等待线程运行结束</td>
<td></td>
</tr>
<tr>
<td>join(long n)</td>
<td></td>
<td>等待线程与进行结束，最多等待n毫秒</td>
<td></td>
</tr>
<tr>
<td>getId()</td>
<td></td>
<td>获取线程长整型的id</td>
<td>id唯一</td>
</tr>
<tr>
<td>getName()</td>
<td></td>
<td>获取线程名</td>
<td></td>
</tr>
<tr>
<td>setName(String)</td>
<td></td>
<td>修改线程名</td>
<td></td>
</tr>
<tr>
<td>getPriority()</td>
<td></td>
<td>获取线程优先级</td>
<td></td>
</tr>
<tr>
<td>setPriority(int)</td>
<td></td>
<td>修改线程优先级</td>
<td>Java中规定线程优先级是1~10的整数，较大的优先级能提高该线程被CPU调度的几率</td>
</tr>
<tr>
<td>getState()</td>
<td></td>
<td>获取线程状态</td>
<td>java中线程状态是6个enum表示，分别为：<code>NEW</code>，<code>RUNNABLE</code>，<code>BLOCKED</code>，<code>WAITNG</code>，<code>TIMED_WAITING</code>，<code>TERMINATED</code></td>
</tr>
<tr>
<td>isInterrupted()</td>
<td></td>
<td>判断是否被打断</td>
<td>不会清除<code>打断标记</code></td>
</tr>
<tr>
<td>isAlive()</td>
<td></td>
<td>线程是否存活（还没有运行完毕）</td>
<td></td>
</tr>
<tr>
<td>interrupt()</td>
<td></td>
<td>打断线程</td>
<td>如果被打断线程正在<code>sleep</code>，<code>wait</code>，<code>join</code>会导致被打断的线程抛出<code>InterruptedException</code>，并清除打<code>断标记</code>；如果打断的正在运行的线程，则会设置<code>打断标记</code>；park的线程被打断，也会设置<code>打断标记</code></td>
</tr>
<tr>
<td>interrupted()</td>
<td>static</td>
<td>判断当前线程是否被打断</td>
<td>会清除<code>打断标记</code></td>
</tr>
<tr>
<td>currentThread()</td>
<td>static</td>
<td>获取当前正在执行的线程</td>
<td></td>
</tr>
<tr>
<td>sleep(long n)</td>
<td>static</td>
<td>让当前执行的线程休眠n毫秒，休眠时让出CPU的时间片给其他线程</td>
<td></td>
</tr>
<tr>
<td>yield</td>
<td>static</td>
<td>提示线程调度器让出当前现场对CPU的使用</td>
<td>主要是为了测试和调试</td>
</tr>
</tbody></table>
<h3 id="1-6-start-与-run"><a href="#1-6-start-与-run" class="headerlink" title="1.6 start 与 run"></a>1.6 start 与 run</h3><h4 id="调用-run"><a href="#调用-run" class="headerlink" title="调用 run"></a>调用 run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"t1"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.debug(Thread.currentThread().getName());</span><br><span class="line">            FileReader.read(Constants.MP4_FULL_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.run();</span><br><span class="line">    log.debug(<span class="string">"do other things ..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p><code>19:39:14 [main] c.TestStart - main</code></p>
<p><code>19:39:14 [main] c.FileReader - read [1.mp4] start ...</code></p>
<p><code>19:39:18 [main] c.FileReader - read [1.mp4] end ... cost: 4227 ms</code></p>
<p><code>19:39:18 [main] c.TestStart - do other things ...</code></p>
</blockquote>
<p>程序仍在 main 线程运行， <code>FileReader.read()</code>方法调用还是同步的</p>
<h4 id="调用-start"><a href="#调用-start" class="headerlink" title="调用 start"></a>调用 start</h4><p>将上述代码的<code>t1.run()</code> 改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p><code>19:41:30 [main] c.TestStart - do other things ...</code></p>
<p><code>19:41:30 [t1] c.TestStart - t1</code></p>
<p><code>19:41:30 [t1] c.FileReader - read [1.mp4] start ...</code></p>
<p><code>19:41:35 [t1] c.FileReader - read [1.mp4] end ... cost: 4542 ms</code></p>
</blockquote>
<p>程序在 t1 线程运行， <code>FileReader.read()</code>方法调用是异步的</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程</li>
<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>
</ul>
<h3 id="1-7-sleep-与-yield"><a href="#1-7-sleep-与-yield" class="headerlink" title="1.7 sleep 与 yield"></a>1.7 sleep 与 yield</h3><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><ul>
<li>调用 sleep 会让当前线程从 <em>Running</em> 进入 <em>Timed Waiting</em> 状态（阻塞）</li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 <code>InterruptedException</code></li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li>
</ul>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><ul>
<li>调用 yield 会让当前线程从 <em>Running</em> 进入 <em>Runnable</em> 就绪状态，然后调度执行其它线程</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ul>
<h4 id="案例应用：防止CPU占用100-限制对CPU的使用——sleep实现"><a href="#案例应用：防止CPU占用100-限制对CPU的使用——sleep实现" class="headerlink" title="案例应用：防止CPU占用100%(限制对CPU的使用——sleep实现)"></a>案例应用：防止CPU占用100%(限制对CPU的使用——sleep实现)</h4><p><strong>sleep实现</strong>：</p>
<p>在没有利用CPU来计算时，不要让while（true）空转浪费CPU，这时可以使用yield或sleep来让出CPU的使用权给其他程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以用 wait 或 条件变量达到类似的效果</li>
<li>不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景</li>
<li>sleep 适用于无需锁同步的场景</li>
</ul>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul>
<li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li>
<li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Runnable task1 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        System.out.println(<span class="string">"----&gt;1 "</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Runnable task2 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// Thread.yield();</span></span><br><span class="line">        System.out.println(<span class="string">" ----&gt;2 "</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(task1, <span class="string">"t1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(task2, <span class="string">"t2"</span>);</span><br><span class="line"><span class="comment">// t1.setPriority(Thread.MIN_PRIORITY);</span></span><br><span class="line"><span class="comment">// t2.setPriority(Thread.MAX_PRIORITY);</span></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>



<h3 id="1-8-join-方法详解"><a href="#1-8-join-方法详解" class="headerlink" title="1.8 join 方法详解"></a>1.8 join 方法详解</h3><h4 id="为什么需要-join"><a href="#为什么需要-join" class="headerlink" title="为什么需要 join"></a>为什么需要 join</h4><p>下面的代码执行，打印 r 是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    test1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    log.debug(<span class="string">"开始"</span>);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">"开始"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">"结束"</span>);</span><br><span class="line">        r = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    log.debug(<span class="string">"结果为:&#123;&#125;"</span>, r);</span><br><span class="line">    log.debug(<span class="string">"结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析</p>
<ul>
<li>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r=10</li>
<li>而主线程一开始就要打印 r 的结果，所以只能打印出 r=0</li>
</ul>
<p>解决方法</p>
<ul>
<li>用 sleep 行不行？为什么？</li>
<li>用 join，加在 t1.start() 之后即可</li>
</ul>
<h4 id="应用之同步"><a href="#应用之同步" class="headerlink" title="应用之同步"></a>应用之同步</h4><p>以调用方角度来讲，如果</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<p><img src="/2021/08/08/JUC/C:%5CUsers%5C92540%5CDesktop%5CmyselfBlog%5Chexo%5Csource_posts%5CJUC%5C1.png" alt="image-20210808203202871"></p>
<h5 id="等待多个结果"><a href="#等待多个结果" class="headerlink" title="等待多个结果"></a>等待多个结果</h5><p>问，下面代码 cost 大约多少秒？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> r1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> r2 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    test2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        r1 = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        r2 = <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    log.debug(<span class="string">"r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;"</span>, r1, r2, end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析如下</p>
<ul>
<li>第一个 join：等待 t1 时, t2 并没有停止, 而在运行</li>
<li>第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s</li>
</ul>
<p>如果颠倒两个 join 呢？</p>
<blockquote>
<p>输出：</p>
<p><code>20:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005</code></p>
</blockquote>
<h5 id="有时效的join"><a href="#有时效的join" class="headerlink" title="有时效的join"></a>有时效的join</h5><ul>
<li>等够时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> r1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> r2 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    test3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        r1 = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">// 线程执行结束会导致 join 结束</span></span><br><span class="line">    t1.join(<span class="number">1500</span>);</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    log.debug(<span class="string">"r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;"</span>, r1, r2, end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p><code>20:48:01.320 [main] c.TestJoin - r1: 10 r2: 0 cost: 1010</code></p>
</blockquote>
<ul>
<li>没等够时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> r1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> r2 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    test3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        r1 = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">// 线程执行结束会导致 join 结束</span></span><br><span class="line">    t1.join(<span class="number">1500</span>);</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    log.debug(<span class="string">"r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;"</span>, r1, r2, end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p><code>20:52:15.623 [main] c.TestJoin - r1: 0 r2: 0 cost: 1502</code></p>
</blockquote>
<h3 id="19-interrupt-方法详解"><a href="#19-interrupt-方法详解" class="headerlink" title="19 interrupt 方法详解"></a>19 interrupt 方法详解</h3><h4 id="打断-sleep，wait，join-的线程"><a href="#打断-sleep，wait，join-的线程" class="headerlink" title="打断 sleep，wait，join 的线程"></a>打断 sleep，wait，join 的线程</h4><p>这几个方法都会让线程进入阻塞状态</p>
<p>打断 sleep 的线程, 会清空打断状态，以 sleep 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">"t1"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">" 打断状态: &#123;&#125;"</span>, t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at java.lang.Thread.sleep(Thread.java:<span class="number">340</span>)</span><br><span class="line">    at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="number">386</span>)</span><br><span class="line">    at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class="number">8</span>)</span><br><span class="line">    at cn.itcast.n4.TestInterrupt.lambda$test1$<span class="number">3</span>(TestInterrupt.java:<span class="number">59</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line">    <span class="number">21</span>:<span class="number">18</span>:<span class="number">10.374</span> [main] c.TestInterrupt - 打断状态: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h4><p>打断正常运行的线程, 不会清空打断状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = current.isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                log.debug(<span class="string">" 打断状态: &#123;&#125;"</span>, interrupted);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"t2"</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p><code>20:57:37.964 [t2] c.TestInterrupt - 打断状态: true</code></p>
</blockquote>
<h3 id="模式之两阶段终止"><a href="#模式之两阶段终止" class="headerlink" title="模式之两阶段终止"></a>模式之两阶段终止</h3><h4 id="打断-park-线程"><a href="#打断-park-线程" class="headerlink" title="打断 park 线程"></a>打断 park 线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">"park..."</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        log.debug(<span class="string">"unpark..."</span>);</span><br><span class="line">        log.debug(<span class="string">"打断状态：&#123;&#125;"</span>, Thread.currentThread().isInterrupted());</span><br><span class="line">    &#125;, <span class="string">"t1"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p><code>21:11:52.795 [t1] c.TestInterrupt - park...</code></p>
<p><code>21:11:53.295 [t1] c.TestInterrupt - unpark...</code></p>
<p><code>21:11:53.295 [t1] c.TestInterrupt - 打断状态：true</code></p>
</blockquote>
<ul>
<li>如果打断标记已经是 true, 则 park 会失效</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            log.debug(<span class="string">"park..."</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.debug(<span class="string">"打断状态：&#123;&#125;"</span>, Thread.currentThread().isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">48.783</span> [Thread-<span class="number">0</span>] c.TestInterrupt - park... </span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">49.809</span> [Thread-<span class="number">0</span>] c.TestInterrupt - 打断状态：<span class="keyword">true</span> </span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">49.812</span> [Thread-<span class="number">0</span>] c.TestInterrupt - park... </span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">49.813</span> [Thread-<span class="number">0</span>] c.TestInterrupt - 打断状态：<span class="keyword">true</span> </span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">49.813</span> [Thread-<span class="number">0</span>] c.TestInterrupt - park... </span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">49.813</span> [Thread-<span class="number">0</span>] c.TestInterrupt - 打断状态：<span class="keyword">true</span> </span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">49.813</span> [Thread-<span class="number">0</span>] c.TestInterrupt - park... </span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">49.813</span> [Thread-<span class="number">0</span>] c.TestInterrupt - 打断状态：<span class="keyword">true</span> </span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">49.813</span> [Thread-<span class="number">0</span>] c.TestInterrupt - park... </span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">49.813</span> [Thread-<span class="number">0</span>] c.TestInterrupt - 打断状态：<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>提示</p>
<p>可以使用 <code>Thread.interrupted()</code>清除打断状态</p>
</blockquote>
<h3 id="1-10-不推荐的方法"><a href="#1-10-不推荐的方法" class="headerlink" title="1.10 不推荐的方法"></a>1.10 不推荐的方法</h3><p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>stop()</td>
<td></td>
<td>停止线程运行</td>
</tr>
<tr>
<td>suspend()</td>
<td></td>
<td>挂起（暂停）线程运行</td>
</tr>
<tr>
<td>resume</td>
<td></td>
<td>恢复线程运行</td>
</tr>
</tbody></table>
<h3 id="1-11-主线程与守护线程"><a href="#1-11-主线程与守护线程" class="headerlink" title="1.11 主线程与守护线程"></a>1.11 主线程与守护线程</h3><blockquote>
<p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">log.debug(<span class="string">"开始运行..."</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">"开始运行..."</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">"运行结束..."</span>);</span><br><span class="line">&#125;, <span class="string">"daemon"</span>);</span><br><span class="line"><span class="comment">// 设置该线程为守护线程</span></span><br><span class="line">t1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">t1.start();</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">"运行结束..."</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">08</span>:<span class="number">26</span>:<span class="number">38.123</span> [main] c.TestDaemon - 开始运行... </span><br><span class="line"><span class="number">08</span>:<span class="number">26</span>:<span class="number">38.213</span> [daemon] c.TestDaemon - 开始运行... </span><br><span class="line"><span class="number">08</span>:<span class="number">26</span>:<span class="number">39.215</span> [main] c.TestDaemon - 运行结束...</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>
</ul>
</blockquote>
<h3 id="1-12-五种状态"><a href="#1-12-五种状态" class="headerlink" title="1.12 五种状态"></a>1.12 五种状态</h3><p>这是从 <strong>操作系统</strong> 层面来描述的</p>
<p><img src="/2021/08/08/JUC/C:%5CUsers%5C92540%5CDesktop%5CmyselfBlog%5Chexo%5Csource_posts%5CJUC%5C2.png" alt="image-20210808222442896"></p>
<ul>
<li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</p>
</li>
<li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</p>
</li>
<li><p>【运行状态】指获取了 CPU 时间片运行中的状态</p>
<ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li><p>【阻塞状态】</p>
<ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li>
</ul>
</li>
<li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p>
</li>
</ul>
<h3 id="1-13-六种状态"><a href="#1-13-六种状态" class="headerlink" title="1.13 六种状态"></a>1.13 六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的</p>
<p>根据 Thread.State 枚举，分为六种状态</p>
<p><img src="/2021/08/08/JUC/C:%5CUsers%5C92540%5CDesktop%5CmyselfBlog%5Chexo%5Csource_posts%5CJUC%5C3.png" alt="image-20210808222641875"></p>
<ul>
<li><code>NEW</code>线程刚被创建，但是还没有调用<code>start()</code>方法</li>
<li><code>RUNNABLE</code> 当调用了<code>start()</code> 方法之后，注意，<strong>Java API</strong> 层面的<code>RUNNABLE</code>状态涵盖了 <strong>操作系统</strong> 层面的</li>
<li>【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li>
<li><code>BLOCKED</code> ，<code>WAITING</code> ， <code>TIMED_WAITING</code>都是 <strong>Java API</strong> 层面对【阻塞状态】的细分，后面会在状态转换一节详述</li>
<li><code>TERMINATED</code>当线程代码运行结束</li>
</ul>
<h3 id="1-14-习题"><a href="#1-14-习题" class="headerlink" title="1.14 习题"></a>1.14 习题</h3><p>阅读华罗庚《统筹方法》，给出烧水泡茶的多线程解决方案，提示</p>
<ul>
<li>参考图二，用两个线程（两个人协作）模拟烧水泡茶过程<ul>
<li>文中办法乙、丙都相当于任务串行</li>
<li>而图一相当于启动了 4 个线程，有点浪费</li>
</ul>
</li>
<li>用 sleep(n) 模拟洗茶壶、洗水壶等耗费的时间</li>
</ul>
<p>附：华罗庚《统筹方法》</p>
<blockquote>
<p>统筹方法，是一种安排工作进程的数学方法。它的实用范围极广泛，在企业管理和基本建设中，以及关系复</p>
<p>杂的科研项目的组织与管理中，都可以应用。</p>
<p>怎样应用呢？主要是把工序安排好。</p>
<p>比如，想泡壶茶喝。当时的情况是：开水没有；水壶要洗，茶壶、茶杯要洗；火已生了，茶叶也有了。怎么</p>
<p>办？</p>
<ul>
<li>办法甲：洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、拿茶叶；等水开了，泡茶喝。</li>
<li>办法乙：先做好一些准备工作，洗水壶，洗茶壶茶杯，拿茶叶；一切就绪，灌水烧水；坐待水开了，泡茶喝。</li>
<li>办法丙：洗净水壶，灌上凉水，放在火上，坐待水开；水开了之后，急急忙忙找茶叶，洗茶壶茶杯，泡茶喝。</li>
</ul>
<p>哪一种办法省时间？我们能一眼看出，第一种办法好，后两种办法都窝了工。</p>
<p>这是小事，但这是引子，可以引出生产管理等方面有用的方法来。</p>
<p>水壶不洗，不能烧开水，因而洗水壶是烧开水的前提。没开水、没茶叶、不洗茶壶茶杯，就不能泡茶，因而这些又是泡茶的前提。它们的相互关系，可以用下边的箭头图来表示：</p>
<p><img src="/2021/08/08/JUC/C:%5CUsers%5C92540%5CDesktop%5CmyselfBlog%5Chexo%5Csource_posts%5CJUC%5C4.png" alt="image-20210808223003939"></p>
<p>从这个图上可以一眼看出，办法甲总共要16分钟（而办法乙、丙需要20分钟）。如果要缩短工时、提高工作</p>
<p>效率，应当主要抓烧开水这个环节，而不是抓拿茶叶等环节。同时，洗茶壶茶杯、拿茶叶总共不过4分钟，大</p>
<p>可利用“等水开”的时间来做。</p>
<p>是的，这好像是废话，卑之无甚高论。有如走路要用两条腿走，吃饭要一口一口吃，这些道理谁都懂得。但</p>
<p>稍有变化，临事而迷的情况，常常是存在的。在近代工业的错综复杂的工艺过程中，往往就不是像泡茶喝这</p>
<p>么简单了。任务多了，几百几千，甚至有好几万个任务。关系多了，错综复杂，千头万绪，往往出现“万事俱</p>
<p>备，只欠东风”的情况。由于一两个零件没完成，耽误了一台复杂机器的出厂时间。或往往因为抓的不是关</p>
<p>键，连夜三班，急急忙忙，完成这一环节之后，还得等待旁的环节才能装配。</p>
<p>洗茶壶，洗茶杯，拿茶叶，或先或后，关系不大，而且同是一个人的活儿，因而可以合并成为：</p>
<p><img src="/2021/08/08/JUC/C:%5CUsers%5C92540%5CDesktop%5CmyselfBlog%5Chexo%5Csource_posts%5CJUC%5C5.png" alt="image-20210808223033458"></p>
<p>看来这是“小题大做”，但在工作环节太多的时候，这样做就非常必要了。</p>
<p>这里讲的主要是时间方面的事，但在具体生产实践中，还有其他方面的许多事。这种方法虽然不一定能直接</p>
<p>解决所有问题，但是，我们利用这种方法来考虑问题，也是不无裨益的</p>
</blockquote>
<h4 id="解法一：join"><a href="#解法一：join" class="headerlink" title="解法一：join"></a>解法一：join</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">"洗水壶"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    log.debug(<span class="string">"烧开水"</span>);</span><br><span class="line">    sleep(<span class="number">15</span>);</span><br><span class="line">&#125;, <span class="string">"老王"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">"洗茶壶"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    log.debug(<span class="string">"洗茶杯"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">"拿茶叶"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">"泡茶"</span>);</span><br><span class="line">&#125;, <span class="string">"小王"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">19</span>:<span class="number">37.547</span> [小王] c.TestMakeTea - 洗茶壶</span><br><span class="line"><span class="number">19</span>:<span class="number">19</span>:<span class="number">37.547</span> [老王] c.TestMakeTea - 洗水壶</span><br><span class="line"><span class="number">19</span>:<span class="number">19</span>:<span class="number">38.552</span> [小王] c.TestMakeTea - 洗茶杯</span><br><span class="line"><span class="number">19</span>:<span class="number">19</span>:<span class="number">38.552</span> [老王] c.TestMakeTea - 烧开水</span><br><span class="line"><span class="number">19</span>:<span class="number">19</span>:<span class="number">40.553</span> [小王] c.TestMakeTea - 拿茶叶</span><br><span class="line"><span class="number">19</span>:<span class="number">19</span>:<span class="number">53.553</span> [小王] c.TestMakeTea - 泡茶</span><br></pre></td></tr></table></figure>

<p>解法1 的缺陷：</p>
<ul>
<li>上面模拟的是小王等老王的水烧开了，小王泡茶，如果反过来要实现老王等小王的茶叶拿来了，老王泡茶呢？代码最好能适应两种情况</li>
<li>上面的两个线程其实是各执行各的，如果要模拟老王把水壶交给小王泡茶，或模拟小王把茶叶交给老王泡呢</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/08/08/JUC/" data-id="cks69tfsy0001iwuaefbr6q28" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rocketMQ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/28/rocketMQ/" class="article-date">
  <time datetime="2021-07-28T11:48:49.000Z" itemprop="datePublished">2021-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/28/rocketMQ/">rocketMQ</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一，RocetMQ入门篇"><a href="#一，RocetMQ入门篇" class="headerlink" title="一，RocetMQ入门篇"></a>一，RocetMQ入门篇</h1><h2 id="1-MQ介绍"><a href="#1-MQ介绍" class="headerlink" title="1. MQ介绍"></a>1. MQ介绍</h2><h3 id="1-1-为什么要用MQ"><a href="#1-1-为什么要用MQ" class="headerlink" title="1.1 为什么要用MQ"></a>1.1 为什么要用MQ</h3><p>消息队列是一种“先进先出”的数据结构</p>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5Cqueue1.png" alt></p>
<p>其应用场景主要包含以下3个方面</p>
<ul>
<li><strong>应用解耦</strong></li>
</ul>
<p>系统的耦合性越高，容错性就越低。以电商应用为例，用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障或者因为升级等原因暂时不可用，都会造成下单操作异常，影响用户使用体验。</p>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5C%E8%A7%A3%E8%80%A61.png" alt></p>
<p>使用消息队列解耦合，系统的耦合性就会提高了。比如物流系统发生故障，需要几分钟才能来修复，在这段时间内，物流系统要处理的数据被缓存到消息队列中，用户的下单操作正常完成。当物流系统回复后，补充处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障。</p>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5C%E8%A7%A3%E8%80%A62.png" alt></p>
<ul>
<li><strong>流量削峰</strong></li>
</ul>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5Cmq-5.png" alt></p>
<p>应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提到系统的稳定性和用户体验。</p>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5Cmq-6.png" alt></p>
<p>一般情况，为了保证系统的稳定性，如果系统负载超过阈值，就会阻止用户请求，这会影响用户体验，而如果使用消息队列将请求缓存起来，等待系统处理完毕后通知用户下单完毕，这样总不能下单体验要好。</p>
<p> 处于经济考量目的：</p>
<p>业务系统正常时段的QPS如果是1000，流量最高峰是10000，为了应对流量高峰配置高性能的服务器显然不划算，这时可以使用消息队列对峰值流量削峰</p>
<ul>
<li><strong>数据分发</strong></li>
</ul>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5Cmq-1.png" alt></p>
<p>通过消息队列可以让数据在多个系统更加之间进行流通。数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可</p>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5Cmq-2.png" alt></p>
<h3 id="1-2-MQ的优点和缺点"><a href="#1-2-MQ的优点和缺点" class="headerlink" title="1.2 MQ的优点和缺点"></a>1.2 MQ的优点和缺点</h3><p><strong>优点</strong>：解耦、削峰、数据分发</p>
<p><strong>缺点</strong>：</p>
<ul>
<li><p><strong>系统可用性降低</strong></p>
<p>系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。</p>
<p>如何保证MQ的高可用？</p>
</li>
<li><p><strong>系统复杂度提高</strong></p>
<p>MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。</p>
<p>如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？</p>
</li>
<li><p><strong>一致性问题</strong></p>
<p>A系统处理完业务，通过MQ给B、C、D三个系统发消息数据，如果B系统、C系统处理成功，D系统处理失败。</p>
<p>如何保证消息数据处理的一致性？</p>
</li>
</ul>
<h3 id="1-3-各种MQ产品的比较"><a href="#1-3-各种MQ产品的比较" class="headerlink" title="1.3 各种MQ产品的比较"></a>1.3 各种MQ产品的比较</h3><p>常见的MQ产品包括Kafka、ActiveMQ、RabbitMQ、RocketMQ。 </p>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5CMQ%E6%AF%94%E8%BE%83.png" alt></p>
<h2 id="2-RocketMQ快速入门"><a href="#2-RocketMQ快速入门" class="headerlink" title="2. RocketMQ快速入门"></a>2. RocketMQ快速入门</h2><p>RocketMQ是阿里巴巴2016年MQ中间件，使用Java语言开发，在阿里内部，RocketMQ承接了例如“双11”等高并发场景的消息流转，能够处理万亿级别的消息。</p>
<h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h3><h4 id="2-1-1-下载RocketMQ"><a href="#2-1-1-下载RocketMQ" class="headerlink" title="2.1.1 下载RocketMQ"></a>2.1.1 下载RocketMQ</h4><p>RocketMQ最新版本：4.5.1</p>
<p><a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.5.1/rocketmq-all-4.5.1-bin-release.zip" target="_blank" rel="noopener">下载地址</a></p>
<h4 id="2-2-2-环境要求"><a href="#2-2-2-环境要求" class="headerlink" title="2.2.2 环境要求"></a>2.2.2 环境要求</h4><ul>
<li><p>Linux64位系统</p>
</li>
<li><p>JDK1.8(64位)</p>
</li>
<li><p>源码安装需要安装Maven 3.2.x</p>
</li>
</ul>
<h3 id="2-2-安装RocketMQ"><a href="#2-2-安装RocketMQ" class="headerlink" title="2.2 安装RocketMQ"></a>2.2 安装RocketMQ</h3><h4 id="2-2-1-安装步骤"><a href="#2-2-1-安装步骤" class="headerlink" title="2.2.1 安装步骤"></a>2.2.1 安装步骤</h4><p>本教程以二进制包方式安装</p>
<ol>
<li>解压安装包</li>
<li>进入安装目录</li>
</ol>
<h4 id="2-2-2-目录介绍"><a href="#2-2-2-目录介绍" class="headerlink" title="2.2.2 目录介绍"></a>2.2.2 目录介绍</h4><ul>
<li>bin：启动脚本，包括shell脚本和CMD脚本</li>
<li>conf：实例配置文件 ，包括broker配置文件、logback配置文件等</li>
<li>lib：依赖jar包，包括Netty、commons-lang、FastJSON等</li>
</ul>
<h3 id="2-3-启动RocketMQ"><a href="#2-3-启动RocketMQ" class="headerlink" title="2.3 启动RocketMQ"></a>2.3 启动RocketMQ</h3><ol>
<li>启动NameServer</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.启动NameServer</span></span><br><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.查看启动日志</span></span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动Broker</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.启动Broker</span></span><br><span class="line">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.查看启动日志</span></span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>

<ul>
<li><p>问题描述：</p>
<p>RocketMQ默认的虚拟机内存较大，启动Broker如果因为内存不足失败，需要编辑如下两个配置文件，修改JVM内存大小</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编辑runbroker.sh和runserver.sh修改默认JVM大小</span></span><br><span class="line">vi runbroker.sh</span><br><span class="line">vi runserver.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>参考设置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.4 测试RocketMQ</span><br><span class="line"></span><br><span class="line">#### 2.4.1 发送消息</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;sh</span><br><span class="line"># 1.设置环境变量</span><br><span class="line">export NAMESRV_ADDR&#x3D;localhost:9876</span><br><span class="line"># 2.使用安装包的Demo发送消息</span><br><span class="line">sh bin&#x2F;tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-接收消息"><a href="#2-4-2-接收消息" class="headerlink" title="2.4.2 接收消息"></a>2.4.2 接收消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.设置环境变量</span></span><br><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.接收消息</span></span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure>

<h3 id="2-5-关闭RocketMQ"><a href="#2-5-关闭RocketMQ" class="headerlink" title="2.5 关闭RocketMQ"></a>2.5 关闭RocketMQ</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.关闭NameServer</span></span><br><span class="line">sh bin/mqshutdown namesrv</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.关闭Broker</span></span><br><span class="line">sh bin/mqshutdown broker</span><br></pre></td></tr></table></figure>





<h2 id="3-RocketMQ集群搭建"><a href="#3-RocketMQ集群搭建" class="headerlink" title="3. RocketMQ集群搭建"></a>3. RocketMQ集群搭建</h2><h3 id="3-1-各角色介绍"><a href="#3-1-各角色介绍" class="headerlink" title="3.1 各角色介绍"></a>3.1 各角色介绍</h3><ul>
<li><strong>Producer</strong>：消息的发送者；举例：发信者</li>
<li><strong>Consumer</strong>：消息接收者；举例：收信者</li>
<li><strong>Broker</strong>：暂存和传输消息；举例：邮局</li>
<li><strong>NameServer</strong>：管理Broker；举例：各个邮局的管理机构</li>
<li><strong>Topic</strong>：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息</li>
<li><strong>Message Queue</strong>：相当于是Topic的分区；用于并行发送和接收消息</li>
</ul>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5CRocketMQ%E8%A7%92%E8%89%B2.jpg" alt></p>
<h3 id="3-2-集群搭建方式"><a href="#3-2-集群搭建方式" class="headerlink" title="3.2 集群搭建方式"></a>3.2 集群搭建方式</h3><h4 id="3-2-1-集群特点"><a href="#3-2-1-集群特点" class="headerlink" title="3.2.1 集群特点"></a>3.2.1 集群特点</h4><ul>
<li><p>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p>
</li>
<li><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p>
</li>
<li><p>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</p>
</li>
<li><p>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</p>
</li>
</ul>
<h4 id="3-2-3-集群模式"><a href="#3-2-3-集群模式" class="headerlink" title="3.2.3 集群模式"></a>3.2.3 集群模式</h4><h5 id="1）单Master模式"><a href="#1）单Master模式" class="headerlink" title="1）单Master模式"></a>1）单Master模式</h5><p>这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。</p>
<h5 id="2）多Master模式"><a href="#2）多Master模式" class="headerlink" title="2）多Master模式"></a>2）多Master模式</h5><p>一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：</p>
<ul>
<li><strong>优点</strong>：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li>
<li><strong>缺点</strong>：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li>
</ul>
<h5 id="3）多Master多Slave模式（异步）"><a href="#3）多Master多Slave模式（异步）" class="headerlink" title="3）多Master多Slave模式（异步）"></a>3）多Master多Slave模式（异步）</h5><p>每个Master配置一个Slave，有多对Master-Slave，HA采用<strong>异步复制</strong>方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>
<ul>
<li><strong>优点</strong>：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时<strong>Master宕机后，消费者仍然可以从Slave消费</strong>，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；</li>
<li><strong>缺点</strong>：Master宕机，磁盘损坏情况下会丢失少量消息。</li>
</ul>
<h5 id="4）多Master多Slave模式（同步）"><a href="#4）多Master多Slave模式（同步）" class="headerlink" title="4）多Master多Slave模式（同步）"></a>4）多Master多Slave模式（同步）</h5><p>每个Master配置一个Slave，有多对Master-Slave，HA采用<strong>同步双写</strong>方式，即<strong>只有主备都写成功，才向应用返回成功</strong>，这种模式的优缺点如下：</p>
<ul>
<li><strong>优点</strong>：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</li>
<li><strong>缺点</strong>：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li>
</ul>
<h3 id="3-3-双主双从集群搭建"><a href="#3-3-双主双从集群搭建" class="headerlink" title="3.3 双主双从集群搭建"></a>3.3 双主双从集群搭建</h3><h4 id="3-3-1-总体架构"><a href="#3-3-1-总体架构" class="headerlink" title="3.3.1 总体架构"></a>3.3.1 总体架构</h4><p>消息高可用采用2m-2s（同步双写）方式</p>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5CRocketMQ%E9%9B%86%E7%BE%A4.png" alt></p>
<h4 id="3-3-2-集群工作流程"><a href="#3-3-2-集群工作流程" class="headerlink" title="3.3.2 集群工作流程"></a>3.3.2 集群工作流程</h4><ol>
<li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li>
<li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li>
<li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ol>
<h4 id="3-3-3-服务器环境"><a href="#3-3-3-服务器环境" class="headerlink" title="3.3.3 服务器环境"></a>3.3.3 服务器环境</h4><table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>IP</strong></th>
<th><strong>角色</strong></th>
<th><strong>架构模式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>192.168.25.135</td>
<td>nameserver、brokerserver</td>
<td>Master1、Slave2</td>
</tr>
<tr>
<td>2</td>
<td>192.168.25.138</td>
<td>nameserver、brokerserver</td>
<td>Master2、Slave1</td>
</tr>
</tbody></table>
<h4 id="3-3-4-Host添加信息"><a href="#3-3-4-Host添加信息" class="headerlink" title="3.3.4 Host添加信息"></a>3.3.4 Host添加信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>

<p>配置如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nameserver</span></span><br><span class="line">192.168.25.135 rocketmq-nameserver1</span><br><span class="line">192.168.25.138 rocketmq-nameserver2</span><br><span class="line"><span class="comment"># broker</span></span><br><span class="line">192.168.25.135 rocketmq-master1</span><br><span class="line">192.168.25.135 rocketmq-slave2</span><br><span class="line">192.168.25.138 rocketmq-master2</span><br><span class="line">192.168.25.138 rocketmq-slave1</span><br></pre></td></tr></table></figure>

<p>配置完成后, 重启网卡</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<h4 id="3-3-5-防火墙配置"><a href="#3-3-5-防火墙配置" class="headerlink" title="3.3.5 防火墙配置"></a>3.3.5 防火墙配置</h4><p>宿主机需要远程访问虚拟机的rocketmq服务和web服务，需要开放相关的端口号，简单粗暴的方式是直接关闭防火墙</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service </span><br><span class="line"><span class="comment"># 查看防火墙的状态</span></span><br><span class="line">firewall-cmd --state </span><br><span class="line"><span class="comment"># 禁止firewall开机启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure>

<p>或者为了安全，只开放特定的端口号，RocketMQ默认使用3个端口：9876 、10911 、11011 。如果防火墙没有关闭的话，那么防火墙就必须开放这些端口：</p>
<ul>
<li><code>nameserver</code> 默认使用 9876 端口</li>
<li><code>master</code> 默认使用 10911 端口</li>
<li><code>slave</code> 默认使用11011 端口</li>
</ul>
<p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放name server默认端口</span></span><br><span class="line">firewall-cmd --remove-port=9876/tcp --permanent</span><br><span class="line"><span class="comment"># 开放master默认端口</span></span><br><span class="line">firewall-cmd --remove-port=10911/tcp --permanent</span><br><span class="line"><span class="comment"># 开放slave默认端口 (当前集群模式可不开启)</span></span><br><span class="line">firewall-cmd --remove-port=11011/tcp --permanent </span><br><span class="line"><span class="comment"># 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h4 id="3-3-6-环境变量配置"><a href="#3-3-6-环境变量配置" class="headerlink" title="3.3.6 环境变量配置"></a>3.3.6 环境变量配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>在profile文件的末尾加入如下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set rocketmq</span></span><br><span class="line">ROCKETMQ_HOME=/usr/<span class="built_in">local</span>/rocketmq/rocketmq-all-4.4.0-bin-release</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$ROCKETMQ_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> ROCKETMQ_HOME PATH</span><br></pre></td></tr></table></figure>

<p>输入:wq! 保存并退出， 并使得配置立刻生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h4 id="3-3-7-创建消息存储路径"><a href="#3-3-7-创建消息存储路径" class="headerlink" title="3.3.7 创建消息存储路径"></a>3.3.7 创建消息存储路径</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store/commitlog</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store/index</span><br></pre></td></tr></table></figure>

<h4 id="3-3-8-broker配置文件"><a href="#3-3-8-broker配置文件" class="headerlink" title="3.3.8 broker配置文件"></a>3.3.8 broker配置文件</h4><h5 id="1）master1"><a href="#1）master1" class="headerlink" title="1）master1"></a>1）master1</h5><p>服务器：192.168.25.135</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-a.properties</span><br></pre></td></tr></table></figure>

<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker<span class="_">-a</span></span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SYNC_MASTER</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=SYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<h5 id="2）slave2"><a href="#2）slave2" class="headerlink" title="2）slave2"></a>2）slave2</h5><p>服务器：192.168.25.135</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-b-s.properties</span><br></pre></td></tr></table></figure>

<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker-b</span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=1</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=11011</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<h5 id="3）master2"><a href="#3）master2" class="headerlink" title="3）master2"></a>3）master2</h5><p>服务器：192.168.25.138</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-b.properties</span><br></pre></td></tr></table></figure>

<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker-b</span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SYNC_MASTER</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=SYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<h5 id="4）slave1"><a href="#4）slave1" class="headerlink" title="4）slave1"></a>4）slave1</h5><p>服务器：192.168.25.138</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/soft/rocketmq/conf/2m-2s-sync/broker<span class="_">-a</span>-s.properties</span><br></pre></td></tr></table></figure>

<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker<span class="_">-a</span></span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=1</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=11011</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-9-修改启动脚本文件"><a href="#3-3-9-修改启动脚本文件" class="headerlink" title="3.3.9 修改启动脚本文件"></a>3.3.9 修改启动脚本文件</h4><h5 id="1）runbroker-sh"><a href="#1）runbroker-sh" class="headerlink" title="1）runbroker.sh"></a>1）runbroker.sh</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/<span class="built_in">local</span>/rocketmq/bin/runbroker.sh</span><br></pre></td></tr></table></figure>

<p>需要根据内存大小进行适当的对JVM参数进行调整：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#===================================================</span></span><br><span class="line"><span class="comment"># 开发环境配置 JVM Configuration</span></span><br><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m"</span></span><br></pre></td></tr></table></figure>

<p>####2）runserver.sh</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/rocketmq/bin/runserver.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-10-服务启动"><a href="#3-3-10-服务启动" class="headerlink" title="3.3.10 服务启动"></a>3.3.10 服务启动</h4><h5 id="1）启动NameServe集群"><a href="#1）启动NameServe集群" class="headerlink" title="1）启动NameServe集群"></a>1）启动NameServe集群</h5><p>分别在192.168.25.135和192.168.25.138启动NameServer</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</span><br><span class="line">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>

<h5 id="2）启动Broker集群"><a href="#2）启动Broker集群" class="headerlink" title="2）启动Broker集群"></a>2）启动Broker集群</h5><ul>
<li>在192.168.25.135上启动master1和slave2</li>
</ul>
<p>master1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</span><br><span class="line">nohup sh mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-syncbroker-a.properties &amp;</span><br></pre></td></tr></table></figure>

<p>slave2：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</span><br><span class="line">nohup sh mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-sync/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>在192.168.25.138上启动master2和slave2</li>
</ul>
<p>master2</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</span><br><span class="line">nohup sh mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-sync/broker-b.properties &amp;</span><br></pre></td></tr></table></figure>

<p>slave1</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</span><br><span class="line">nohup sh mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-sync/broker<span class="_">-a</span>-s.properties &amp;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-11-查看进程状态"><a href="#3-3-11-查看进程状态" class="headerlink" title="3.3.11 查看进程状态"></a>3.3.11 查看进程状态</h4><p>启动后通过JPS查看启动进程</p>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5Cjps1.png" alt></p>
<h4 id="3-3-12-查看日志"><a href="#3-3-12-查看日志" class="headerlink" title="3.3.12 查看日志"></a>3.3.12 查看日志</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看nameServer日志</span></span><br><span class="line">tail -500f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line"><span class="comment"># 查看broker日志</span></span><br><span class="line">tail -500f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>



<h3 id="3-4-mqadmin管理工具"><a href="#3-4-mqadmin管理工具" class="headerlink" title="3.4 mqadmin管理工具"></a>3.4 mqadmin管理工具</h3><h4 id="3-4-1-使用方式"><a href="#3-4-1-使用方式" class="headerlink" title="3.4.1 使用方式"></a>3.4.1 使用方式</h4><p>进入RocketMQ安装位置，在bin目录下执行<code>./mqadmin {command} {args}</code> </p>
<h4 id="3-4-2-命令介绍"><a href="#3-4-2-命令介绍" class="headerlink" title="3.4.2 命令介绍"></a>3.4.2 命令介绍</h4><h5 id="1）Topic相关"><a href="#1）Topic相关" class="headerlink" title="1）Topic相关"></a>1）Topic相关</h5><table border="0" cellpadding="0" cellspacing="0" width="714">
 <col width="177">
 <col width="175">
 <col width="177">
 <col width="185">
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl63" width="177" style="height:17.0pt;width:133pt">名称</td>
  <td class="xl64" width="175" style="width:131pt">含义</td>
  <td class="xl64" width="177" style="width:133pt">命令选项</td>
  <td class="xl64" width="185" style="width:139pt">说明</td>
 </tr>
 <tr height="132" style="height:99.0pt">
  <td rowspan="8" height="593" class="xl68" width="163" style="border-bottom:1.0pt;
  height:444.0pt;border-top:none;width:122pt">updateTopic</td>
  <td rowspan="8" class="xl70" width="135" style="border-bottom:1.0pt;
  border-top:none;width:101pt">创建更新Topic配置</td>
  <td class="xl65" width="149" style="width:112pt">-b</td>
  <td class="xl66" width="159" style="width:119pt">Broker 地址，表示 topic 所在
  Broker，只支持单台Broker，地址为ip:port</td>
 </tr>
 <tr height="132" style="height:99.0pt">
  <td height="132" class="xl65" width="149" style="height:99.0pt;width:112pt">-c</td>
  <td class="xl66" width="159" style="width:119pt">cluster 名称，表示 topic 所在集群（集群可通过
  clusterList 查询）</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl65" width="149" style="height:17.0pt;width:112pt">-h-</td>
  <td class="xl66" width="159" style="width:119pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="149" style="height:43.0pt;width:112pt">-n</td>
  <td class="xl66" width="159" style="width:119pt">NameServer服务地址，格式 ip:port</td>
 </tr>
 <tr height="76" style="height:57.0pt">
  <td height="76" class="xl65" width="149" style="height:57.0pt;width:112pt">-p</td>
  <td class="xl66" width="159" style="width:119pt">指定新topic的读写权限( W=2|R=4|WR=6 )</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl65" width="149" style="height:29.0pt;width:112pt">-r</td>
  <td class="xl66" width="159" style="width:119pt">可读队列数（默认为 8）</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl65" width="149" style="height:29.0pt;width:112pt">-w</td>
  <td class="xl66" width="159" style="width:119pt">可写队列数（默认为 8）</td>
 </tr>
 <tr height="95" style="height:71.0pt">
  <td height="95" class="xl65" width="149" style="height:71.0pt;width:112pt">-t</td>
  <td class="xl66" width="159" style="width:119pt">topic 名称（名称只能使用字符
  ^[a-zA-Z0-9_-]+$ ）</td>
 </tr>
 <tr height="132" style="height:99.0pt">
  <td rowspan="4" height="307" class="xl68" width="163" style="border-bottom:1.0pt;
  height:230.0pt;border-top:none;width:122pt">deleteTopic</td>
  <td rowspan="4" class="xl70" width="135" style="border-bottom:1.0pt;
  border-top:none;width:101pt">删除Topic</td>
  <td class="xl65" width="149" style="width:112pt">-c</td>
  <td class="xl66" width="159" style="width:119pt">cluster 名称，表示删除某集群下的某个 topic （集群
  可通过 clusterList 查询）</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl65" width="149" style="height:17.0pt;width:112pt">-h</td>
  <td class="xl66" width="159" style="width:119pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="149" style="height:43.0pt;width:112pt">-n</td>
  <td class="xl66" width="159" style="width:119pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="95" style="height:71.0pt">
  <td height="95" class="xl65" width="149" style="height:71.0pt;width:112pt">-t</td>
  <td class="xl66" width="159" style="width:119pt">topic 名称（名称只能使用字符
  ^[a-zA-Z0-9_-]+$ ）</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="3" height="287" class="xl68" width="163" style="border-bottom:1.0pt;
  height:215.0pt;border-top:none;width:122pt">topicList</td>
  <td rowspan="3" class="xl70" width="135" style="border-bottom:1.0pt;
  border-top:none;width:101pt">查看 Topic 列表信息</td>
  <td class="xl65" width="149" style="width:112pt">-h</td>
  <td class="xl66" width="159" style="width:119pt">打印帮助</td>
 </tr>
 <tr height="207" style="height:155.0pt">
  <td height="207" class="xl65" width="149" style="height:155.0pt;width:112pt">-c</td>
  <td class="xl66" width="159" style="width:119pt">不配置-c只返回topic列表，增加-c返回clusterName,
  topic, consumerGroup信息，即topic的所属集群和订阅关系，没有参数</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="149" style="height:43.0pt;width:112pt">-n</td>
  <td class="xl66" width="159" style="width:119pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="3" height="103" class="xl68" width="163" style="border-bottom:1.0pt;
  height:77.0pt;border-top:none;width:122pt">topicRoute</td>
  <td rowspan="3" class="xl70" width="135" style="border-bottom:1.0pt;
  border-top:none;width:101pt">查看 Topic 路由信息</td>
  <td class="xl65" width="149" style="width:112pt">-t</td>
  <td class="xl66" width="159" style="width:119pt">topic 名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl65" width="149" style="height:17.0pt;width:112pt">-h</td>
  <td class="xl66" width="159" style="width:119pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="149" style="height:43.0pt;width:112pt">-n</td>
  <td class="xl66" width="159" style="width:119pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="3" height="103" class="xl68" width="163" style="border-bottom:1.0pt;
  height:77.0pt;border-top:none;width:122pt">topicStatus</td>
  <td rowspan="3" class="xl70" width="135" style="border-bottom:1.0pt;
  border-top:none;width:101pt">查看 Topic 消息队列offset</td>
  <td class="xl65" width="149" style="width:112pt">-t</td>
  <td class="xl66" width="159" style="width:119pt">topic 名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl65" width="149" style="height:17.0pt;width:112pt">-h</td>
  <td class="xl66" width="159" style="width:119pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="149" style="height:43.0pt;width:112pt">-n</td>
  <td class="xl66" width="159" style="width:119pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="3" height="103" class="xl68" width="163" style="border-bottom:1.0pt;
  height:77.0pt;border-top:none;width:122pt">topicClusterList</td>
  <td rowspan="3" class="xl70" width="135" style="border-bottom:1.0pt;
  border-top:none;width:101pt">查看 Topic 所在集群列表</td>
  <td class="xl65" width="149" style="width:112pt">-t</td>
  <td class="xl66" width="159" style="width:119pt">topic 名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl65" width="149" style="height:17.0pt;width:112pt">-h</td>
  <td class="xl66" width="159" style="width:119pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="149" style="height:43.0pt;width:112pt">-n</td>
  <td class="xl66" width="159" style="width:119pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="6" height="518" class="xl68" width="163" style="border-bottom:1.0pt;
  height:380pt;border-top:none;width:122pt">updateTopicPerm</td>
  <td rowspan="6" class="xl70" width="135" style="border-bottom:1.0pt;
  border-top:none;width:101pt">更新 Topic 读写权限</td>
  <td class="xl65" width="149" style="width:112pt">-t</td>
  <td class="xl66" width="159" style="width:119pt">topic 名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl65" width="149" style="height:17.0pt;width:112pt">-h</td>
  <td class="xl66" width="159" style="width:119pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="149" style="height:43.0pt;width:112pt">-n</td>
  <td class="xl66" width="159" style="width:119pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="132" style="height:99.0pt">
  <td height="132" class="xl65" width="149" style="height:99.0pt;width:112pt">-b</td>
  <td class="xl66" width="159" style="width:119pt">Broker 地址，表示 topic 所在
  Broker，只支持单台Broker，地址为ip:port</td>
 </tr>
 <tr height="76" style="height:57.0pt">
  <td height="76" class="xl65" width="149" style="height:57.0pt;width:112pt">-p</td>
  <td class="xl66" width="159" style="width:119pt">指定新 topic 的读写权限( W=2|R=4|WR=6 )</td>
 </tr>
 <tr height="207" style="height:155.0pt">
  <td height="207" class="xl65" width="149" style="height:155.0pt;width:112pt">-c</td>
  <td class="xl66" width="159" style="width:119pt">cluster 名称，表示 topic 所在集群（集群可通过
  clusterList 查询），-b优先，如果没有-b，则对集群中所有Broker执行命令</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="5" height="199" class="xl68" width="163" style="border-bottom:1.0pt;
  height:149.0pt;border-top:none;width:122pt">updateOrderConf</td>
  <td rowspan="5" class="xl70" width="135" style="border-bottom:1.0pt;
  border-top:none;width:101pt">从NameServer上创建、删除、获取特定命名空间的kv配置，目前还未启用</td>
  <td class="xl65" width="149" style="width:112pt">-h</td>
  <td class="xl66" width="159" style="width:119pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="149" style="height:43.0pt;width:112pt">-n</td>
  <td class="xl66" width="159" style="width:119pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl65" width="149" style="height:17.0pt;width:112pt">-t</td>
  <td class="xl66" width="159" style="width:119pt">topic，键</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl65" width="149" style="height:29.0pt;width:112pt">-v</td>
  <td class="xl66" width="159" style="width:119pt">orderConf，值</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="149" style="height:43.0pt;width:112pt">-m</td>
  <td class="xl66" width="159" style="width:119pt">method，可选get、put、delete</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="4" height="198" class="xl68" width="163" style="border-bottom:1.0pt;
  height:140pt;border-top:none;width:122pt">allocateMQ</td>
  <td rowspan="4" class="xl70" width="135" style="border-bottom:1.0pt;
  border-top:none;width:101pt">以平均负载算法计算消费者列表负载消息队列的负载结果</td>
  <td class="xl65" width="149" style="width:112pt">-t</td>
  <td class="xl66" width="159" style="width:119pt">topic 名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl65" width="149" style="height:17.0pt;width:112pt">-h</td>
  <td class="xl66" width="159" style="width:119pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="149" style="height:43.0pt;width:112pt">-n</td>
  <td class="xl66" width="159" style="width:119pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="95" style="height:71.0pt">
  <td height="95" class="xl65" width="149" style="height:71.0pt;width:112pt">-i</td>
  <td class="xl66" width="159" style="width:119pt">ipList，用逗号分隔，计算这些ip去负载Topic的消息队列</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="4" height="142" class="xl68" width="163" style="border-bottom:1.0pt solid black;
  height:106.0pt;border-top:1.0pt;width:122pt">statsAll</td>
  <td rowspan="4" class="xl70" width="135" style="border-bottom:1.0pt;
  border-top:none;width:101pt">打印Topic订阅关系、TPS、积累量、24h读写总量等信息</td>
  <td class="xl65" width="149" style="width:112pt">-h</td>
  <td class="xl66" width="159" style="width:119pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="149" style="height:43.0pt;width:112pt">-n</td>
  <td class="xl66" width="159" style="width:119pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl65" width="149" style="height:29.0pt;width:112pt">-a</td>
  <td class="xl66" width="159" style="width:119pt">是否只打印活跃topic</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl65" width="149" style="height:17.0pt;width:112pt">-t</td>
  <td class="xl66" width="159" style="width:119pt">指定topic</td>
 </tr>
</table>

<h5 id="2）集群相关"><a href="#2）集群相关" class="headerlink" title="2）集群相关"></a>2）集群相关</h5><table border="0" cellpadding="0" cellspacing="0" width="714">
 <col width="177">
 <col width="175">
 <col width="177">
 <col width="185">
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl63" width="177" style="height:17.0pt;width:133pt">名称</td>
  <td class="xl64" width="175" style="width:131pt">含义</td>
  <td class="xl64" width="177" style="width:133pt">命令选项</td>
  <td class="xl64" width="185" style="width:139pt">说明</td>
 </tr>
 <tr height="207" style="height:155.0pt">
  <td rowspan="4" height="326" class="xl67" width="177" style="border-bottom:1.0pt;
  height:244.0pt;border-top:none;width:133pt"><span style="mso-spacerun:yes"> </span>clusterList</td>
  <td rowspan="4" class="xl70" width="175" style="border-bottom:1.0pt;
  border-top:none;width:131pt">查看集群信息，集群、BrokerName、BrokerId、TPS等信息</td>
  <td class="xl65" width="177" style="width:133pt">-m</td>
  <td class="xl66" width="185" style="width:139pt">打印更多信息 (增加打印出如下信息 #InTotalYest,
  #OutTotalYest, #InTotalToday ,#OutTotalToday)</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl65" width="177" style="height:17.0pt;width:133pt">-h</td>
  <td class="xl66" width="185" style="width:139pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="177" style="height:43.0pt;width:133pt">-n</td>
  <td class="xl66" width="185" style="width:139pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl65" width="177" style="height:29.0pt;width:133pt">-i</td>
  <td class="xl66" width="185" style="width:139pt">打印间隔，单位秒</td>
 </tr>
 <tr height="95" style="height:71.0pt">
  <td rowspan="8" height="391" class="xl67" width="177" style="border-bottom:1.0pt;
  height:292.0pt;border-top:none;width:133pt">clusterRT</td>
  <td rowspan="8" class="xl70" width="175" style="border-bottom:1.0pt;
  border-top:none;width:131pt">发送消息检测集群各Broker RT。消息发往${BrokerName} Topic。</td>
  <td class="xl65" width="177" style="width:133pt">-a</td>
  <td class="xl66" width="185" style="width:139pt">amount，每次探测的总数，RT = 总时间 /
  amount</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl65" width="177" style="height:29.0pt;width:133pt">-s</td>
  <td class="xl66" width="185" style="width:139pt">消息大小，单位B</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl65" width="177" style="height:17.0pt;width:133pt">-c</td>
  <td class="xl66" width="185" style="width:139pt">探测哪个集群</td>
 </tr>
 <tr height="76" style="height:57.0pt">
  <td height="76" class="xl65" width="177" style="height:57.0pt;width:133pt">-p</td>
  <td class="xl66" width="185" style="width:139pt">是否打印格式化日志，以|分割，默认不打印</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl65" width="177" style="height:17.0pt;width:133pt">-h</td>
  <td class="xl66" width="185" style="width:139pt">打印帮助</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl65" width="177" style="height:29.0pt;width:133pt">-m</td>
  <td class="xl66" width="185" style="width:139pt">所属机房，打印使用</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl65" width="177" style="height:29.0pt;width:133pt">-i</td>
  <td class="xl66" width="185" style="width:139pt">发送间隔，单位秒</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl65" width="177" style="height:43.0pt;width:133pt">-n</td>
  <td class="xl66" width="185" style="width:139pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
</table>

<h5 id="3）Broker相关"><a href="#3）Broker相关" class="headerlink" title="3）Broker相关"></a>3）Broker相关</h5><table border="0" cellpadding="0" cellspacing="0" width="714">
 <col width="177">
 <col width="175">
 <col width="177">
 <col width="185">
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl63" width="177" style="height:17.0pt;width:133pt">名称</td>
  <td class="xl64" width="175" style="width:131pt">含义</td>
  <td class="xl64" width="177" style="width:133pt">命令选项</td>
  <td class="xl64" width="185" style="width:139pt">说明</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="6" height="206" class="xl69" width="191" style="border-bottom:1.0pt;
  height:154.0pt;border-top:none;width:143pt">updateBrokerConfig</td>
  <td rowspan="6" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">更新 Broker 配置文件，会修改Broker.conf</td>
  <td class="xl67" width="87" style="width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">Broker 地址，格式为ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-c</td>
  <td class="xl68" width="87" style="width:65pt">cluster 名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-k</td>
  <td class="xl68" width="87" style="width:65pt">key 值</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-v</td>
  <td class="xl68" width="87" style="width:65pt">value 值</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="3" height="137" class="xl69" width="191" style="border-bottom:1.0pt;
  height:103.0pt;border-top:none;width:143pt">brokerStatus</td>
  <td rowspan="3" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">查看 Broker 统计信息、运行状态（你想要的信息几乎都在里面）</td>
  <td class="xl67" width="87" style="width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">Broker 地址，地址为ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="6" height="256" class="xl69" width="191" style="border-bottom:1.0pt;
  height:192.0pt;border-top:none;width:143pt">brokerConsumeStats</td>
  <td rowspan="6" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">Broker中各个消费者的消费情况，按Message Queue维度返回Consume
  Offset，Broker Offset，Diff，TImestamp等信息</td>
  <td class="xl67" width="87" style="width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">Broker 地址，地址为ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">请求超时时间</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-l</td>
  <td class="xl68" width="87" style="width:65pt">diff阈值，超过阈值才打印</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-o</td>
  <td class="xl68" width="87" style="width:65pt">是否为顺序topic，一般为false</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="2" height="114" class="xl69" width="191" style="border-bottom:1.0pt;
  height:86.0pt;border-top:none;width:143pt">getBrokerConfig</td>
  <td rowspan="2" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">获取Broker配置</td>
  <td class="xl67" width="87" style="width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">Broker 地址，地址为ip:port</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="3" height="137" class="xl69" width="191" style="border-bottom:1.0pt;
  height:103.0pt;border-top:none;width:143pt">wipeWritePerm</td>
  <td rowspan="3" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">从NameServer上清除 Broker写权限</td>
  <td class="xl67" width="87" style="width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">Broker 地址，地址为ip:port</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="4" height="160" class="xl69" width="191" style="border-bottom:1.0pt;
  height:120.0pt;border-top:none;width:143pt">cleanExpiredCQ</td>
  <td rowspan="4" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">清理Broker上过期的Consume Queue，如果手动减少对列数可能产生过期队列</td>
  <td class="xl67" width="87" style="width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">Broker 地址，地址为ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-c</td>
  <td class="xl68" width="87" style="width:65pt">集群名称</td>
 </tr>
 <tr height="88" style="mso-height-source:userset;height:66.0pt">
  <td rowspan="4" height="191" class="xl69" width="191" style="border-bottom:1.0pt;
  height:143.0pt;border-top:none;width:143pt">cleanUnusedTopic</td>
  <td rowspan="4" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">清理Broker上不使用的Topic，从内存中释放Topic的Consume
  Queue，如果手动删除Topic会产生不使用的Topic</td>
  <td class="xl67" width="87" style="width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">Broker 地址，地址为ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-c</td>
  <td class="xl68" width="87" style="width:65pt">集群名称</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="5" height="199" class="xl69" width="191" style="border-bottom:1.0pt;
  height:149.0pt;border-top:none;width:143pt">sendMsgStatus</td>
  <td rowspan="5" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">向Broker发消息，返回发送状态和RT</td>
  <td class="xl67" width="87" style="width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">BrokerName，注意不同于Broker地址</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-s</td>
  <td class="xl68" width="87" style="width:65pt">消息大小，单位B</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-c</td>
  <td class="xl68" width="87" style="width:65pt">发送次数</td>
 </tr>
</table>

<h5 id="4）消息相关"><a href="#4）消息相关" class="headerlink" title="4）消息相关"></a>4）消息相关</h5><table border="0" cellpadding="0" cellspacing="0" width="714">
 <col width="177">
 <col width="175">
 <col width="177">
 <col width="185">
<tr height="23" style="height:17.0pt">
  <td height="23" class="xl63" width="177" style="height:17.0pt;width:133pt">名称</td>
  <td class="xl64" width="175" style="width:131pt">含义</td>
  <td class="xl64" width="177" style="width:133pt">命令选项</td>
  <td class="xl64" width="185" style="width:139pt">说明</td>
 </tr>
 <tr height="128" style="height:96.0pt">
  <td rowspan="3" height="208" class="xl69" width="87" style="border-bottom:1.0pt;
  height:156.0pt;border-top:none;width:65pt">queryMsgById</td>
  <td rowspan="3" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">根据offsetMsgId查询msg，如果使用开源控制台，应使用offsetMsgId，此命令还有其他参数，具体作用请阅读QueryMsgByIdSubCommand。</td>
  <td class="xl67" width="87" style="width:65pt">-i</td>
  <td class="xl67" width="87" style="width:65pt">msgId</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="4" height="126" class="xl69" width="87" style="border-bottom:1.0pt;
  height:94.0pt;border-top:none;width:65pt">queryMsgByKey</td>
  <td rowspan="4" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">根据消息 Key 查询消息</td>
  <td class="xl67" width="87" style="width:65pt">-k</td>
  <td class="xl67" width="87" style="width:65pt">msgKey</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">Topic 名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="225" style="height:169.0pt">
  <td rowspan="6" height="390" class="xl69" width="87" style="border-bottom:1.0pt;
  height:292.0pt;border-top:none;width:65pt">queryMsgByOffset</td>
  <td rowspan="6" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">根据 Offset 查询消息</td>
  <td class="xl67" width="87" style="width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">Broker 名称，（这里需要注意
  填写的是 Broker 的名称，不是 Broker 的地址，Broker 名称可以在 clusterList 查到）</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-i</td>
  <td class="xl68" width="87" style="width:65pt">query 队列 id</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-o</td>
  <td class="xl68" width="87" style="width:65pt">offset 值</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">topic 名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="47">
  <td rowspan="6" height="209" class="xl69" width="87" style="border-bottom:1.0pt;
  height:156.0pt;border-top:none;width:65pt">queryMsgByUniqueKey</td>
  <td rowspan="6" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">根据msgId查询，msgId不同于offsetMsgId，区别详见常见运维问题。-g，-d配合使用，查到消息后尝试让特定的消费者消费消息并返回消费结果</td>
  <td class="xl67" width="87" style="width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-i</td>
  <td class="xl67" width="87" style="width:65pt">uniqe msg id</td>
 </tr>
 <tr height="36" style="height:27.0pt">
  <td height="36" class="xl67" width="87" style="height:27.0pt;width:65pt">-g</td>
  <td class="xl67" width="87" style="width:65pt">consumerGroup</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-d</td>
  <td class="xl67" width="87" style="width:65pt">clientId</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">topic名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="5" height="149" class="xl69" width="87" style="border-bottom:1.0pt
  height:111.0pt;border-top:none;width:65pt">checkMsgSendRT</td>
  <td rowspan="5" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">检测向topic发消息的RT，功能类似clusterRT</td>
  <td class="xl67" width="87" style="width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">topic名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-a</td>
  <td class="xl68" width="87" style="width:65pt">探测次数</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-s</td>
  <td class="xl68" width="87" style="width:65pt">消息大小</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="8" height="218" class="xl69" width="87" style="border-bottom:1.0pt;
  height:162.0pt;border-top:none;width:65pt">sendMessage</td>
  <td rowspan="8" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">发送一条消息，可以根据配置发往特定Message Queue，或普通发送。</td>
  <td class="xl67" width="87" style="width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">topic名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-p</td>
  <td class="xl68" width="87" style="width:65pt">body，消息体</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-k</td>
  <td class="xl67" width="87" style="width:65pt">keys</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-c</td>
  <td class="xl67" width="87" style="width:65pt">tags</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-b</td>
  <td class="xl67" width="87" style="width:65pt">BrokerName</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-i</td>
  <td class="xl67" width="87" style="width:65pt">queueId</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="10" height="312" class="xl69" width="87" style="border-bottom:1.0pt;
  height:232.0pt;border-top:none;width:65pt">consumeMessage</td>
  <td rowspan="10" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">消费消息。可以根据offset、开始&amp;结束时间戳、消息队列消费消息，配置不同执行不同消费逻辑，详见ConsumeMessageCommand。</td>
  <td class="xl67" width="87" style="width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">topic名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-b</td>
  <td class="xl67" width="87" style="width:65pt">BrokerName</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-o</td>
  <td class="xl68" width="87" style="width:65pt">从offset开始消费</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-i</td>
  <td class="xl67" width="87" style="width:65pt">queueId</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-g</td>
  <td class="xl68" width="87" style="width:65pt">消费者分组</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-s</td>
  <td class="xl68" width="87" style="width:65pt">开始时间戳，格式详见-h</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-d</td>
  <td class="xl68" width="87" style="width:65pt">结束时间戳</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-c</td>
  <td class="xl68" width="87" style="width:65pt">消费多少条消息</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="8" height="282" class="xl69" width="87" style="border-bottom:1.0pt;
  height:210.0pt;border-top:none;width:65pt">printMsg</td>
  <td rowspan="8" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">从Broker消费消息并打印，可选时间段</td>
  <td class="xl67" width="87" style="width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">topic名称</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-c</td>
  <td class="xl68" width="87" style="width:65pt">字符集，例如UTF-8</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-s</td>
  <td class="xl68" width="87" style="width:65pt">subExpress，过滤表达式</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">开始时间戳，格式参见-h</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-e</td>
  <td class="xl68" width="87" style="width:65pt">结束时间戳</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-d</td>
  <td class="xl68" width="87" style="width:65pt">是否打印消息体</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="12" height="390" class="xl69" width="87" style="border-bottom:1.0pt;
  height:290.0pt;border-top:none;width:65pt">printMsgByQueue</td>
  <td rowspan="12" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">类似printMsg，但指定Message Queue</td>
  <td class="xl67" width="87" style="width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">topic名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-i</td>
  <td class="xl67" width="87" style="width:65pt">queueId</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-a</td>
  <td class="xl67" width="87" style="width:65pt">BrokerName</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-c</td>
  <td class="xl68" width="87" style="width:65pt">字符集，例如UTF-8</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-s</td>
  <td class="xl68" width="87" style="width:65pt">subExpress，过滤表达式</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">开始时间戳，格式参见-h</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-e</td>
  <td class="xl68" width="87" style="width:65pt">结束时间戳</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-p</td>
  <td class="xl68" width="87" style="width:65pt">是否打印消息</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-d</td>
  <td class="xl68" width="87" style="width:65pt">是否打印消息体</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-f</td>
  <td class="xl68" width="87" style="width:65pt">是否统计tag数量并打印</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="7" height="410" class="xl69" width="87" style="border-bottom:1.0pt;
  height:307.0pt;border-top:none;width:65pt">resetOffsetByTime</td>
  <td rowspan="7" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">按时间戳重置offset，Broker和consumer都会重置</td>
  <td class="xl67" width="87" style="width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-g</td>
  <td class="xl68" width="87" style="width:65pt">消费者分组</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">topic名称</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-s</td>
  <td class="xl68" width="87" style="width:65pt">重置为此时间戳对应的offset</td>
 </tr>
 <tr height="188" style="height:141.0pt">
  <td height="188" class="xl67" width="87" style="height:141.0pt;width:65pt">-f</td>
  <td class="xl68" width="87" style="width:65pt">是否强制重置，如果false，只支持回溯offset，如果true，不管时间戳对应offset与consumeOffset关系</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-c</td>
  <td class="xl68" width="87" style="width:65pt">是否重置c++客户端offset</td>
 </tr>
</table>


<h5 id="5）消费者、消费组相关"><a href="#5）消费者、消费组相关" class="headerlink" title="5）消费者、消费组相关"></a>5）消费者、消费组相关</h5><table border="0" cellpadding="0" cellspacing="0" width="714">
 <col width="177">
 <col width="175">
 <col width="177">
 <col width="185">
<tr height="23" style="height:17.0pt">
  <td height="23" class="xl63" width="177" style="height:17.0pt;width:133pt">名称</td>
  <td class="xl64" width="175" style="width:131pt">含义</td>
  <td class="xl64" width="177" style="width:133pt">命令选项</td>
  <td class="xl64" width="185" style="width:139pt">说明</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td rowspan="4" height="158" class="xl69" width="87" style="border-bottom:1.0pt;
  height:110pt;border-top:none;width:65pt">consumerProgress</td>
  <td rowspan="4" class="xl72" width="87" style="border-bottom:1.0pt;
  border-top:none;width:65pt">查看订阅组消费状态，可以查看具体的client IP的消息积累量</td>
  <td class="xl67" width="87" style="width:65pt">-g</td>
  <td class="xl68" width="87" style="width:65pt">消费者所属组名</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-s</td>
  <td class="xl68" width="87" style="width:65pt">是否打印client IP</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="105" style="mso-height-source:userset;height:79.0pt">
  <td rowspan="5" height="260" class="xl69" width="87" style="border-bottom:1.0pt;
  height:195.0pt;border-top:none;width:65pt">consumerStatus</td>
  <td rowspan="5" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">查看消费者状态，包括同一个分组中是否都是相同的订阅，分析Process
  Queue是否堆积，返回消费者jstack结果，内容较多，使用者参见ConsumerStatusSubCommand</td>
  <td class="xl67" width="87" style="width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="36" style="height:27.0pt">
  <td height="36" class="xl67" width="87" style="height:27.0pt;width:65pt">-g</td>
  <td class="xl67" width="87" style="width:65pt">consumer group</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-i</td>
  <td class="xl67" width="87" style="width:65pt">clientId</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-s</td>
  <td class="xl68" width="87" style="width:65pt">是否执行jstack</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td rowspan="5" height="181" class="xl69" width="87" style="border-bottom:1.0pt
  height:135.0pt;border-top:none;width:65pt">getConsumerStatus</td>
  <td rowspan="5" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">获取 Consumer 消费进度</td>
  <td class="xl67" width="87" style="width:65pt">-g</td>
  <td class="xl68" width="87" style="width:65pt">消费者所属组名</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">查询主题</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-i</td>
  <td class="xl68" width="87" style="width:65pt">Consumer 客户端 ip</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="13" height="761" class="xl69" width="87" style="border-bottom:1.0pt
  height:569.0pt;border-top:none;width:65pt">updateSubGroup</td>
  <td rowspan="13" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">更新或创建订阅关系</td>
  <td class="xl67" width="87" style="width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">Broker地址</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-c</td>
  <td class="xl68" width="87" style="width:65pt">集群名称</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-g</td>
  <td class="xl68" width="87" style="width:65pt">消费者分组名称</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-s</td>
  <td class="xl68" width="87" style="width:65pt">分组是否允许消费</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-m</td>
  <td class="xl68" width="87" style="width:65pt">是否从最小offset开始消费</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-d</td>
  <td class="xl68" width="87" style="width:65pt">是否是广播模式</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-q</td>
  <td class="xl68" width="87" style="width:65pt">重试队列数量</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-r</td>
  <td class="xl68" width="87" style="width:65pt">最大重试次数</td>
 </tr>
 <tr height="207" style="height:155.0pt">
  <td height="207" class="xl67" width="87" style="height:155.0pt;width:65pt">-i</td>
  <td class="xl68" width="87" style="width:65pt">当slaveReadEnable开启时有效，且还未达到从slave消费时建议从哪个BrokerId消费，可以配置备机id，主动从备机消费</td>
 </tr>
 <tr height="132" style="height:99.0pt">
  <td height="132" class="xl67" width="87" style="height:99.0pt;width:65pt">-w</td>
  <td class="xl68" width="87" style="width:65pt">如果Broker建议从slave消费，配置决定从哪个slave消费，配置BrokerId，例如1</td>
 </tr>
 <tr height="76" style="height:57.0pt">
  <td height="76" class="xl67" width="87" style="height:57.0pt;width:65pt">-a</td>
  <td class="xl68" width="87" style="width:65pt">当消费者数量变化时是否通知其他消费者负载均衡</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="5" height="165" class="xl69" width="87" style="border-bottom:1.0pt
  height:123.0pt;border-top:none;width:65pt">deleteSubGroup</td>
  <td rowspan="5" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">从Broker删除订阅关系</td>
  <td class="xl67" width="87" style="width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-b</td>
  <td class="xl68" width="87" style="width:65pt">Broker地址</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-c</td>
  <td class="xl68" width="87" style="width:65pt">集群名称</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td height="39" class="xl67" width="87" style="height:29.0pt;width:65pt">-g</td>
  <td class="xl68" width="87" style="width:65pt">消费者分组名称</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="6" height="172" class="xl69" width="87" style="border-bottom:1.0pt
  height:120pt;border-top:none;width:65pt">cloneGroupOffset</td>
  <td rowspan="6" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">在目标群组中使用源群组的offset</td>
  <td class="xl67" width="87" style="width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-s</td>
  <td class="xl68" width="87" style="width:65pt">源消费者组</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-d</td>
  <td class="xl68" width="87" style="width:65pt">目标消费者组</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">topic名称</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-o</td>
  <td class="xl68" width="87" style="width:65pt">暂未使用</td>
 </tr>
</table>


<h5 id="6）连接相关"><a href="#6）连接相关" class="headerlink" title="6）连接相关"></a>6）连接相关</h5><table border="0" cellpadding="0" cellspacing="0" width="714">
 <col width="177">
 <col width="175">
 <col width="177">
 <col width="185">
<tr height="23" style="height:17.0pt">
  <td height="23" class="xl63" width="177" style="height:17.0pt;width:133pt">名称</td>
  <td class="xl64" width="175" style="width:131pt">含义</td>
  <td class="xl64" width="177" style="width:133pt">命令选项</td>
  <td class="xl64" width="185" style="width:139pt">说明</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td rowspan="3" height="119" class="xl69" width="87" style="border-bottom:1.0pt
  height:89.0pt;border-top:none;width:65pt">consumerConnec tion</td>
  <td rowspan="3" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">查询 Consumer 的网络连接</td>
  <td class="xl67" width="87" style="width:65pt">-g</td>
  <td class="xl68" width="87" style="width:65pt">消费者所属组名</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="39" style="height:29.0pt">
  <td rowspan="4" height="142" class="xl69" width="87" style="border-bottom:1.0pt
  height:106.0pt;border-top:none;width:65pt">producerConnec tion</td>
  <td rowspan="4" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">查询 Producer 的网络连接</td>
  <td class="xl67" width="87" style="width:65pt">-g</td>
  <td class="xl68" width="87" style="width:65pt">生产者所属组名</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-t</td>
  <td class="xl68" width="87" style="width:65pt">主题名称</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
</table>


<h5 id="7）NameServer相关"><a href="#7）NameServer相关" class="headerlink" title="7）NameServer相关"></a>7）NameServer相关</h5><table border="0" cellpadding="0" cellspacing="0" width="714">
 <col width="177">
 <col width="175">
 <col width="177">
 <col width="185">
<tr height="23" style="height:17.0pt">
  <td height="23" class="xl63" width="177" style="height:17.0pt;width:133pt">名称</td>
  <td class="xl64" width="175" style="width:131pt">含义</td>
  <td class="xl64" width="177" style="width:133pt">命令选项</td>
  <td class="xl64" width="185" style="width:139pt">说明</td>
 </tr>
 <tr height="21" style="height:16.0pt">
  <td rowspan="5" height="143" class="xl69" width="87" style="border-bottom:1.0pt
  height:100pt;border-top:none;width:65pt">updateKvConfig</td>
  <td rowspan="5" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">更新NameServer的kv配置，目前还未使用</td>
  <td class="xl75" width="87" style="width:65pt">-s</td>
  <td class="xl76" width="87" style="width:65pt">命名空间</td>
 </tr>
 <tr height="21" style="height:16.0pt">
  <td height="21" class="xl75" width="87" style="height:16.0pt;width:65pt">-k</td>
  <td class="xl75" width="87" style="width:65pt">key</td>
 </tr>
 <tr height="21" style="height:16.0pt">
  <td height="21" class="xl75" width="87" style="height:16.0pt;width:65pt">-v</td>
  <td class="xl75" width="87" style="width:65pt">value</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td rowspan="4" height="126" class="xl69" width="87" style="border-bottom:1.0pt
  height:94.0pt;border-top:none;width:65pt">deleteKvConfig</td>
  <td rowspan="4" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">删除NameServer的kv配置</td>
  <td class="xl67" width="87" style="width:65pt">-s</td>
  <td class="xl68" width="87" style="width:65pt">命名空间</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-k</td>
  <td class="xl67" width="87" style="width:65pt">key</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td height="57" class="xl67" width="87" style="height:43.0pt;width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="2" height="80" class="xl69" width="87" style="border-bottom:1.0pt
  height:60.0pt;border-top:none;width:65pt">getNamesrvConfig</td>
  <td rowspan="2" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">获取NameServer配置</td>
  <td class="xl67" width="87" style="width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="4" height="126" class="xl69" width="87" style="border-bottom:1.0pt
  height:94.0pt;border-top:none;width:65pt">updateNamesrvConfig</td>
  <td rowspan="4" class="xl72" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">修改NameServer配置</td>
  <td class="xl67" width="87" style="width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-k</td>
  <td class="xl67" width="87" style="width:65pt">key</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-v</td>
  <td class="xl67" width="87" style="width:65pt">value</td>
 </tr>
</table>


<h5 id="8）其他"><a href="#8）其他" class="headerlink" title="8）其他"></a>8）其他</h5><table border="0" cellpadding="0" cellspacing="0" width="714">
 <col width="177">
 <col width="175">
 <col width="177">
 <col width="185">
<tr height="23" style="height:17.0pt">
  <td height="23" class="xl63" width="177" style="height:17.0pt;width:133pt">名称</td>
  <td class="xl64" width="175" style="width:131pt">含义</td>
  <td class="xl64" width="177" style="width:133pt">命令选项</td>
  <td class="xl64" width="185" style="width:139pt">说明</td>
 </tr>
 <tr height="57" style="height:43.0pt">
  <td rowspan="2" height="80" class="xl69" width="87" style="border-bottom:1.0pt
  height:60.0pt;border-top:none;width:65pt">startMonitoring</td>
  <td rowspan="2" class="xl71" width="87" style="border-bottom:1.0pt
  border-top:none;width:65pt">开启监控进程，监控消息误删、重试队列消息数等</td>
  <td class="xl67" width="87" style="width:65pt">-n</td>
  <td class="xl68" width="87" style="width:65pt">NameServer 服务地址，格式 ip:port</td>
 </tr>
 <tr height="23" style="height:17.0pt">
  <td height="23" class="xl67" width="87" style="height:17.0pt;width:65pt">-h</td>
  <td class="xl68" width="87" style="width:65pt">打印帮助</td>
 </tr>
</table>


<h4 id="3-4-3-注意事项"><a href="#3-4-3-注意事项" class="headerlink" title="3.4.3 注意事项"></a>3.4.3 注意事项</h4><ul>
<li>几乎所有命令都需要配置-n表示NameServer地址，格式为ip:port</li>
<li>几乎所有命令都可以通过-h获取帮助</li>
<li>如果既有Broker地址（-b）配置项又有clusterName（-c）配置项，则优先以Broker地址执行命令；如果不配置Broker地址，则对集群中所有主机执行命令</li>
</ul>
<h3 id="3-5-集群监控平台搭建"><a href="#3-5-集群监控平台搭建" class="headerlink" title="3.5 集群监控平台搭建"></a>3.5 集群监控平台搭建</h3><h4 id="3-5-1-概述"><a href="#3-5-1-概述" class="headerlink" title="3.5.1 概述"></a>3.5.1 概述</h4><p><code>RocketMQ</code>有一个对其扩展的开源项目<a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener">incubator-rocketmq-externals</a>，这个项目中有一个子模块叫<code>rocketmq-console</code>，这个便是管理控制台项目了，先将<a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener">incubator-rocketmq-externals</a>拉到本地，因为我们需要自己对<code>rocketmq-console</code>进行编译打包运行。</p>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5Crocketmq-console.png" alt></p>
<h4 id="3-5-2-下载并编译打包"><a href="#3-5-2-下载并编译打包" class="headerlink" title="3.5.2 下载并编译打包"></a>3.5.2 下载并编译打包</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/rocketmq-externals</span><br><span class="line"><span class="built_in">cd</span> rocketmq-console</span><br><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>注意：打包前在<code>rocketmq-console</code>中配置<code>namesrv</code>集群地址：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876</span><br></pre></td></tr></table></figure>

<p>启动rocketmq-console：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar rocketmq-console-ng-1.0.0.jar</span><br></pre></td></tr></table></figure>

<p>启动成功后，我们就可以通过浏览器访问<code>http://localhost:8080</code>进入控制台界面了，如下图：</p>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5Crocketmq-console2.png" alt></p>
<p>集群状态：</p>
<p><img src="/2021/07/28/rocketMQ/rocketMQ%5Crocketmq-console3.png" alt></p>
<h2 id="4-消息发送样例"><a href="#4-消息发送样例" class="headerlink" title="4. 消息发送样例"></a>4. 消息发送样例</h2><ul>
<li><strong>导入MQ客户端依赖</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消息发送者步骤分析</strong></li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.创建消息生产者producer，并制定生产者组名</span><br><span class="line">2.指定Nameserver地址</span><br><span class="line">3.启动producer</span><br><span class="line">4.创建消息对象，指定主题Topic、Tag和消息体</span><br><span class="line">5.发送消息</span><br><span class="line">6.关闭生产者producer</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消息消费者步骤分析</strong></li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.创建消费者Consumer，制定消费者组名</span><br><span class="line">2.指定Nameserver地址</span><br><span class="line">3.订阅主题Topic和Tag</span><br><span class="line">4.设置回调函数，处理消息</span><br><span class="line">5.启动消费者consumer</span><br></pre></td></tr></table></figure>

<h3 id="4-1-基本样例"><a href="#4-1-基本样例" class="headerlink" title="4.1 基本样例"></a>4.1 基本样例</h3><h4 id="4-1-1-消息发送"><a href="#4-1-1-消息发送" class="headerlink" title="4.1.1 消息发送"></a>4.1.1 消息发送</h4><h5 id="1）发送同步消息"><a href="#1）发送同步消息" class="headerlink" title="1）发送同步消息"></a>1）发送同步消息</h5><p>这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">    	producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    	    <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">    	    Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">        	<span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">        	(<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">        	);</span><br><span class="line">        	<span class="comment">// 发送消息到一个Broker</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            <span class="comment">// 通过sendResult返回消息是否成功送达</span></span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）发送异步消息"><a href="#2）发送异步消息" class="headerlink" title="2）发送异步消息"></a>2）发送异步消息</h5><p>异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            	<span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">                    <span class="string">"TagA"</span>,</span><br><span class="line">                    <span class="string">"OrderID188"</span>,</span><br><span class="line">                    <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                <span class="comment">// SendCallback接收异步返回结果的回调</span></span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">      	              System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, index, e);</span><br><span class="line">      	              e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">            	&#125;);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3）单向发送消息"><a href="#3）单向发送消息" class="headerlink" title="3）单向发送消息"></a>3）单向发送消息</h5><p>这种方式主要用在不特别关心发送结果的场景，例如日志发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        	<span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        	Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">        	);</span><br><span class="line">        	<span class="comment">// 发送单向消息，没有任何返回结果</span></span><br><span class="line">        	producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-消费消息"><a href="#4-1-2-消费消息" class="headerlink" title="4.1.2 消费消息"></a>4.1.2 消费消息</h4><h5 id="1）负载均衡模式"><a href="#1）负载均衡模式" class="headerlink" title="1）负载均衡模式"></a>1）负载均衡模式</h5><p>消费者采用负载均衡方式消费消息，多个消费者共同消费队列消息，每个消费者处理的消息不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者,指定组名</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"group1"</span>);</span><br><span class="line">    <span class="comment">// 指定Namesrv地址信息.</span></span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    <span class="comment">// 订阅Topic</span></span><br><span class="line">    consumer.subscribe(<span class="string">"Test"</span>, <span class="string">"*"</span>);</span><br><span class="line">    <span class="comment">//负载均衡模式消费</span></span><br><span class="line">    consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">    <span class="comment">// 注册回调函数，处理消息</span></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, </span><br><span class="line">                              Thread.currentThread().getName(), msgs);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动消息者</span></span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）广播模式"><a href="#2）广播模式" class="headerlink" title="2）广播模式"></a>2）广播模式</h5><p>消费者采用广播的方式消费消息，每个消费者消费的消息都是相同的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者,指定组名</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"group1"</span>);</span><br><span class="line">    <span class="comment">// 指定Namesrv地址信息.</span></span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    <span class="comment">// 订阅Topic</span></span><br><span class="line">    consumer.subscribe(<span class="string">"Test"</span>, <span class="string">"*"</span>);</span><br><span class="line">    <span class="comment">//广播模式消费</span></span><br><span class="line">    consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">    <span class="comment">// 注册回调函数，处理消息</span></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, </span><br><span class="line">                              Thread.currentThread().getName(), msgs);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动消息者</span></span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-顺序消息"><a href="#4-2-顺序消息" class="headerlink" title="4.2 顺序消息"></a>4.2 顺序消息</h3><blockquote>
<p>消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为<strong>分区有序</strong>或者<strong>全局有序。</strong></p>
<p>顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果<strong>控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。</strong></p>
<p>下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一个队列。</p>
</blockquote>
<h4 id="4-2-1-顺序消息生产"><a href="#4-2-1-顺序消息生产" class="headerlink" title="4.2.1 顺序消息生产"></a>4.2.1 顺序消息生产</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Producer，发送顺序消息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line"></span><br><span class="line">       producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line"></span><br><span class="line">       producer.start();</span><br><span class="line"></span><br><span class="line">       String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">"TagA"</span>, <span class="string">"TagC"</span>, <span class="string">"TagD"</span>&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 订单列表</span></span><br><span class="line">       List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> Producer().buildOrders();</span><br><span class="line"></span><br><span class="line">       Date date = <span class="keyword">new</span> Date();</span><br><span class="line">       SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">       String dateStr = sdf.format(date);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           <span class="comment">// 加个时间前缀</span></span><br><span class="line">           String body = dateStr + <span class="string">" Hello RocketMQ "</span> + orderList.get(i);</span><br><span class="line">           Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i, body.getBytes());</span><br><span class="line"></span><br><span class="line">           SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                   Long id = (Long) arg;  <span class="comment">//根据订单id选择发送queue</span></span><br><span class="line">                   <span class="keyword">long</span> index = id % mqs.size();</span><br><span class="line">                   <span class="keyword">return</span> mqs.get((<span class="keyword">int</span>) index);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, orderList.get(i).getOrderId());<span class="comment">//订单id</span></span><br><span class="line"></span><br><span class="line">           System.out.println(String.format(<span class="string">"SendResult status:%s, queueId:%d, body:%s"</span>,</span><br><span class="line">               sendResult.getSendStatus(),</span><br><span class="line">               sendResult.getMessageQueue().getQueueId(),</span><br><span class="line">               body));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       producer.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 订单的步骤</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderStep</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">long</span> orderId;</span><br><span class="line">       <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> orderId;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(<span class="keyword">long</span> orderId)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> desc;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.desc = desc;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"OrderStep&#123;"</span> +</span><br><span class="line">               <span class="string">"orderId="</span> + orderId +</span><br><span class="line">               <span class="string">", desc='"</span> + desc + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">'&#125;'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生成模拟订单数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> List&lt;OrderStep&gt; <span class="title">buildOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> ArrayList&lt;OrderStep&gt;();</span><br><span class="line"></span><br><span class="line">       OrderStep orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"创建"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"创建"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"付款"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"创建"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"付款"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"付款"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"完成"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"推送"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"完成"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"完成"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> orderList;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-顺序消费消息"><a href="#4-2-2-顺序消费消息" class="headerlink" title="4.2.2 顺序消费消息"></a>4.2.2 顺序消费消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 顺序消息消费，带事务方式（应用可控制Offset什么时候提交）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerInOrder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       DefaultMQPushConsumer consumer = <span class="keyword">new</span> </span><br><span class="line">           DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_3"</span>);</span><br><span class="line">       consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span></span><br><span class="line"><span class="comment">        * 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">       consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"TagA || TagC || TagD"</span>);</span><br><span class="line"></span><br><span class="line">       consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">           Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">               context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">               <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                   <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class="line">                   System.out.println(<span class="string">"consumeThread="</span> + Thread.currentThread().getName() + <span class="string">"queueId="</span> + msg.getQueueId() + <span class="string">", content:"</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//模拟业务逻辑处理中...</span></span><br><span class="line">                   TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       consumer.start();</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"Consumer Started."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-延时消息"><a href="#4-3-延时消息" class="headerlink" title="4.3 延时消息"></a>4.3 延时消息</h3><blockquote>
<p>比如电商里，提交了一个订单就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。</p>
</blockquote>
<h4 id="4-3-1-启动消息消费者"><a href="#4-3-1-启动消息消费者" class="headerlink" title="4.3.1 启动消息消费者"></a>4.3.1 启动消息消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageConsumer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 实例化消费者</span></span><br><span class="line">      DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"ExampleConsumer"</span>);</span><br><span class="line">      <span class="comment">// 订阅Topics</span></span><br><span class="line">      consumer.subscribe(<span class="string">"TestTopic"</span>, <span class="string">"*"</span>);</span><br><span class="line">      <span class="comment">// 注册消息监听者</span></span><br><span class="line">      consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">for</span> (MessageExt message : messages) &#123;</span><br><span class="line">                  <span class="comment">// Print approximate delay time period</span></span><br><span class="line">                  System.out.println(<span class="string">"Receive message[msgId="</span> + message.getMsgId() + <span class="string">"] "</span> + (System.currentTimeMillis() - message.getStoreTimestamp()) + <span class="string">"ms later"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 启动消费者</span></span><br><span class="line">      consumer.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-发送延时消息"><a href="#4-3-2-发送延时消息" class="headerlink" title="4.3.2 发送延时消息"></a>4.3.2 发送延时消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 实例化一个生产者来产生延时消息</span></span><br><span class="line">      DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">      <span class="comment">// 启动生产者</span></span><br><span class="line">      producer.start();</span><br><span class="line">      <span class="keyword">int</span> totalMessagesToSend = <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">          Message message = <span class="keyword">new</span> Message(<span class="string">"TestTopic"</span>, (<span class="string">"Hello scheduled message "</span> + i).getBytes());</span><br><span class="line">          <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span></span><br><span class="line">          message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">          <span class="comment">// 发送消息</span></span><br><span class="line">          producer.send(message);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 关闭生产者</span></span><br><span class="line">      producer.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-验证"><a href="#4-3-3-验证" class="headerlink" title="4.3.3 验证"></a>4.3.3 验证</h4><p>您将会看到消息的消费比存储时间晚10秒</p>
<h4 id="4-3-4-使用限制"><a href="#4-3-4-使用限制" class="headerlink" title="4.3.4 使用限制"></a>4.3.4 使用限制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org/apache/rocketmq/store/config/MessageStoreConfig.java</span></span><br><span class="line"><span class="keyword">private</span> String messageDelayLevel = <span class="string">"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span>;</span><br></pre></td></tr></table></figure>

<p>现在RocketMq并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18</p>
<h3 id="4-4-批量消息"><a href="#4-4-批量消息" class="headerlink" title="4.4 批量消息"></a>4.4 批量消息</h3><blockquote>
<p>批量发送消息能显著提高传递小消息的性能。限制是这些批量消息应该有相同的topic，相同的waitStoreMsgOK，而且不能是延时消息。此外，这一批消息的总大小不应超过4MB。</p>
</blockquote>
<h4 id="4-4-1-发送批量消息"><a href="#4-4-1-发送批量消息" class="headerlink" title="4.4.1 发送批量消息"></a>4.4.1 发送批量消息</h4><ul>
<li>如果您每次只发送不超过4MB的消息，则很容易使用批处理，样例如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String topic = <span class="string">"BatchTest"</span>;</span><br><span class="line">List&lt;Message&gt; messages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID001"</span>, <span class="string">"Hello world 0"</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID002"</span>, <span class="string">"Hello world 1"</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID003"</span>, <span class="string">"Hello world 2"</span>.getBytes()));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   producer.send(messages);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   <span class="comment">//处理error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果消息的总长度可能大于4MB时，这时候最好把消息进行分割</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSplitter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">List</span>&lt;<span class="title">Message</span>&gt;&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE_LIMIT = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> currIndex;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.messages = messages;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">   &#125;</span><br><span class="line">   	<span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Message&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> nextIndex = currIndex;</span><br><span class="line">       <span class="keyword">int</span> totalSize = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">           Message message = messages.get(nextIndex);</span><br><span class="line">           <span class="keyword">int</span> tmpSize = message.getTopic().length() + message.getBody().length;</span><br><span class="line">           Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">               tmpSize += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">           &#125;</span><br><span class="line">           tmpSize = tmpSize + <span class="number">20</span>; <span class="comment">// 增加日志的开销20字节</span></span><br><span class="line">           <span class="keyword">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">               <span class="comment">//单个消息超过了最大的限制</span></span><br><span class="line">               <span class="comment">//忽略,否则会阻塞分裂的进程</span></span><br><span class="line">               <span class="keyword">if</span> (nextIndex - currIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//假如下一个子列表没有元素,则添加这个子列表然后退出循环,否则只是退出循环</span></span><br><span class="line">                  nextIndex++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               totalSize += tmpSize;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line">       currIndex = nextIndex;</span><br><span class="line">       <span class="keyword">return</span> subList;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把大的消息分裂成若干个小的消息</span></span><br><span class="line">ListSplitter splitter = <span class="keyword">new</span> ListSplitter(messages);</span><br><span class="line"><span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      List&lt;Message&gt;  listItem = splitter.next();</span><br><span class="line">      producer.send(listItem);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="comment">//处理error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-过滤消息"><a href="#4-5-过滤消息" class="headerlink" title="4.5 过滤消息"></a>4.5 过滤消息</h3><p>在大多数情况下，TAG是一个简单而有用的设计，其可以来选择您想要的消息。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"CID_EXAMPLE"</span>);</span><br><span class="line">consumer.subscribe(<span class="string">"TOPIC"</span>, <span class="string">"TAGA || TAGB || TAGC"</span>);</span><br></pre></td></tr></table></figure>

<p>消费者将接收包含TAGA或TAGB或TAGC的消息。但是限制是一个消息只能有一个标签，这对于复杂的场景可能不起作用。在这种情况下，可以使用SQL表达式筛选消息。SQL特性可以通过发送消息时的属性来进行计算。在RocketMQ定义的语法下，可以实现一些简单的逻辑。下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">------------</span><br><span class="line">| message  |</span><br><span class="line">|----------|  a &gt; 5 AND b &#x3D; &#39;abc&#39;</span><br><span class="line">| a &#x3D; 10   |  --------------------&gt; Gotten</span><br><span class="line">| b &#x3D; &#39;abc&#39;|</span><br><span class="line">| c &#x3D; true |</span><br><span class="line">------------</span><br><span class="line">------------</span><br><span class="line">| message  |</span><br><span class="line">|----------|   a &gt; 5 AND b &#x3D; &#39;abc&#39;</span><br><span class="line">| a &#x3D; 1    |  --------------------&gt; Missed</span><br><span class="line">| b &#x3D; &#39;abc&#39;|</span><br><span class="line">| c &#x3D; true |</span><br><span class="line">------------</span><br></pre></td></tr></table></figure>

<h4 id="4-5-1-SQL基本语法"><a href="#4-5-1-SQL基本语法" class="headerlink" title="4.5.1 SQL基本语法"></a>4.5.1 SQL基本语法</h4><p>RocketMQ只定义了一些基本语法来支持这个特性。你也可以很容易地扩展它。</p>
<ul>
<li>数值比较，比如：<strong>&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=；</strong></li>
<li>字符比较，比如：<strong>=，&lt;&gt;，IN；</strong></li>
<li><strong>IS NULL</strong> 或者 <strong>IS NOT NULL；</strong></li>
<li>逻辑符号 <strong>AND，OR，NOT；</strong></li>
</ul>
<p>常量支持类型为：</p>
<ul>
<li>数值，比如：<strong>123，3.1415；</strong></li>
<li>字符，比如：<strong>‘abc’，必须用单引号包裹起来；</strong></li>
<li><strong>NULL</strong>，特殊的常量</li>
<li>布尔值，<strong>TRUE</strong> 或 <strong>FALSE</strong></li>
</ul>
<p>只有使用push模式的消费者才能用使用SQL92标准的sql语句，接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(finalString topic, <span class="keyword">final</span> MessageSelector messageSelector)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="4-5-2-消息生产者"><a href="#4-5-2-消息生产者" class="headerlink" title="4.5.2 消息生产者"></a>4.5.2 消息生产者</h4><p>发送消息时，你能通过<code>putUserProperty</code>来设置消息的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">producer.start();</span><br><span class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">   tag,</span><br><span class="line">   (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 设置一些属性</span></span><br><span class="line">msg.putUserProperty(<span class="string">"a"</span>, String.valueOf(i));</span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line"></span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>

<h4 id="4-5-3-消息消费者"><a href="#4-5-3-消息消费者" class="headerlink" title="4.5.3 消息消费者"></a>4.5.3 消息消费者</h4><p>用MessageSelector.bySql来使用sql筛选消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line"><span class="comment">// 只有订阅的消息有这个属性a, a &gt;=0 and a &lt;= 3</span></span><br><span class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, MessageSelector.bySql(<span class="string">"a between 0 and 3"</span>);</span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></figure>

<h3 id="4-6-事务消息"><a href="#4-6-事务消息" class="headerlink" title="4.6 事务消息"></a>4.6 事务消息</h3><h4 id="4-6-1-流程分析"><a href="#4-6-1-流程分析" class="headerlink" title="4.6.1 流程分析"></a>4.6.1 流程分析</h4><p><img src="/2021/07/28/rocketMQ/rocketMQ%5C%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png" alt></p>
<p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<h5 id="1）事务消息发送及提交"><a href="#1）事务消息发送及提交" class="headerlink" title="1）事务消息发送及提交"></a>1）事务消息发送及提交</h5><blockquote>
<p>(1) 发送消息（half消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
</blockquote>
<h5 id="2）事务补偿"><a href="#2）事务补偿" class="headerlink" title="2）事务补偿"></a>2）事务补偿</h5><blockquote>
<p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
</blockquote>
<h5 id="3）事务消息状态"><a href="#3）事务消息状态" class="headerlink" title="3）事务消息状态"></a>3）事务消息状态</h5><blockquote>
<p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>
<ul>
<li>TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。</li>
<li>TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。</li>
<li>TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。</li>
</ul>
</blockquote>
<h4 id="4-6-2-发送事务消息"><a href="#4-6-2-发送事务消息" class="headerlink" title="4.6.2 发送事务消息"></a>4.6.2 发送事务消息</h4><h5 id="1-创建事务性生产者"><a href="#1-创建事务性生产者" class="headerlink" title="1) 创建事务性生产者"></a>1) 创建事务性生产者</h5><p>使用 <code>TransactionMQProducer</code>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复。回传的事务状态在请参考前一节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建事务监听器</span></span><br><span class="line">        TransactionListener transactionListener = <span class="keyword">new</span> TransactionListenerImpl();</span><br><span class="line">        <span class="comment">//创建消息生产者</span></span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">"group6"</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"192.168.25.135:9876;192.168.25.138:9876"</span>);</span><br><span class="line">        <span class="comment">//生产者这是监听器</span></span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line">        <span class="comment">//启动消息生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TransactionTopic"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i,</span><br><span class="line">                        (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                SendResult sendResult = producer.sendMessageInTransaction(msg, <span class="keyword">null</span>);</span><br><span class="line">                System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//producer.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）实现事务的监听接口"><a href="#2）实现事务的监听接口" class="headerlink" title="2）实现事务的监听接口"></a>2）实现事务的监听接口</h5><p>当发送半消息成功时，我们使用 <code>executeLocalTransaction</code> 方法来执行本地事务。它返回前一节中提到的三个事务状态之一。<code>checkLocalTranscation</code> 方法用于检查本地事务状态，并回应消息队列的检查请求。它也是返回前一节中提到的三个事务状态之一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行本地事务"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.equals(<span class="string">"TagA"</span>, msg.getTags())) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">"TagB"</span>, msg.getTags())) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MQ检查消息Tag【"</span>+msg.getTags()+<span class="string">"】的本地事务执行结果"</span>);</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-2-使用限制"><a href="#4-6-2-使用限制" class="headerlink" title="4.6.2 使用限制"></a>4.6.2 使用限制</h4><ol>
<li>事务消息不支持延时消息和批量消息。</li>
<li>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N = <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionCheckListener</code> 类来修改这个行为。</li>
<li>事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionMsgTimeout</code> 参数。</li>
<li>事务性消息可能不止一次被检查或消费。</li>
<li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</li>
<li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</li>
</ol>
<h1 id="二，RocketMQ高级篇"><a href="#二，RocketMQ高级篇" class="headerlink" title="二，RocketMQ高级篇"></a>二，RocketMQ高级篇</h1><h2 id="1-高级功能"><a href="#1-高级功能" class="headerlink" title="1. 高级功能"></a>1. 高级功能</h2><h3 id="1-1-消息存储"><a href="#1-1-消息存储" class="headerlink" title="1.1 消息存储"></a>1.1 消息存储</h3><p>分布式队列因为有高可靠性的要求，所以数据要进行持久化存储。</p>
<p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png" alt></p>
<ol>
<li>消息生成者发送消息</li>
<li>MQ收到消息，将消息进行持久化，在存储中新增一条记录</li>
<li>返回ACK给生产者</li>
<li>MQ push 消息给对应的消费者，然后等待消费者返回ACK</li>
<li>如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,重复执行4、5、6步骤</li>
<li>MQ删除消息</li>
</ol>
<h4 id="1-1-1-存储介质"><a href="#1-1-1-存储介质" class="headerlink" title="1.1.1 存储介质"></a>1.1.1 存储介质</h4><ul>
<li><strong>关系型数据库DB</strong></li>
</ul>
<p>Apache下开源的另外一款MQ—ActiveMQ（默认采用的KahaDB做消息存储）可选用JDBC的方式来做消息持久化，通过简单的xml配置信息即可实现JDBC消息存储。由于，普通关系型数据库（如Mysql）在单表数据量达到千万级别的情况下，其IO读写性能往往会出现瓶颈。在可靠性方面，该种方案非常依赖DB，如果一旦DB出现故障，则MQ的消息就无法落盘存储会导致线上故障</p>
<p><img src="/2021/07/28/rocketMQ/MySQL.png" alt></p>
<ul>
<li><p><strong>文件系统</strong></p>
<p>目前业界较为常用的几款产品（RocketMQ/Kafka/RabbitMQ）均采用的是<strong>消息刷盘至所部署虚拟机/物理机的文件系统来做持久化</strong>（刷盘一般可以分为<strong>异步刷盘</strong>和<strong>同步刷盘</strong>两种模式）。消息刷盘为消息存储提供了一种高效率、高可靠性和高性能的数据持久化方式。除非部署MQ机器本身或是本地磁盘挂了，否则一般是不会出现无法持久化的故障问题。</p>
<p><img src="/2021/07/28/rocketMQ/%E7%A3%81%E7%9B%98.png" alt></p>
</li>
</ul>
<h4 id="1-1-2-性能对比"><a href="#1-1-2-性能对比" class="headerlink" title="1.1.2 性能对比"></a>1.1.2 性能对比</h4><p>文件系统 &gt; 关系型数据库DB</p>
<h4 id="1-1-3-消息的存储和发送"><a href="#1-1-3-消息的存储和发送" class="headerlink" title="1.1.3 消息的存储和发送"></a>1.1.3 消息的存储和发送</h4><h5 id="1）消息存储"><a href="#1）消息存储" class="headerlink" title="1）消息存储"></a>1）消息存储</h5><p>磁盘如果使用得当，磁盘的速度完全可以匹配上网络 的数据传输速度。目前的高性能磁盘，顺序写速度可以达到600MB/s， 超过了一般网卡的传输速度。但是磁盘随机写的速度只有大概100KB/s，和顺序写的性能相差6000倍！因为有如此巨大的速度差别，好的消息队列系统会比普通的消息队列系统速度快多个数量级。RocketMQ的消息用顺序写,保证了消息存储的速度。</p>
<h5 id="2）消息发送"><a href="#2）消息发送" class="headerlink" title="2）消息发送"></a>2）消息发送</h5><p>Linux操作系统分为【用户态】和【内核态】，文件操作、网络操作需要涉及这两种形态的切换，免不了进行数据复制。</p>
<p>一台服务器 把本机磁盘文件的内容发送到客户端，一般分为两个步骤：</p>
<p>1）read；读取本地文件内容； </p>
<p>2）write；将读取的内容通过网络发送出去。</p>
<p>这两个看似简单的操作，实际进行了4 次数据复制，分别是：</p>
<ol>
<li>从磁盘复制数据到内核态内存；</li>
<li>从内核态内存复 制到用户态内存；</li>
<li>然后从用户态 内存复制到网络驱动的内核态内存；</li>
<li>最后是从网络驱动的内核态内存复 制到网卡中进行传输。</li>
</ol>
<p><img src="/2021/07/28/rocketMQ/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C.png" alt>通过使用mmap的方式，可以省去向用户态的内存复制，提高速度。这种机制在Java中是通过MappedByteBuffer实现的</p>
<p>RocketMQ充分利用了上述特性，也就是所谓的“零拷贝”技术，提高消息存盘和网络发送的速度。</p>
<blockquote>
<p>这里需要注意的是，采用MappedByteBuffer这种内存映射的方式有几个限制，其中之一是一次只能映射1.5~2G 的文件至用户态的虚拟内存，这也是为何RocketMQ默认设置单个CommitLog日志数据文件为1G的原因了</p>
</blockquote>
<h4 id="1-1-4-消息存储结构"><a href="#1-1-4-消息存储结构" class="headerlink" title="1.1.4 消息存储结构"></a>1.1.4 消息存储结构</h4><p>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成 的，消息真正的物理存储文件是CommitLog，ConsumeQueue是消息的逻辑队列，类似数据库的索引文件，存储的是指向物理存储的地址。每 个Topic下的每个Message Queue都有一个对应的ConsumeQueue文件。</p>
<p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt></p>
<ul>
<li>CommitLog：存储消息的元数据</li>
<li>ConsumerQueue：存储消息在CommitLog的索引</li>
<li>IndexFile：为了消息查询提供了一种通过key或时间区间来查询消息的方法，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程</li>
</ul>
<h4 id="1-1-5-刷盘机制"><a href="#1-1-5-刷盘机制" class="headerlink" title="1.1.5 刷盘机制"></a>1.1.5 刷盘机制</h4><p>RocketMQ的消息是存储到磁盘上的，这样既能保证断电后恢复， 又可以让存储的消息量超出内存的限制。RocketMQ为了提高性能，会尽可能地保证磁盘的顺序写。消息在通过Producer写入RocketMQ的时 候，有两种写磁盘方式，分布式同步刷盘和异步刷盘。</p>
<p><img src="/2021/07/28/rocketMQ/%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98.png" alt></p>
<h5 id="1）同步刷盘"><a href="#1）同步刷盘" class="headerlink" title="1）同步刷盘"></a>1）同步刷盘</h5><p>在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写 成功的状态。</p>
<h5 id="2）异步刷盘"><a href="#2）异步刷盘" class="headerlink" title="2）异步刷盘"></a>2）异步刷盘</h5><p>在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</p>
<h5 id="3）配置"><a href="#3）配置" class="headerlink" title="3）配置"></a>3）配置</h5><p><strong>同步刷盘还是异步刷盘，都是通过Broker配置文件里的flushDiskType 参数设置的，这个参数被配置成SYNC_FLUSH、ASYNC_FLUSH中的 一个。</strong></p>
<h3 id="1-2-高可用性机制"><a href="#1-2-高可用性机制" class="headerlink" title="1.2 高可用性机制"></a>1.2 高可用性机制</h3><p><img src="/2021/07/28/rocketMQ/RocketMQ%E8%A7%92%E8%89%B2.jpg" alt></p>
<p>RocketMQ分布式集群是通过Master和Slave的配合达到高可用性的。</p>
<ul>
<li><strong>Master和Slave的区别</strong>：<ul>
<li>在Broker的配置文件中，参数 brokerId的值为0表明这个Broker是Master，大于0表明这个Broker是 Slave，同时brokerRole参数也会说明这个Broker是Master还是Slave。</li>
<li>Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。</li>
</ul>
</li>
</ul>
<h4 id="1-2-1-消息消费高可用"><a href="#1-2-1-消息消费高可用" class="headerlink" title="1.2.1 消息消费高可用"></a>1.2.1 消息消费高可用</h4><p>在Consumer的配置文件中，并不需要设置是从Master读还是从Slave 读，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave 读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性。</p>
<h4 id="1-2-2-消息发送高可用"><a href="#1-2-2-消息发送高可用" class="headerlink" title="1.2.2 消息发送高可用"></a>1.2.2 消息发送高可用</h4><p>在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可用后，其他组的Master仍然可用，Producer仍然可以发送消息。 RocketMQ目前还不支持把Slave自动转成Master，如果机器资源不足， 需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文 件，用新的配置文件启动Broker。</p>
<p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1.jpg" alt></p>
<h4 id="1-2-3-消息主从复制"><a href="#1-2-3-消息主从复制" class="headerlink" title="1.2.3 消息主从复制"></a>1.2.3 消息主从复制</h4><p>如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。</p>
<h5 id="1）同步复制"><a href="#1）同步复制" class="headerlink" title="1）同步复制"></a>1）同步复制</h5><p>同步复制方式是等<strong>Master和Slave均写 成功后才反馈</strong>给客户端写成功状态；</p>
<p>在同步复制方式下，如果Master出故障， Slave上有全部的备份数据，容易恢复，但是同步复制会增大数据写入 延迟，降低系统吞吐量。</p>
<h5 id="2）异步复制"><a href="#2）异步复制" class="headerlink" title="2）异步复制"></a>2）异步复制</h5><p>异步复制方式是<strong>只要Master写成功 即可反馈</strong>给客户端写成功状态。</p>
<p>在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失；</p>
<h5 id="3）配置-1"><a href="#3）配置-1" class="headerlink" title="3）配置"></a>3）配置</h5><p>同步复制和异步复制是通过Broker配置文件里的brokerRole参数进行设置的，这个参数可以被设置成ASYNC_MASTER、 SYNC_MASTER、SLAVE三个值中的一个。</p>
<h5 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h5><p><img src="/2021/07/28/rocketMQ/%E5%A4%8D%E5%88%B6%E5%88%B7%E7%9B%98.png" alt></p>
<p>实际应用中要结合业务场景，合理设置刷盘方式和主从复制方式， 尤其是SYNC_FLUSH方式，由于频繁地触发磁盘写动作，会明显降低 性能。通常情况下，应该把Master和Save配置成ASYNC_FLUSH（<strong>异步刷盘</strong>）的刷盘 方式，主从之间配置成SYNC_MASTER（<strong>主从同步复制</strong>）的复制方式，这样即使有一台 机器出故障，仍然能保证数据不丢，是个不错的选择。</p>
<h3 id="1-3-负载均衡"><a href="#1-3-负载均衡" class="headerlink" title="1.3 负载均衡"></a>1.3 负载均衡</h3><h4 id="1-3-1-Producer负载均衡"><a href="#1-3-1-Producer负载均衡" class="headerlink" title="1.3.1 Producer负载均衡"></a>1.3.1 Producer负载均衡</h4><p>Producer端，每个实例在发消息的时候，默认会轮询所有的message queue发送，以达到让消息平均落在不同的queue上。而由于queue可以散落在不同的broker，所以消息就发送到不同的broker下，如下图：</p>
<p><img src="/2021/07/28/rocketMQ/producer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt></p>
<p>图中箭头线条上的标号代表顺序，发布方会把第一条消息发送至 Queue 0，然后第二条消息发送至 Queue 1，以此类推。</p>
<h4 id="1-3-2-Consumer负载均衡"><a href="#1-3-2-Consumer负载均衡" class="headerlink" title="1.3.2 Consumer负载均衡"></a>1.3.2 Consumer负载均衡</h4><h5 id="1）集群模式"><a href="#1）集群模式" class="headerlink" title="1）集群模式"></a>1）集群模式</h5><p>在集群消费模式下，每条消息只需要投递到订阅这个topic的Consumer Group下的一个实例即可。RocketMQ采用主动拉取的方式拉取并消费消息，在拉取的时候需要明确指定拉取哪一条message queue。</p>
<p>而每当实例的数量有变更，都会触发一次所有实例的负载均衡，这时候会按照queue的数量和实例的数量平均分配queue给每个实例。</p>
<p>默认的分配算法是AllocateMessageQueueAveragely，如下图：</p>
<p><img src="/2021/07/28/rocketMQ/consumer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt></p>
<p>还有另外一种平均的算法是AllocateMessageQueueAveragelyByCircle，也是平均分摊每一条queue，只是以环状轮流分queue的形式，如下图：</p>
<p><img src="/2021/07/28/rocketMQ/consumer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A12.png" alt></p>
<p>需要注意的是，集群模式下，queue都是只允许分配只一个实例，这是由于如果多个实例同时消费一个queue的消息，由于拉取哪些消息是consumer主动控制的，那样会导致同一个消息在不同的实例下被消费多次，所以算法上都是<strong>一个queue只分给一个consumer实例，一个consumer实例可以允许同时分到不同的queue</strong>。</p>
<p>通过增加consumer实例去分摊queue的消费，可以起到水平扩展的消费能力的作用。而有实例下线的时候，会重新触发负载均衡，这时候原来分配到的queue将分配到其他实例上继续消费。</p>
<p>但是如果consumer实例的数量比message queue的总数量还多的话，多出来的consumer实例将无法分到queue，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让queue的总数量大于等于consumer的数量。</p>
<h5 id="2）广播模式-1"><a href="#2）广播模式-1" class="headerlink" title="2）广播模式"></a>2）广播模式</h5><p>由于广播模式下要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。</p>
<p>在实现上，其中一个不同就是在consumer分配queue的时候，所有consumer都分到所有的queue。</p>
<p><img src="/2021/07/28/rocketMQ/consumer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A13.png" alt></p>
<h3 id="1-4-消息重试"><a href="#1-4-消息重试" class="headerlink" title="1.4 消息重试"></a>1.4 消息重试</h3><h4 id="1-4-1-顺序消息的重试"><a href="#1-4-1-顺序消息的重试" class="headerlink" title="1.4.1 顺序消息的重试"></a>1.4.1 顺序消息的重试</h4><p><strong>对于顺序消息，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试（每次间隔时间为 1 秒）</strong>，这时，应用会出现消息消费被阻塞的情况。因此，在使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生。</p>
<h4 id="1-4-2-无序消息的重试"><a href="#1-4-2-无序消息的重试" class="headerlink" title="1.4.2 无序消息的重试"></a>1.4.2 无序消息的重试</h4><p>对于无序消息（普通、定时、延时、事务消息），当消费者消费消息失败时，您可以通过设置返回状态达到消息重试的结果。</p>
<p><strong>无序消息的重试只针对集群消费方式生效；广播方式不提供失败重试特性</strong>，即消费失败后，失败消息不再重试，继续消费新的消息。</p>
<h5 id="1）重试次数"><a href="#1）重试次数" class="headerlink" title="1）重试次数"></a>1）重试次数</h5><p>消息队列 RocketMQ 默认允许每条消息最多重试 16 次，每次重试的间隔时间如下：</p>
<table>
<thead>
<tr>
<th align="center">第几次重试</th>
<th align="center">与上次重试的间隔时间</th>
<th align="center">第几次重试</th>
<th align="center">与上次重试的间隔时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">10 秒</td>
<td align="center">9</td>
<td align="center">7 分钟</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">30 秒</td>
<td align="center">10</td>
<td align="center">8 分钟</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1 分钟</td>
<td align="center">11</td>
<td align="center">9 分钟</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2 分钟</td>
<td align="center">12</td>
<td align="center">10 分钟</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3 分钟</td>
<td align="center">13</td>
<td align="center">20 分钟</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">4 分钟</td>
<td align="center">14</td>
<td align="center">30 分钟</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">5 分钟</td>
<td align="center">15</td>
<td align="center">1 小时</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">6 分钟</td>
<td align="center">16</td>
<td align="center">2 小时</td>
</tr>
</tbody></table>
<p>如果消息重试 16 次后仍然失败，消息将不再投递。如果严格按照上述重试时间间隔计算，某条消息在一直消费失败的前提下，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，超过这个时间范围消息将不再重试投递。</p>
<p><strong>注意：</strong> 一条消息无论重试多少次，这些重试消息的 Message ID 不会改变。</p>
<h5 id="2）配置方式"><a href="#2）配置方式" class="headerlink" title="2）配置方式"></a>2）配置方式</h5><p><strong>消费失败后，重试配置方式</strong></p>
<p>集群消费方式下，消息消费失败后期望消息重试，需要在消息监听器接口的实现中明确进行配置（三种方式任选一种）：</p>
<ul>
<li>返回 Action.ReconsumeLater （推荐）</li>
<li>返回 Null</li>
<li>抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理消息</span></span><br><span class="line">        doConsumeMessage(message);</span><br><span class="line">        <span class="comment">//方式1：返回 Action.ReconsumeLater，消息将重试</span></span><br><span class="line">        <span class="keyword">return</span> Action.ReconsumeLater;</span><br><span class="line">        <span class="comment">//方式2：返回 null，消息将重试</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//方式3：直接抛出异常， 消息将重试</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Consumer Message exceotion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费失败后，不重试配置方式</strong></p>
<p>集群消费方式下，消息失败后期望消息不重试，需要捕获消费逻辑中可能抛出的异常，最终返回 Action.CommitMessage，此后这条消息将不会再重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doConsumeMessage(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">//捕获消费逻辑中的所有异常，并返回 Action.CommitMessage;</span></span><br><span class="line">            <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息处理正常，直接返回 Action.CommitMessage;</span></span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义消息最大重试次数</strong></p>
<p>消息队列 RocketMQ 允许 Consumer 启动的时候设置最大重试次数，重试时间间隔将按照如下策略：</p>
<ul>
<li>最大重试次数小于等于 16 次，则重试时间间隔同上表描述。</li>
<li>最大重试次数大于 16 次，超过 16 次的重试时间间隔均为每次 2 小时。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//配置对应 Group ID 的最大消息重试次数为 20 次</span></span><br><span class="line">properties.put(PropertyKeyConst.MaxReconsumeTimes,<span class="string">"20"</span>);</span><br><span class="line">Consumer consumer =ONSFactory.createConsumer(properties);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>消息最大重试次数的设置对相同 Group ID 下的所有 Consumer 实例有效。</li>
<li>如果只对相同 Group ID 下两个 Consumer 实例中的其中一个设置了 MaxReconsumeTimes，那么该配置对两个 Consumer 实例均生效。</li>
<li>配置采用覆盖的方式生效，即最后启动的 Consumer 实例会覆盖之前的启动实例的配置</li>
</ul>
<p><strong>获取消息重试次数</strong></p>
<p>消费者收到消息后，可按照如下方式获取消息的重试次数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取消息的重试次数</span></span><br><span class="line">        System.out.println(message.getReconsumeTimes());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="1-5-死信队列"><a href="#1-5-死信队列" class="headerlink" title="1.5 死信队列"></a>1.5 死信队列</h3><p>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p>
<p><strong>在消息队列 RocketMQ 中，这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。</strong></p>
<h4 id="1-5-1-死信特性"><a href="#1-5-1-死信特性" class="headerlink" title="1.5.1 死信特性"></a>1.5.1 死信特性</h4><p><strong>死信消息具有以下特性</strong></p>
<ul>
<li>不会再被消费者正常消费。</li>
<li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，请在死信消息产生后的 3 天内及时处理。</li>
</ul>
<p><strong>死信队列具有以下特性：</strong></p>
<ul>
<li>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例。</li>
<li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li>
<li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li>
</ul>
<h4 id="1-5-2-查看死信信息"><a href="#1-5-2-查看死信信息" class="headerlink" title="1.5.2 查看死信信息"></a>1.5.2 查看死信信息</h4><ol>
<li>在控制台查询出现死信队列的主题信息</li>
</ol>
<p><img src="/2021/07/28/rocketMQ/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%B8%BB%E9%A2%98.png" alt></p>
<ol start="2">
<li>在消息界面根据主题查询死信消息</li>
</ol>
<p><img src="/2021/07/28/rocketMQ/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%B8%BB%E9%A2%982.png" alt></p>
<ol start="3">
<li>选择重新发送消息</li>
</ol>
<p>一条消息进入死信队列，意味着某些因素导致消费者无法正常消费该消息，因此，通常需要您对其进行特殊处理。排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息，让消费者重新消费一次。</p>
<h3 id="1-6-消费幂等"><a href="#1-6-消费幂等" class="headerlink" title="1.6 消费幂等"></a>1.6 消费幂等</h3><p>消息队列 RocketMQ 消费者在接收到消息以后，有必要根据业务上的唯一 Key 对消息做幂等处理的必要性。</p>
<h4 id="1-6-1-消费幂等的必要性"><a href="#1-6-1-消费幂等的必要性" class="headerlink" title="1.6.1 消费幂等的必要性"></a>1.6.1 消费幂等的必要性</h4><p>在互联网应用中，尤其在网络不稳定的情况下，消息队列 RocketMQ 的消息有可能会出现重复，这个重复简单可以概括为以下情况：</p>
<ul>
<li><p><strong>发送时消息重复</strong></p>
<p>当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li><p><strong>投递时消息重复</strong></p>
<p>消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。 为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li><p><strong>负载均衡时消息重复（包括但不限于网络抖动、Broker 重启以及订阅方应用重启）</strong></p>
<p>当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息。</p>
</li>
</ul>
<h4 id="1-6-2-处理方式"><a href="#1-6-2-处理方式" class="headerlink" title="1.6.2 处理方式"></a>1.6.2 处理方式</h4><p>因为 Message ID 有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据。 最好的方式是<strong>以业务唯一标识作为幂等处理的关键依据</strong>，而业务的唯一标识可以通过消息 Key 进行设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message message = <span class="keyword">new</span> Message();</span><br><span class="line">message.setKey(<span class="string">"ORDERID_100"</span>);</span><br><span class="line">SendResult sendResult = producer.send(message);</span><br></pre></td></tr></table></figure>

<p>订阅方收到消息时可以根据消息的 Key 进行幂等处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">"ons_test"</span>, <span class="string">"*"</span>, <span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        String key = message.getKey()</span><br><span class="line">        <span class="comment">// 根据业务唯一标识的 key 做幂等处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>







<h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><h3 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h3><p>依赖工具</p>
<ul>
<li>JDK ：1.8+</li>
<li>Maven</li>
<li>IntelliJ IDEA</li>
</ul>
<h4 id="2-1-1-源码拉取"><a href="#2-1-1-源码拉取" class="headerlink" title="2.1.1 源码拉取"></a>2.1.1 源码拉取</h4><p>从官方仓库 <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">https://github.com/apache/rocketmq</a> <code>clone</code>或者<code>download</code>源码。</p>
<p><img src="/2021/07/28/rocketMQ/%E6%BA%90%E7%A0%811.png" alt></p>
<p><strong>源码目录结构：</strong></p>
<ul>
<li><p>broker: broker 模块（broke 启动进程） </p>
</li>
<li><p>client ：消息客户端，包含消息生产者、消息消费者相关类 </p>
</li>
<li><p>common ：公共包 </p>
</li>
<li><p>dev ：开发者信息（非源代码） </p>
</li>
<li><p>distribution ：部署实例文件夹（非源代码） </p>
</li>
<li><p>example: RocketMQ 例代码 </p>
</li>
<li><p>filter ：消息过滤相关基础类</p>
</li>
<li><p>filtersrv：消息过滤服务器实现相关类（Filter启动进程）</p>
</li>
<li><p>logappender：日志实现相关类</p>
</li>
<li><p>namesrv：NameServer实现相关类（NameServer启动进程）</p>
</li>
<li><p>openmessageing：消息开放标准</p>
</li>
<li><p>remoting：远程通信模块，给予Netty</p>
</li>
<li><p>srcutil：服务工具类</p>
</li>
<li><p>store：消息存储实现相关类</p>
</li>
<li><p>style：checkstyle相关实现</p>
</li>
<li><p>test：测试相关类</p>
</li>
<li><p>tools：工具类，监控命令相关实现类</p>
</li>
</ul>
<h4 id="2-1-2-导入IDEA"><a href="#2-1-2-导入IDEA" class="headerlink" title="2.1.2 导入IDEA"></a>2.1.2 导入IDEA</h4><p><img src="/2021/07/28/rocketMQ/%E6%BA%90%E7%A0%812.png" alt></p>
<p><strong>执行安装</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean install -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-调试"><a href="#2-1-3-调试" class="headerlink" title="2.1.3 调试"></a>2.1.3 调试</h4><p>创建<code>conf</code>配置文件夹,从<code>distribution</code>拷贝<code>broker.conf</code>和<code>logback_broker.xml</code>和<code>logback_namesrv.xml</code></p>
<p><img src="/2021/07/28/rocketMQ/%E6%BA%90%E7%A0%816.png" alt></p>
<h5 id="1）启动NameServer"><a href="#1）启动NameServer" class="headerlink" title="1）启动NameServer"></a>1）启动NameServer</h5><ul>
<li>展开namesrv模块，右键NamesrvStartup.java</li>
</ul>
<p><img src="/2021/07/28/rocketMQ/%E6%BA%90%E7%A0%813.png" alt></p>
<ul>
<li>配置<strong>ROCKETMQ_HOME</strong></li>
</ul>
<p><img src="/2021/07/28/rocketMQ/%E6%BA%90%E7%A0%814.png" alt></p>
<p><img src="/2021/07/28/rocketMQ/%E6%BA%90%E7%A0%815.png" alt></p>
<ul>
<li><p>重新启动</p>
<p>控制台打印结果</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Name Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure>

<h5 id="2）启动Broker"><a href="#2）启动Broker" class="headerlink" title="2）启动Broker"></a>2）启动Broker</h5><ul>
<li><code>broker.conf</code>配置文件内容</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">brokerClusterName</span> = <span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span> = <span class="string">broker-a</span></span><br><span class="line"><span class="attr">brokerId</span> = <span class="string">0</span></span><br><span class="line"><span class="comment"># namesrvAddr地址</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">127.0.0.1:9876</span></span><br><span class="line"><span class="attr">deleteWhen</span> = <span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span> = <span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span> = <span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="attr">flushDiskType</span> = <span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">E:\\RocketMQ\\data\\rocketmq\\dataDir</span></span><br><span class="line"><span class="comment"># commitLog路径</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">E:\\RocketMQ\\data\\rocketmq\\dataDir\\commitlog</span></span><br><span class="line"><span class="comment"># 消息队列存储路径</span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">E:\\RocketMQ\\data\\rocketmq\\dataDir\\consumequeue</span></span><br><span class="line"><span class="comment"># 消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">E:\\RocketMQ\\data\\rocketmq\\dataDir\\index</span></span><br><span class="line"><span class="comment"># checkpoint文件路径</span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">E:\\RocketMQ\\data\\rocketmq\\dataDir\\checkpoint</span></span><br><span class="line"><span class="comment"># abort文件存储路径</span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">E:\\RocketMQ\\data\\rocketmq\\dataDir\\abort</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建数据文件夹<code>dataDir</code></li>
<li>启动<code>BrokerStartup</code>,配置<code>broker.conf</code>和<code>ROCKETMQ_HOME</code></li>
</ul>
<p><img src="/2021/07/28/rocketMQ/%E6%BA%90%E7%A0%817.png" alt></p>
<p><img src="/2021/07/28/rocketMQ/%E6%BA%90%E7%A0%818.png" alt></p>
<h5 id="3）发送消息"><a href="#3）发送消息" class="headerlink" title="3）发送消息"></a>3）发送消息</h5><ul>
<li>进入example模块的<code>org.apache.rocketmq.example.quickstart</code></li>
<li>指定Namesrv地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>运行<code>main</code>方法，发送消息</li>
</ul>
<h5 id="4）消费消息"><a href="#4）消费消息" class="headerlink" title="4）消费消息"></a>4）消费消息</h5><ul>
<li>进入example模块的<code>org.apache.rocketmq.example.quickstart</code></li>
<li>指定Namesrv地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line">consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>运行<code>main</code>方法，消费消息</li>
</ul>
<h3 id="2-2-NameServer"><a href="#2-2-NameServer" class="headerlink" title="2.2 NameServer"></a>2.2 NameServer</h3><h4 id="2-2-1-架构设计"><a href="#2-2-1-架构设计" class="headerlink" title="2.2.1 架构设计"></a>2.2.1 架构设计</h4><p>消息中间件的设计思路一般是基于主题订阅发布的机制，消息生产者（Producer）发送某一个主题到消息服务器，消息服务器负责将消息持久化存储，消息消费者（Consumer）订阅该兴趣的主题，消息服务器根据订阅信息（路由信息）将消息推送到消费者（Push模式）或者消费者主动向消息服务器拉去（Pull模式），从而实现消息生产者与消息消费者解耦。为了避免消息服务器的单点故障导致的整个系统瘫痪，通常会部署多台消息服务器共同承担消息的存储。那消息生产者如何知道消息要发送到哪台消息服务器呢？如果某一台消息服务器宕机了，那么消息生产者如何在不重启服务情况下感知呢？</p>
<p>NameServer就是为了解决以上问题设计的。</p>
<p><img src="/2021/07/28/rocketMQ/RocketMQ%E8%A7%92%E8%89%B2.jpg" alt></p>
<p>Broker消息服务器在启动的时向所有NameServer注册，消息生产者（Producer）在发送消息时之前先从NameServer获取Broker服务器地址列表，然后根据负载均衡算法从列表中选择一台服务器进行发送。NameServer与每台Broker保持长连接，并间隔30S检测Broker是否存活，如果检测到Broker宕机，则从路由注册表中删除。但是路由变化不会马上通知消息生产者。这样设计的目的是为了降低NameServer实现的复杂度，在消息发送端提供容错机制保证消息发送的可用性。</p>
<p>NameServer本身的高可用是通过部署多台NameServer来实现，但彼此之间不通讯，也就是NameServer服务器之间在某一个时刻的数据并不完全相同，但这对消息发送并不会造成任何影响，这也是NameServer设计的一个亮点，总之，RocketMQ设计追求简单高效。</p>
<h4 id="2-2-2-启动流程"><a href="#2-2-2-启动流程" class="headerlink" title="2.2.2 启动流程"></a>2.2.2 启动流程</h4><p><img src="/2021/07/28/rocketMQ/NameServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt></p>
<p>启动类：<code>org.apache.rocketmq.namesrv.NamesrvStartup</code></p>
<h5 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h5><p>解析配置文件，填充NameServerConfig、NettyServerConfig属性值，并创建NamesrvController</p>
<p><strong><em>代码：NamesrvController#createNamesrvController</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建NamesrvConfig</span></span><br><span class="line"><span class="keyword">final</span> NamesrvConfig namesrvConfig = <span class="keyword">new</span> NamesrvConfig();</span><br><span class="line"><span class="comment">//创建NettyServerConfig</span></span><br><span class="line"><span class="keyword">final</span> NettyServerConfig nettyServerConfig = <span class="keyword">new</span> NettyServerConfig();</span><br><span class="line"><span class="comment">//设置启动端口号</span></span><br><span class="line">nettyServerConfig.setListenPort(<span class="number">9876</span>);</span><br><span class="line"><span class="comment">//解析启动-c参数</span></span><br><span class="line"><span class="keyword">if</span> (commandLine.hasOption(<span class="string">'c'</span>)) &#123;</span><br><span class="line">    String file = commandLine.getOptionValue(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(in);</span><br><span class="line">        MixAll.properties2Object(properties, namesrvConfig);</span><br><span class="line">        MixAll.properties2Object(properties, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">        namesrvConfig.setConfigStorePath(file);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"load config properties file OK, %s%n"</span>, file);</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析启动-p参数</span></span><br><span class="line"><span class="keyword">if</span> (commandLine.hasOption(<span class="string">'p'</span>)) &#123;</span><br><span class="line">    InternalLogger console = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME);</span><br><span class="line">    MixAll.printObjectProperties(console, namesrvConfig);</span><br><span class="line">    MixAll.printObjectProperties(console, nettyServerConfig);</span><br><span class="line">    System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将启动参数填充到namesrvConfig,nettyServerConfig</span></span><br><span class="line">MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建NameServerController</span></span><br><span class="line"><span class="keyword">final</span> NamesrvController controller = <span class="keyword">new</span> NamesrvController(namesrvConfig, nettyServerConfig);</span><br></pre></td></tr></table></figure>

<p><u><strong>NamesrvConfig属性</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));</span><br><span class="line"><span class="keyword">private</span> String kvConfigPath = System.getProperty(<span class="string">"user.home"</span>) + File.separator + <span class="string">"namesrv"</span> + File.separator + <span class="string">"kvConfig.json"</span>;</span><br><span class="line"><span class="keyword">private</span> String configStorePath = System.getProperty(<span class="string">"user.home"</span>) + File.separator + <span class="string">"namesrv"</span> + File.separator + <span class="string">"namesrv.properties"</span>;</span><br><span class="line"><span class="keyword">private</span> String productEnvName = <span class="string">"center"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> clusterTest = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> orderMessageEnable = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p><strong>rocketmqHome：</strong>rocketmq主目录</p>
<p><strong>kvConfig：</strong>NameServer存储KV配置属性的持久化路径</p>
<p><strong>configStorePath：</strong>nameServer默认配置文件路径</p>
<p><strong>orderMessageEnable：</strong>是否支持顺序消息</p>
<p><u><strong>NettyServerConfig属性</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> listenPort = <span class="number">8888</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverWorkerThreads = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverCallbackExecutorThreads = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSelectorThreads = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverOnewaySemaphoreValue = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverAsyncSemaphoreValue = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverChannelMaxIdleTimeSeconds = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSocketSndBufSize = NettySystemConfig.socketSndbufSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSocketRcvBufSize = NettySystemConfig.socketRcvbufSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> serverPooledByteBufAllocatorEnable = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useEpollNativeSelector = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p><strong>listenPort：</strong>NameServer监听端口，该值默认会被初始化为9876<br><strong>serverWorkerThreads：</strong>Netty业务线程池线程个数<br><strong>serverCallbackExecutorThreads：</strong>Netty public任务线程池线程个数，Netty网络设计，根据业务类型会创建不同的线程池，比如处理消息发送、消息消费、心跳检测等。如果该业务类型未注册线程池，则由public线程池执行。<br><strong>serverSelectorThreads：</strong>IO线程池个数，主要是NameServer、Broker端解析请求、返回相应的线程个数，这类线程主要是处理网路请求的，解析请求包，然后转发到各个业务线程池完成具体的操作，然后将结果返回给调用方;<br><strong>serverOnewaySemaphoreValue：</strong>send oneway消息请求并发读（Broker端参数）;<br><strong>serverAsyncSemaphoreValue：</strong>异步消息发送最大并发度;<br><strong>serverChannelMaxIdleTimeSeconds ：</strong>网络连接最大的空闲时间，默认120s。<br><strong>serverSocketSndBufSize：</strong>网络socket发送缓冲区大小。<br><strong>serverSocketRcvBufSize：</strong> 网络接收端缓存区大小。<br><strong>serverPooledByteBufAllocatorEnable：</strong>ByteBuffer是否开启缓存;<br><strong>useEpollNativeSelector：</strong>是否启用Epoll IO模型。</p>
<h5 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h5><p>根据启动属性创建NamesrvController实例，并初始化该实例。NameServerController实例为NameServer核心控制器</p>
<p><strong><em>代码：NamesrvController#initialize</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//加载KV配置</span></span><br><span class="line">    <span class="keyword">this</span>.kvConfigManager.load();</span><br><span class="line">	<span class="comment">//创建NettyServer网络处理对象</span></span><br><span class="line">    <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.brokerHousekeepingService);</span><br><span class="line">	<span class="comment">//开启定时任务:每隔10s扫描一次Broker,移除不活跃的Broker</span></span><br><span class="line">    <span class="keyword">this</span>.remotingExecutor =</span><br><span class="line">        Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"RemotingExecutorThread_"</span>));</span><br><span class="line">    <span class="keyword">this</span>.registerProcessor();</span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">	<span class="comment">//开启定时任务:每隔10min打印一次KV配置</span></span><br><span class="line">	<span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NamesrvController.<span class="keyword">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h5><p>在JVM进程关闭之前，先将线程池关闭，及时释放资源</p>
<p><strong><em>代码：NamesrvStartup#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册JVM钩子函数代码</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> ShutdownHookThread(log, <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        controller.shutdown();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-路由管理"><a href="#2-2-3-路由管理" class="headerlink" title="2.2.3 路由管理"></a>2.2.3 路由管理</h4><p>NameServer的主要作用是为消息的生产者和消息消费者提供关于主题Topic的路由信息，那么NameServer需要存储路由的基础信息，还要管理Broker节点，包括路由注册、路由删除等。</p>
<h5 id="2-2-3-1-路由元信息"><a href="#2-2-3-1-路由元信息" class="headerlink" title="2.2.3.1 路由元信息"></a>2.2.3.1 路由元信息</h5><p><strong><em>代码：RouteInfoManager</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/28/rocketMQ/%E8%B7%AF%E7%94%B1%E5%AE%9E%E4%BD%93%E5%9B%BE.png" alt></p>
<p><strong>topicQueueTable：</strong>Topic消息队列路由信息，消息发送时根据路由表进行负载均衡</p>
<p><strong>brokerAddrTable：</strong>Broker基础信息，包括brokerName、所属集群名称、主备Broker地址</p>
<p><strong>clusterAddrTable：</strong>Broker集群信息，存储集群中所有Broker名称</p>
<p><strong>brokerLiveTable：</strong>Broker状态信息，NameServer每次收到心跳包是会替换该信息</p>
<p><strong>filterServerTable：</strong>Broker上的FilterServer列表，用于类模式消息过滤。</p>
<blockquote>
<p>RocketMQ基于定于发布机制，一个Topic拥有多个消息队列，一个Broker为每一个主题创建4个读队列和4个写队列。多个Broker组成一个集群，集群由相同的多台Broker组成Master-Slave架构，brokerId为0代表Master，大于0为Slave。BrokerLiveInfo中的lastUpdateTimestamp存储上次收到Broker心跳包的时间。</p>
</blockquote>
<p><img src="/2021/07/28/rocketMQ/%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E5%AE%9E%E4%BE%8B.png" alt></p>
<p><img src="/2021/07/28/rocketMQ/%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E5%AE%9E%E4%BE%8B2.png" alt></p>
<h5 id="2-2-3-2-路由注册"><a href="#2-2-3-2-路由注册" class="headerlink" title="2.2.3.2 路由注册"></a>2.2.3.2 路由注册</h5><h6 id="1）发送心跳包"><a href="#1）发送心跳包" class="headerlink" title="1）发送心跳包"></a>1）发送心跳包</h6><p><img src="/2021/07/28/rocketMQ/%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C.png" alt></p>
<p>RocketMQ路由注册是通过Broker与NameServer的心跳功能实现的。Broker启动时向集群中所有的NameServer发送心跳信息，每隔30s向集群中所有NameServer发送心跳包，NameServer收到心跳包时会更新brokerLiveTable缓存中BrokerLiveInfo的lastUpdataTimeStamp信息，然后NameServer每隔10s扫描brokerLiveTable，如果连续120S没有收到心跳包，NameServer将移除Broker的路由信息同时关闭Socket连接。</p>
<p><strong><em>代码：BrokerController#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册Broker信息</span></span><br><span class="line"><span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//每隔30s上报Broker信息到NameServer</span></span><br><span class="line"><span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BrokerController.<span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"registerBrokerAll Exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), </span><br><span class="line">                                                  TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：BrokerOuterAPI#registerBrokerAll</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得nameServer地址信息</span></span><br><span class="line">List&lt;String&gt; nameServerAddressList = <span class="keyword">this</span>.remotingClient.getNameServerAddressList();</span><br><span class="line"><span class="comment">//遍历所有nameserver列表</span></span><br><span class="line"><span class="keyword">if</span> (nameServerAddressList != <span class="keyword">null</span> &amp;&amp; nameServerAddressList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装请求头</span></span><br><span class="line">    <span class="keyword">final</span> RegisterBrokerRequestHeader requestHeader = <span class="keyword">new</span> RegisterBrokerRequestHeader();</span><br><span class="line">    requestHeader.setBrokerAddr(brokerAddr);</span><br><span class="line">    requestHeader.setBrokerId(brokerId);</span><br><span class="line">    requestHeader.setBrokerName(brokerName);</span><br><span class="line">    requestHeader.setClusterName(clusterName);</span><br><span class="line">    requestHeader.setHaServerAddr(haServerAddr);</span><br><span class="line">    requestHeader.setCompressed(compressed);</span><br><span class="line">	<span class="comment">//封装请求体</span></span><br><span class="line">    RegisterBrokerBody requestBody = <span class="keyword">new</span> RegisterBrokerBody();</span><br><span class="line">    requestBody.setTopicConfigSerializeWrapper(topicConfigWrapper);</span><br><span class="line">    requestBody.setFilterServerList(filterServerList);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] body = requestBody.encode(compressed);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bodyCrc32 = UtilAll.crc32(body);</span><br><span class="line">    requestHeader.setBodyCrc32(bodyCrc32);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(nameServerAddressList.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String namesrvAddr : nameServerAddressList) &#123;</span><br><span class="line">        brokerOuterExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//分别向NameServer注册</span></span><br><span class="line">                    RegisterBrokerResult result = registerBroker(namesrvAddr,oneway, timeoutMills,requestHeader,body);</span><br><span class="line">                    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        registerBrokerResultList.add(result);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">"register broker[&#123;&#125;]to name server &#123;&#125; OK"</span>, brokerId, namesrvAddr);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.warn(<span class="string">"registerBroker Exception, &#123;&#125;"</span>, namesrvAddr, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：BrokerOutAPI#registerBroker</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oneway) &#123;    <span class="keyword">try</span> &#123;        <span class="keyword">this</span>.remotingClient.invokeOneway(namesrvAddr, request, timeoutMills);    &#125; <span class="keyword">catch</span> (RemotingTooMuchRequestException e) &#123;        <span class="comment">// Ignore    &#125;    return null;&#125;RemotingCommand response = this.remotingClient.invokeSync(namesrvAddr, request, timeoutMills);</span></span><br></pre></td></tr></table></figure>

<h6 id="2）处理心跳包"><a href="#2）处理心跳包" class="headerlink" title="2）处理心跳包"></a>2）处理心跳包</h6><p><img src="/2021/07/28/rocketMQ/NameServer%E5%A4%84%E7%90%86%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C.png" alt></p>
<p><code>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor</code>网路处理类解析请求类型，如果请求类型是为<strong><em>REGISTER_BROKER</em></strong>，则将请求转发到<code>RouteInfoManager#regiesterBroker</code></p>
<p><strong><em>代码：DefaultRequestProcessor#processRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是注册Broker信息case RequestCode.REGISTER_BROKER:	Version brokerVersion = MQVersion.value2Version(request.getVersion());	if (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;	    return this.registerBrokerWithFilterServer(ctx, request);	&#125; else &#123;        //注册Broker信息	    return this.registerBroker(ctx, request);	&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultRequestProcessor#registerBroker</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RegisterBrokerResult result = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().registerBroker(    requestHeader.getClusterName(),    requestHeader.getBrokerAddr(),    requestHeader.getBrokerName(),    requestHeader.getBrokerId(),    requestHeader.getHaServerAddr(),    topicConfigWrapper,    <span class="keyword">null</span>,    ctx.channel());</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：RouteInfoManager#registerBroker</em></strong></p>
<p>维护路由信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line"><span class="comment">//维护clusterAddrTable</span></span><br><span class="line">Set&lt;String&gt; brokerNames = <span class="keyword">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerNames) &#123;</span><br><span class="line">    brokerNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="keyword">this</span>.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">&#125;</span><br><span class="line">brokerNames.add(brokerName);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护brokerAddrTable</span></span><br><span class="line">BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line"><span class="comment">//第一次注册,则创建brokerData</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">    registerFirst = <span class="keyword">true</span>;</span><br><span class="line">    brokerData = <span class="keyword">new</span> BrokerData(clusterName, brokerName, <span class="keyword">new</span> HashMap&lt;Long, String&gt;());</span><br><span class="line">    <span class="keyword">this</span>.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非第一次注册,更新Broker</span></span><br><span class="line">Map&lt;Long, String&gt; brokerAddrsMap = brokerData.getBrokerAddrs();</span><br><span class="line">Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerAddrsMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Entry&lt;Long, String&gt; item = it.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId != item.getKey()) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">registerFirst = registerFirst || (<span class="keyword">null</span> == oldAddr);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护topicQueueTable</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != topicConfigWrapper &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion()) || </span><br><span class="line">        registerFirst) &#123;</span><br><span class="line">        ConcurrentMap&lt;String, TopicConfig&gt; tcTable = topicConfigWrapper.getTopicConfigTable();</span><br><span class="line">        <span class="keyword">if</span> (tcTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：RouteInfoManager#createAndUpdateQueueData</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createAndUpdateQueueData</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> TopicConfig topicConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建QueueData</span></span><br><span class="line">	QueueData queueData = <span class="keyword">new</span> QueueData();</span><br><span class="line">	queueData.setBrokerName(brokerName);</span><br><span class="line">	queueData.setWriteQueueNums(topicConfig.getWriteQueueNums());</span><br><span class="line">	queueData.setReadQueueNums(topicConfig.getReadQueueNums());</span><br><span class="line">	queueData.setPerm(topicConfig.getPerm());</span><br><span class="line">	queueData.setTopicSynFlag(topicConfig.getTopicSysFlag());</span><br><span class="line">	<span class="comment">//获得topicQueueTable中队列集合</span></span><br><span class="line">	List&lt;QueueData&gt; queueDataList = <span class="keyword">this</span>.topicQueueTable.get(topicConfig.getTopicName());</span><br><span class="line">    <span class="comment">//topicQueueTable为空,则直接添加queueData到队列集合</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == queueDataList) &#123;</span><br><span class="line">	    queueDataList = <span class="keyword">new</span> LinkedList&lt;QueueData&gt;();</span><br><span class="line">	    queueDataList.add(queueData);</span><br><span class="line">	    <span class="keyword">this</span>.topicQueueTable.put(topicConfig.getTopicName(), queueDataList);</span><br><span class="line">	    log.info(<span class="string">"new topic registered, &#123;&#125; &#123;&#125;"</span>, topicConfig.getTopicName(), queueData);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否是新的队列</span></span><br><span class="line">	    <span class="keyword">boolean</span> addNewOne = <span class="keyword">true</span>;</span><br><span class="line">	    Iterator&lt;QueueData&gt; it = queueDataList.iterator();</span><br><span class="line">	    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">	        QueueData qd = it.next();</span><br><span class="line">            <span class="comment">//如果brokerName相同,代表不是新的队列</span></span><br><span class="line">	        <span class="keyword">if</span> (qd.getBrokerName().equals(brokerName)) &#123;</span><br><span class="line">	            <span class="keyword">if</span> (qd.equals(queueData)) &#123;</span><br><span class="line">	                addNewOne = <span class="keyword">false</span>;</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	                    log.info(<span class="string">"topic changed, &#123;&#125; OLD: &#123;&#125; NEW: &#123;&#125;"</span>, topicConfig.getTopicName(), qd,</span><br><span class="line">	                        queueData);</span><br><span class="line">	                    it.remove();</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">		<span class="comment">//如果是新的队列,则添加队列到queueDataList</span></span><br><span class="line">        <span class="keyword">if</span> (addNewOne) &#123;</span><br><span class="line">            queueDataList.add(queueData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护brokerLiveTable</span></span><br><span class="line">BrokerLiveInfo prevBrokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.put(brokerAddr,<span class="keyword">new</span> BrokerLiveInfo(</span><br><span class="line">    System.currentTimeMillis(),</span><br><span class="line">    topicConfigWrapper.getDataVersion(),</span><br><span class="line">    channel,</span><br><span class="line">    haServerAddr));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护filterServerList</span></span><br><span class="line"><span class="keyword">if</span> (filterServerList != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (filterServerList.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.filterServerTable.remove(brokerAddr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">    String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">    <span class="keyword">if</span> (masterAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        BrokerLiveInfo brokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line">        <span class="keyword">if</span> (brokerLiveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">            result.setMasterAddr(masterAddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-3-路由删除"><a href="#2-2-3-3-路由删除" class="headerlink" title="2.2.3.3 路由删除"></a>2.2.3.3 路由删除</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**RocketMQ有两个触发点来删除路由信息**：</span><br><span class="line"></span><br><span class="line">* NameServer定期扫描brokerLiveTable检测上次心跳包与当前系统的时间差，如果时间超过120s，则需要移除broker。</span><br><span class="line">* Broker在正常关闭的情况下，会执行unregisterBroker指令</span><br><span class="line"></span><br><span class="line">这两种方式路由删除的方法都是一样的，就是从相关路由表中删除与该broker相关的信息。</span><br><span class="line"></span><br><span class="line">![](rocketMQ&#x2F;路由删除.png)</span><br><span class="line"></span><br><span class="line">***代码：NamesrvController#initialize***</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;每隔10s扫描一次为活跃Brokerthis.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;    @Override    public void run() &#123;        NamesrvController.this.routeInfoManager.scanNotActiveBroker();    &#125;&#125;, 5, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：RouteInfoManager#scanNotActiveBroker</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanNotActiveBroker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得brokerLiveTable</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = <span class="keyword">this</span>.brokerLiveTable.entrySet().iterator();</span><br><span class="line">    <span class="comment">//遍历brokerLiveTable</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, BrokerLiveInfo&gt; next = it.next();</span><br><span class="line">        <span class="keyword">long</span> last = next.getValue().getLastUpdateTimestamp();</span><br><span class="line">        <span class="comment">//如果收到心跳包的时间距当时时间是否超过120s</span></span><br><span class="line">        <span class="keyword">if</span> ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class="line">            <span class="comment">//移除broker</span></span><br><span class="line">            it.remove();</span><br><span class="line">            <span class="comment">//维护路由表</span></span><br><span class="line">            <span class="keyword">this</span>.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：RouteInfoManager#onChannelDestroy</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请写锁,根据brokerAddress从brokerLiveTable和filterServerTable移除</span></span><br><span class="line"><span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line"><span class="keyword">this</span>.brokerLiveTable.remove(brokerAddrFound);</span><br><span class="line"><span class="keyword">this</span>.filterServerTable.remove(brokerAddrFound);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护brokerAddrTable</span></span><br><span class="line">String brokerNameFound = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> removeBrokerName = <span class="keyword">false</span>;</span><br><span class="line">Iterator&lt;Entry&lt;String, BrokerData&gt;&gt; itBrokerAddrTable =<span class="keyword">this</span>.brokerAddrTable.entrySet().iterator();</span><br><span class="line"><span class="comment">//遍历brokerAddrTable</span></span><br><span class="line"><span class="keyword">while</span> (itBrokerAddrTable.hasNext() &amp;&amp; (<span class="keyword">null</span> == brokerNameFound)) &#123;</span><br><span class="line">    BrokerData brokerData = itBrokerAddrTable.next().getValue();</span><br><span class="line">    <span class="comment">//遍历broker地址</span></span><br><span class="line">    Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerData.getBrokerAddrs().entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;Long, String&gt; entry = it.next();</span><br><span class="line">        Long brokerId = entry.getKey();</span><br><span class="line">        String brokerAddr = entry.getValue();</span><br><span class="line">        <span class="comment">//根据broker地址移除brokerAddr</span></span><br><span class="line">        <span class="keyword">if</span> (brokerAddr.equals(brokerAddrFound)) &#123;</span><br><span class="line">            brokerNameFound = brokerData.getBrokerName();</span><br><span class="line">            it.remove();</span><br><span class="line">            log.info(<span class="string">"remove brokerAddr[&#123;&#125;, &#123;&#125;] from brokerAddrTable, because channel destroyed"</span>,</span><br><span class="line">                brokerId, brokerAddr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果当前主题只包含待移除的broker,则移除该topic</span></span><br><span class="line">    <span class="keyword">if</span> (brokerData.getBrokerAddrs().isEmpty()) &#123;</span><br><span class="line">        removeBrokerName = <span class="keyword">true</span>;</span><br><span class="line">        itBrokerAddrTable.remove();</span><br><span class="line">        log.info(<span class="string">"remove brokerName[&#123;&#125;] from brokerAddrTable, because channel destroyed"</span>,</span><br><span class="line">            brokerData.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护clusterAddrTable</span></span><br><span class="line"><span class="keyword">if</span> (brokerNameFound != <span class="keyword">null</span> &amp;&amp; removeBrokerName) &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;String, Set&lt;String&gt;&gt;&gt; it = <span class="keyword">this</span>.clusterAddrTable.entrySet().iterator();</span><br><span class="line">    <span class="comment">//遍历clusterAddrTable</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, Set&lt;String&gt;&gt; entry = it.next();</span><br><span class="line">        <span class="comment">//获得集群名称</span></span><br><span class="line">        String clusterName = entry.getKey();</span><br><span class="line">        <span class="comment">//获得集群中brokerName集合</span></span><br><span class="line">        Set&lt;String&gt; brokerNames = entry.getValue();</span><br><span class="line">        <span class="comment">//从brokerNames中移除brokerNameFound</span></span><br><span class="line">        <span class="keyword">boolean</span> removed = brokerNames.remove(brokerNameFound);</span><br><span class="line">        <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">            log.info(<span class="string">"remove brokerName[&#123;&#125;], clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed"</span>,</span><br><span class="line">                brokerNameFound, clusterName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerNames.isEmpty()) &#123;</span><br><span class="line">                log.info(<span class="string">"remove the clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed and no broker in this cluster"</span>,</span><br><span class="line">                    clusterName);</span><br><span class="line">                <span class="comment">//如果集群中不包含任何broker,则移除该集群</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护topicQueueTable队列</span></span><br><span class="line"><span class="keyword">if</span> (removeBrokerName) &#123;</span><br><span class="line">    <span class="comment">//遍历topicQueueTable</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, List&lt;QueueData&gt;&gt;&gt; itTopicQueueTable =</span><br><span class="line">        <span class="keyword">this</span>.topicQueueTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (itTopicQueueTable.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, List&lt;QueueData&gt;&gt; entry = itTopicQueueTable.next();</span><br><span class="line">        <span class="comment">//主题名称</span></span><br><span class="line">        String topic = entry.getKey();</span><br><span class="line">        <span class="comment">//队列集合</span></span><br><span class="line">        List&lt;QueueData&gt; queueDataList = entry.getValue();</span><br><span class="line">		<span class="comment">//遍历该主题队列</span></span><br><span class="line">        Iterator&lt;QueueData&gt; itQueueData = queueDataList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (itQueueData.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//从队列中移除为活跃broker信息</span></span><br><span class="line">            QueueData queueData = itQueueData.next();</span><br><span class="line">            <span class="keyword">if</span> (queueData.getBrokerName().equals(brokerNameFound)) &#123;</span><br><span class="line">                itQueueData.remove();</span><br><span class="line">                log.info(<span class="string">"remove topic[&#123;&#125; &#123;&#125;], from topicQueueTable, because channel destroyed"</span>,</span><br><span class="line">                    topic, queueData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果该topic的队列为空,则移除该topic</span></span><br><span class="line">        <span class="keyword">if</span> (queueDataList.isEmpty()) &#123;</span><br><span class="line">            itTopicQueueTable.remove();</span><br><span class="line">            log.info(<span class="string">"remove topic[&#123;&#125;] all queue, from topicQueueTable, because channel destroyed"</span>,</span><br><span class="line">                topic);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放写锁</span></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-4-路由发现"><a href="#2-2-3-4-路由发现" class="headerlink" title="2.2.3.4 路由发现"></a>2.2.3.4 路由发现</h5><p>RocketMQ路由发现是非实时的，当Topic路由出现变化后，NameServer不会主动推送给客户端，而是由客户端定时拉取主题最新的路由。</p>
<p><strong><em>代码：DefaultRequestProcessor#getRouteInfoByTopic</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">getRouteInfoByTopic</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> GetRouteInfoRequestHeader requestHeader =</span><br><span class="line">        (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="comment">//调用RouteInfoManager的方法,从路由表topicQueueTable、brokerAddrTable、filterServerTable中分别填充TopicRouteData的List&lt;QueueData&gt;、List&lt;BrokerData&gt;、filterServer</span></span><br><span class="line">    TopicRouteData topicRouteData = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());</span><br><span class="line">	<span class="comment">//如果找到主题对应你的路由信息并且该主题为顺序消息，则从NameServer KVConfig中获取关于顺序消息相关的配置填充路由信息</span></span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.namesrvController.getNamesrvConfig().isOrderMessageEnable()) &#123;</span><br><span class="line">            String orderTopicConf =</span><br><span class="line">                <span class="keyword">this</span>.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG,</span><br><span class="line">                    requestHeader.getTopic());</span><br><span class="line">            topicRouteData.setOrderTopicConf(orderTopicConf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = topicRouteData.encode();</span><br><span class="line">        response.setBody(content);</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(ResponseCode.TOPIC_NOT_EXIST);</span><br><span class="line">    response.setRemark(<span class="string">"No topic route info in name server for the topic: "</span> + requestHeader.getTopic()</span><br><span class="line">        + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4 小结"></a>2.2.4 小结</h4><p><img src="/2021/07/28/rocketMQ/NameServer%E5%B0%8F%E7%BB%93.png" alt></p>
<h3 id="2-3-Producer"><a href="#2-3-Producer" class="headerlink" title="2.3 Producer"></a>2.3 Producer</h3><p>消息生产者的代码都在client模块中，相对于RocketMQ来讲，消息生产者就是客户端，也是消息的提供者。</p>
<p><img src="/2021/07/28/rocketMQ/DefaultMQProducer%E7%B1%BB%E5%9B%BE.png" alt></p>
<h4 id="2-3-1-方法和属性"><a href="#2-3-1-方法和属性" class="headerlink" title="2.3.1 方法和属性"></a>2.3.1 方法和属性</h4><h5 id="1）主要方法介绍"><a href="#1）主要方法介绍" class="headerlink" title="1）主要方法介绍"></a>1）主要方法介绍</h5><p><img src="/2021/07/28/rocketMQ/MQAdmin.png" alt></p>
<ul>
<li><pre><code class="java"><span class="comment">//创建主题void createTopic(final String key, final String newTopic, final int queueNum) throws MQClientException;</span>
&lt;!--￼<span class="number">94</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="comment">//查找消息队列中最大的偏移量long maxOffset(final MessageQueue mq) throws MQClientException;</span>
&lt;!--￼<span class="number">95</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="comment">//根据偏移量查找消息MessageExt viewMessage(final String offsetMsgId) throws RemotingException, MQBrokerException,        InterruptedException, MQClientException;</span>
&lt;!--￼<span class="number">96</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="comment">//根据消息ID和主题查找消息MessageExt viewMessage(String topic,String msgId) throws RemotingException, MQBrokerException, InterruptedException, MQClientException;</span>
&lt;!--￼<span class="number">97</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="comment">//关闭void shutdown();</span>
&lt;!--￼<span class="number">98</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="comment">//同步发送消息SendResult send(final Message msg) throws MQClientException, RemotingException, MQBrokerException,        InterruptedException;</span>
&lt;!--￼<span class="number">99</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="comment">//异步发送消息void send(final Message msg, final SendCallback sendCallback) throws MQClientException,        RemotingException, InterruptedException;</span>
&lt;!--￼<span class="number">100</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="comment">//发送单向消息void sendOneway(final Message msg) throws MQClientException, RemotingException,    InterruptedException;</span>
&lt;!--￼<span class="number">101</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="comment">//选择指定队列异步发送消息</span>
<span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> SendCallback sendCallback)</span></span>
<span class="function">    <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException</span>;
&lt;!--￼<span class="number">102</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="comment">//批量发送消息</span>
<span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Collection&lt;Message&gt; msgs)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException,InterruptedException</span>;
&lt;!--￼<span class="number">103</span>--&gt;
</code></pre>
</li>
</ul>
<h4 id="2-3-2-启动流程"><a href="#2-3-2-启动流程" class="headerlink" title="2.3.2 启动流程"></a>2.3.2 启动流程</h4><p><img src="/2021/07/28/rocketMQ/%E7%94%9F%E4%BA%A7%E8%80%85%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt></p>
<p><strong><em>代码：DefaultMQProducerImpl#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查生产者组是否满足要求</span></span><br><span class="line"><span class="keyword">this</span>.checkConfig();</span><br><span class="line"><span class="comment">//更改当前instanceName为进程ID</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得MQ客户端实例</span></span><br><span class="line"><span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>整个JVM中只存在一个MQClientManager实例，维护一个MQClientInstance缓存表</p>
<p>ConcurrentMap&lt;String/* clientId */, MQClientInstance&gt; factoryTable = new ConcurrentHashMap&lt;String,MQClientInstance&gt;();</p>
<p>同一个clientId只会创建一个MQClientInstance。</p>
<p>MQClientInstance封装了RocketMQ网络处理API，是消息生产者和消息消费者与NameServer、Broker打交道的网络通道</p>
</blockquote>
<p><strong><em>代码：MQClientManager#getAndCreateMQClientInstance</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MQClientInstance <span class="title">getAndCreateMQClientInstance</span><span class="params">(<span class="keyword">final</span> ClientConfig clientConfig, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                     RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建客户端ID</span></span><br><span class="line">    String clientId = clientConfig.buildMQClientId();</span><br><span class="line">    <span class="comment">//根据客户端ID或者客户端实例</span></span><br><span class="line">    MQClientInstance instance = <span class="keyword">this</span>.factoryTable.get(clientId);</span><br><span class="line">    <span class="comment">//实例如果为空就创建新的实例,并添加到实例表中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">        instance =</span><br><span class="line">            <span class="keyword">new</span> MQClientInstance(clientConfig.cloneClientConfig(),</span><br><span class="line">                <span class="keyword">this</span>.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class="line">        MQClientInstance prev = <span class="keyword">this</span>.factoryTable.putIfAbsent(clientId, instance);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = prev;</span><br><span class="line">            log.warn(<span class="string">"Returned Previous MQClientInstance for clientId:[&#123;&#125;]"</span>, clientId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"Created new MQClientInstance for clientId:[&#123;&#125;]"</span>, clientId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMQProducerImpl#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册当前生产者到到MQClientInstance管理中,方便后续调用网路请求</span></span><br><span class="line"><span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">    <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">        + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">        <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动生产者</span></span><br><span class="line"><span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">    mQClientFactory.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-消息发送"><a href="#2-3-3-消息发送" class="headerlink" title="2.3.3 消息发送"></a>2.3.3 消息发送</h4><p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81.png" alt></p>
<p><strong><em>代码：DefaultMQProducerImpl#send(Message msg)</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> send(msg, <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMQProducerImpl#send(Message msg,long timeout)</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息,默认超时时间为3s</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg,<span class="keyword">long</span> timeout)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class="keyword">null</span>, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMQProducerImpl#sendDefaultImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//校验消息</span></span><br><span class="line">Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br></pre></td></tr></table></figure>

<h5 id="1）验证消息"><a href="#1）验证消息" class="headerlink" title="1）验证消息"></a>1）验证消息</h5><p><strong><em>代码：Validators#checkMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMessage</span><span class="params">(Message msg, DefaultMQProducer defaultMQProducer)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == msg) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">"the message is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验主题</span></span><br><span class="line">    Validators.checkTopic(msg.getTopic());</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 校验消息体</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == msg.getBody()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">"the message body is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == msg.getBody().length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">"the message body length is zero"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg.getBody().length &gt; defaultMQProducer.getMaxMessageSize()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL,</span><br><span class="line">            <span class="string">"the message body size over max value, MAX: "</span> + defaultMQProducer.getMaxMessageSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）查找路由"><a href="#2）查找路由" class="headerlink" title="2）查找路由"></a>2）查找路由</h5><p><strong><em>代码：DefaultMQProducerImpl#tryToFindTopicPublishInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从缓存中获得主题的路由信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    <span class="comment">//路由信息为空,则从NameServer获取路由</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果未找到当前主题的路由信息,则用默认主题继续查找</span></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/28/rocketMQ/Topic%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF.png" alt></p>
<p><strong><em>代码：TopicPublishInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPublishInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> orderTopic = <span class="keyword">false</span>;	<span class="comment">//是否是顺序消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> haveTopicRouterInfo = <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();	<span class="comment">//该主题消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadLocalIndex sendWhichQueue = <span class="keyword">new</span> ThreadLocalIndex();<span class="comment">//每选择一次消息队列,该值+1</span></span><br><span class="line">    <span class="keyword">private</span> TopicRouteData topicRouteData;<span class="comment">//关联Topic路由元信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TopicRouteData topicRouteData;</span><br><span class="line"><span class="comment">//使用默认主题从NameServer获取路由信息</span></span><br><span class="line"><span class="keyword">if</span> (isDefault &amp;&amp; defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),</span><br><span class="line">        <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (QueueData data : topicRouteData.getQueueDatas()) &#123;</span><br><span class="line">            <span class="keyword">int</span> queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());</span><br><span class="line">            data.setReadQueueNums(queueNums);</span><br><span class="line">            data.setWriteQueueNums(queueNums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//使用指定主题从NameServer获取路由信息</span></span><br><span class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断路由是否需要更改</span></span><br><span class="line">TopicRouteData old = <span class="keyword">this</span>.topicRouteTable.get(topic);</span><br><span class="line"><span class="keyword">boolean</span> changed = topicRouteDataIsChange(old, topicRouteData);</span><br><span class="line"><span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">    changed = <span class="keyword">this</span>.isNeedUpdateTopicRouteInfo(topic);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.info(<span class="string">"the topic[&#123;&#125;] route info changed, old[&#123;&#125;] ,new[&#123;&#125;]"</span>, topic, old, topicRouteData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (changed) &#123;</span><br><span class="line">    <span class="comment">//将topicRouteData转换为发布队列</span></span><br><span class="line">    TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);</span><br><span class="line">    publishInfo.setHaveTopicRouterInfo(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//遍历生产</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, MQProducerInner&gt;&gt; it = <span class="keyword">this</span>.producerTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, MQProducerInner&gt; entry = it.next();</span><br><span class="line">        MQProducerInner impl = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//生产者不为空时,更新publishInfo信息</span></span><br><span class="line">            impl.updateTopicPublishInfo(topic, publishInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：MQClientInstance#topicRouteData2TopicPublishInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TopicPublishInfo <span class="title">topicRouteData2TopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> TopicRouteData route)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//创建TopicPublishInfo对象</span></span><br><span class="line">        TopicPublishInfo info = <span class="keyword">new</span> TopicPublishInfo();</span><br><span class="line">    	<span class="comment">//关联topicRoute</span></span><br><span class="line">        info.setTopicRouteData(route);</span><br><span class="line">    	<span class="comment">//顺序消息,更新TopicPublishInfo</span></span><br><span class="line">        <span class="keyword">if</span> (route.getOrderTopicConf() != <span class="keyword">null</span> &amp;&amp; route.getOrderTopicConf().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] brokers = route.getOrderTopicConf().split(<span class="string">";"</span>);</span><br><span class="line">            <span class="keyword">for</span> (String broker : brokers) &#123;</span><br><span class="line">                String[] item = broker.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">int</span> nums = Integer.parseInt(item[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, item[<span class="number">0</span>], i);</span><br><span class="line">                    info.getMessageQueueList().add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            info.setOrderTopic(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非顺序消息更新TopicPublishInfo</span></span><br><span class="line">            List&lt;QueueData&gt; qds = route.getQueueDatas();</span><br><span class="line">            Collections.sort(qds);</span><br><span class="line">            <span class="comment">//遍历topic队列信息</span></span><br><span class="line">            <span class="keyword">for</span> (QueueData qd : qds) &#123;</span><br><span class="line">                <span class="comment">//是否是写队列</span></span><br><span class="line">                <span class="keyword">if</span> (PermName.isWriteable(qd.getPerm())) &#123;</span><br><span class="line">                    BrokerData brokerData = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//遍历写队列Broker</span></span><br><span class="line">                    <span class="keyword">for</span> (BrokerData bd : route.getBrokerDatas()) &#123;</span><br><span class="line">                        <span class="comment">//根据名称获得读队列对应的Broker</span></span><br><span class="line">                        <span class="keyword">if</span> (bd.getBrokerName().equals(qd.getBrokerName())) &#123;</span><br><span class="line">                        brokerData = bd;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!brokerData.getBrokerAddrs().containsKey(MixAll.MASTER_ID)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//封装TopicPublishInfo写队列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qd.getWriteQueueNums(); i++) &#123;</span><br><span class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, qd.getBrokerName(), i);</span><br><span class="line">                    info.getMessageQueueList().add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        info.setOrderTopic(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//返回TopicPublishInfo对象</span></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3）选择队列"><a href="#3）选择队列" class="headerlink" title="3）选择队列"></a>3）选择队列</h5><ul>
<li>默认不启用Broker故障延迟机制</li>
</ul>
<p><strong><em>代码：TopicPublishInfo#selectOneMessageQueue(lastBrokerName)</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一次选择队列</span></span><br><span class="line">    <span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//sendWhichQueue</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">        <span class="comment">//遍历消息队列集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//sendWhichQueue自增后取模</span></span><br><span class="line">            <span class="keyword">int</span> pos = Math.abs(index++) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//规避上次Broker队列</span></span><br><span class="line">            MessageQueue mq = <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">            <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果以上情况都不满足,返回sendWhichQueue取模后的队列</span></span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：TopicPublishInfo#selectOneMessageQueue()</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次选择队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sendWhichQueue自增</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">    <span class="comment">//对队列大小取模</span></span><br><span class="line">    <span class="keyword">int</span> pos = Math.abs(index) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//返回对应的队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启用Broker故障延迟机制</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Broker故障延迟机制</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//对sendWhichQueue自增</span></span><br><span class="line">            <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">            <span class="comment">//对消息队列轮询获取一个队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">                <span class="comment">//验证该队列是否可用</span></span><br><span class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                    <span class="comment">//可用</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                        <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//从规避的Broker中选择一个可用的Broker</span></span><br><span class="line">            <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">            <span class="comment">//获得Broker的写队列集合</span></span><br><span class="line">            <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//获得一个队列,指定broker和队列ID并返回</span></span><br><span class="line">                <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line">                <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mq.setBrokerName(notBestBroker);</span><br><span class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error occurred when selecting message queue"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/28/rocketMQ/Broker%E6%95%85%E9%9A%9C%E5%BB%B6%E8%BF%9F%E6%9C%BA%E5%88%B6%E6%A0%B8%E5%BF%83%E7%B1%BB.png" alt></p>
<ul>
<li>延迟机制接口规范</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LatencyFaultTolerance</span>&lt;<span class="title">T</span>&gt; </span>&#123;    <span class="comment">//更新失败条目    void updateFaultItem(final T name, final long currentLatency, final long notAvailableDuration);	//判断Broker是否可用    boolean isAvailable(final T name);	//移除Fault条目    void remove(final T name);	//尝试从规避的Broker中选择一个可用的Broker    T pickOneAtLeast();&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>FaultItem：失败条目</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FaultItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">FaultItem</span>&gt; </span>&#123;    <span class="comment">//条目唯一键,这里为brokerName    private final String name;    //本次消息发送延迟    private volatile long currentLatency;    //故障规避开始时间    private volatile long startTimestamp;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>消息失败策略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQFaultStrategy</span> </span>&#123;   <span class="comment">//根据currentLatency本地消息发送延迟,从latencyMax尾部向前找到第一个比currentLatency小的索引,如果没有找到,返回0	private long[] latencyMax = &#123;50L, 100L, 550L, 1000L, 2000L, 3000L, 15000L&#125;;    //根据这个索引从notAvailableDuration取出对应的时间,在该时长内,Broker设置为不可用	private long[] notAvailableDuration = &#123;0L, 0L, 30000L, 60000L, 120000L, 180000L, 600000L&#125;;&#125;</span></span><br></pre></td></tr></table></figure>

<p><u><strong><em>原理分析</em></strong></u></p>
<p><strong><em>代码：DefaultMQProducerImpl#sendDefaultImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendResult = <span class="keyword">this</span>.sendKernelImpl(msg,                                  mq,                                  communicationMode,                                  sendCallback,                                  topicPublishInfo,                                  timeout - costTime);endTimestamp = System.currentTimeMillis();<span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>如果上述发送过程出现异常，则调用<code>DefaultMQProducerImpl#updateFaultItem</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;    <span class="comment">//参数一：broker名称    //参数二:本次消息发送延迟时间    //参数三:是否隔离    this.mqFaultStrategy.updateFaultItem(brokerName, currentLatency, isolation);&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：MQFaultStrategy#updateFaultItem</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;        <span class="comment">//计算broker规避的时长        long duration = computeNotAvailableDuration(isolation ? 30000 : currentLatency);        //更新该FaultItem规避时长        this.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：MQFaultStrategy#computeNotAvailableDuration</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeNotAvailableDuration</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> currentLatency)</span> </span>&#123;    <span class="comment">//遍历latencyMax    for (int i = latencyMax.length - 1; i &gt;= 0; i--) &#123;        //找到第一个比currentLatency的latencyMax值        if (currentLatency &gt;= latencyMax[i])            return this.notAvailableDuration[i];    &#125;    //没有找到则返回0    return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：LatencyFaultToleranceImpl#updateFaultItem</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">final</span> <span class="keyword">long</span> notAvailableDuration)</span> </span>&#123;    <span class="comment">//获得原FaultItem    FaultItem old = this.faultItemTable.get(name);    //为空新建faultItem对象,设置规避时长和开始时间    if (null == old) &#123;        final FaultItem faultItem = new FaultItem(name);        faultItem.setCurrentLatency(currentLatency);        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);        old = this.faultItemTable.putIfAbsent(name, faultItem);        if (old != null) &#123;            old.setCurrentLatency(currentLatency);            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);        &#125;    &#125; else &#123;        //更新规避时长和开始时间        old.setCurrentLatency(currentLatency);        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4）发送消息"><a href="#4）发送消息" class="headerlink" title="4）发送消息"></a>4）发送消息</h5><p>消息发送API核心入口<strong><em>DefaultMQProducerImpl#sendKernelImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(    <span class="keyword">final</span> Message msg,	//待发送消息    <span class="keyword">final</span> MessageQueue mq,	//消息发送队列    <span class="keyword">final</span> CommunicationMode communicationMode,		//消息发送内模式    <span class="keyword">final</span> SendCallback sendCallback,	pp	//异步消息回调函数    <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,	//主题路由信息    <span class="keyword">final</span> <span class="keyword">long</span> timeout	//超时时间    )</span></span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMQProducerImpl#sendKernelImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得broker网络地址信息String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());if (null == brokerAddr) &#123;    //没有找到从NameServer更新broker网络地址信息    tryToFindTopicPublishInfo(mq.getTopic());    brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为消息分类唯一ID</span></span><br><span class="line"><span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">    MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> topicWithNamespace = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.mQClientFactory.getClientConfig().getNamespace()) &#123;</span><br><span class="line">    msg.setInstanceId(<span class="keyword">this</span>.mQClientFactory.getClientConfig().getNamespace());</span><br><span class="line">    topicWithNamespace = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消息大小超过4K,启用消息压缩</span></span><br><span class="line"><span class="keyword">int</span> sysFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> msgBodyCompressed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">    msgBodyCompressed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是事务消息,设置消息标记MessageSysFlag.TRANSACTION_PREPARED_TYPE</span></span><br><span class="line"><span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"><span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果注册了消息发送钩子函数,在执行消息发送前的增强逻辑</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">    context = <span class="keyword">new</span> SendMessageContext();</span><br><span class="line">    context.setProducer(<span class="keyword">this</span>);</span><br><span class="line">    context.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    context.setCommunicationMode(communicationMode);</span><br><span class="line">    context.setBornHost(<span class="keyword">this</span>.defaultMQProducer.getClientIP());</span><br><span class="line">    context.setBrokerAddr(brokerAddr);</span><br><span class="line">    context.setMessage(msg);</span><br><span class="line">    context.setMq(mq);</span><br><span class="line">    context.setNamespace(<span class="keyword">this</span>.defaultMQProducer.getNamespace());</span><br><span class="line">    String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">    <span class="keyword">if</span> (isTrans != <span class="keyword">null</span> &amp;&amp; isTrans.equals(<span class="string">"true"</span>)) &#123;</span><br><span class="line">        context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg.getProperty(<span class="string">"__STARTDELIVERTIME"</span>) != <span class="keyword">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：SendMessageHook</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SendMessageHook</span> </span>&#123;    <span class="function">String <span class="title">hookName</span><span class="params">()</span></span>;    <span class="function"><span class="keyword">void</span> <span class="title">sendMessageBefore</span><span class="params">(<span class="keyword">final</span> SendMessageContext context)</span></span>;    <span class="function"><span class="keyword">void</span> <span class="title">sendMessageAfter</span><span class="params">(<span class="keyword">final</span> SendMessageContext context)</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMQProducerImpl#sendKernelImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建消息发送请求包</span></span><br><span class="line">SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line"><span class="comment">//生产者组</span></span><br><span class="line">requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line"><span class="comment">//主题</span></span><br><span class="line">requestHeader.setTopic(msg.getTopic());</span><br><span class="line"><span class="comment">//默认创建主题Key</span></span><br><span class="line">requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line"><span class="comment">//该主题在单个Broker默认队列树</span></span><br><span class="line">requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line"><span class="comment">//队列ID</span></span><br><span class="line">requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line"><span class="comment">//消息系统标记</span></span><br><span class="line">requestHeader.setSysFlag(sysFlag);</span><br><span class="line"><span class="comment">//消息发送时间</span></span><br><span class="line">requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line"><span class="comment">//消息标记</span></span><br><span class="line">requestHeader.setFlag(msg.getFlag());</span><br><span class="line"><span class="comment">//消息扩展信息</span></span><br><span class="line">requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"><span class="comment">//消息重试次数</span></span><br><span class="line">requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line"><span class="comment">//是否是批量消息等</span></span><br><span class="line">requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line"><span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">    String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">    <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">    <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ASYNC:		<span class="comment">//异步发送</span></span><br><span class="line">    Message tmpMessage = msg;</span><br><span class="line">    <span class="keyword">boolean</span> messageCloned = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (msgBodyCompressed) &#123;</span><br><span class="line">        <span class="comment">//If msg body was compressed, msgbody should be reset using prevBody.</span></span><br><span class="line">        <span class="comment">//Clone new message using commpressed message body and recover origin massage.</span></span><br><span class="line">        <span class="comment">//Fix bug:https://github.com/apache/rocketmq-externals/issues/66</span></span><br><span class="line">        tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">        messageCloned = <span class="keyword">true</span>;</span><br><span class="line">        msg.setBody(prevBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicWithNamespace) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!messageCloned) &#123;</span><br><span class="line">            tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">            messageCloned = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), </span><br><span class="line">                                                    <span class="keyword">this</span>.defaultMQProducer.getNamespace()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> costTimeAsync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">		<span class="keyword">if</span> (timeout &lt; costTimeAsync) &#123;</span><br><span class="line">		    <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">        			brokerAddr,</span><br><span class="line">        			mq.getBrokerName(),</span><br><span class="line">        			tmpMessage,</span><br><span class="line">        			requestHeader,</span><br><span class="line">        			timeout - costTimeAsync,</span><br><span class="line">        			communicationMode,</span><br><span class="line">        			sendCallback,</span><br><span class="line">        			topicPublishInfo,</span><br><span class="line">        			<span class="keyword">this</span>.mQClientFactory,</span><br><span class="line">        			<span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</span><br><span class="line">        			context,</span><br><span class="line">        			<span class="keyword">this</span>);</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ONEWAY:</span><br><span class="line"><span class="keyword">case</span> SYNC:		<span class="comment">//同步发送</span></span><br><span class="line">    <span class="keyword">long</span> costTimeSync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; costTimeSync) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">            brokerAddr,</span><br><span class="line">            mq.getBrokerName(),</span><br><span class="line">            msg,</span><br><span class="line">            requestHeader,</span><br><span class="line">            timeout - costTimeSync,</span><br><span class="line">            communicationMode,</span><br><span class="line">            context,</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果注册了钩子函数,则发送完毕后执行钩子函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">    context.setSendResult(sendResult);</span><br><span class="line">    <span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-批量消息发送"><a href="#2-3-4-批量消息发送" class="headerlink" title="2.3.4 批量消息发送"></a>2.3.4 批量消息发送</h4><p><img src="/2021/07/28/rocketMQ/%E5%8F%91%E9%80%81%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF.png" alt></p>
<p>批量消息发送是将同一个主题的多条消息一起打包发送到消息服务端，减少网络调用次数，提高网络传输效率。当然，并不是在同一批次中发送的消息数量越多越好，其判断依据是单条消息的长度，如果单条消息内容比较长，则打包多条消息发送会影响其他线程发送消息的响应时间，并且单批次消息总长度不能超过DefaultMQProducer#maxMessageSize。</p>
<p>批量消息发送要解决的问题是如何将这些消息编码以便服务端能够正确解码出每条消息的消息内容。</p>
<p><strong><em>代码：DefaultMQProducer#send</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Collection&lt;Message&gt; msgs)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//压缩消息集合成一条消息,然后发送出去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.send(batch(msgs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMQProducer#batch</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MessageBatch <span class="title">batch</span><span class="params">(Collection&lt;Message&gt; msgs)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    MessageBatch msgBatch;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将集合消息封装到MessageBatch</span></span><br><span class="line">        msgBatch = MessageBatch.generateFromList(msgs);</span><br><span class="line">        <span class="comment">//遍历消息集合,检查消息合法性,设置消息ID,设置Topic</span></span><br><span class="line">        <span class="keyword">for</span> (Message message : msgBatch) &#123;</span><br><span class="line">            Validators.checkMessage(message, <span class="keyword">this</span>);</span><br><span class="line">            MessageClientIDSetter.setUniqID(message);</span><br><span class="line">            message.setTopic(withNamespace(message.getTopic()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//压缩消息,设置消息body</span></span><br><span class="line">        msgBatch.setBody(msgBatch.encode());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"Failed to initiate the MessageBatch"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置msgBatch的topic</span></span><br><span class="line">    msgBatch.setTopic(withNamespace(msgBatch.getTopic()));</span><br><span class="line">    <span class="keyword">return</span> msgBatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-消息存储"><a href="#2-4-消息存储" class="headerlink" title="2.4 消息存储"></a>2.4 消息存储</h3><h4 id="2-4-1-消息存储核心类"><a href="#2-4-1-消息存储核心类" class="headerlink" title="2.4.1 消息存储核心类"></a>2.4.1 消息存储核心类</h4><p><img src="/2021/07/28/rocketMQ/DefaultMessageStore.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageStoreConfig messageStoreConfig;	<span class="comment">//消息配置属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CommitLog commitLog;		<span class="comment">//CommitLog文件存储的实现类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, ConcurrentMap&lt;Integer<span class="comment">/* queueId */</span>, ConsumeQueue&gt;&gt; consumeQueueTable;	<span class="comment">//消息队列存储缓存表,按照消息主题分组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FlushConsumeQueueService flushConsumeQueueService;	<span class="comment">//消息队列文件刷盘线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CleanCommitLogService cleanCommitLogService;	<span class="comment">//清除CommitLog文件服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CleanConsumeQueueService cleanConsumeQueueService;	<span class="comment">//清除ConsumerQueue队列文件服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IndexService indexService;	<span class="comment">//索引实现类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AllocateMappedFileService allocateMappedFileService;	<span class="comment">//MappedFile分配服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReputMessageService reputMessageService;<span class="comment">//CommitLog消息分发,根据CommitLog文件构建ConsumerQueue、IndexFile文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HAService haService;	<span class="comment">//存储HA机制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduleMessageService scheduleMessageService;	<span class="comment">//消息服务调度线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StoreStatsService storeStatsService;	<span class="comment">//消息存储服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransientStorePool transientStorePool;	<span class="comment">//消息堆外内存缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BrokerStatsManager brokerStatsManager;	<span class="comment">//Broker状态管理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageArrivingListener messageArrivingListener;	<span class="comment">//消息拉取长轮询模式消息达到监听器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BrokerConfig brokerConfig;	<span class="comment">//Broker配置类</span></span><br><span class="line"><span class="keyword">private</span> StoreCheckpoint storeCheckpoint;	<span class="comment">//文件刷盘监测点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;CommitLogDispatcher&gt; dispatcherList;	<span class="comment">//CommitLog文件转发请求</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-消息存储流程"><a href="#2-4-2-消息存储流程" class="headerlink" title="2.4.2 消息存储流程"></a>2.4.2 消息存储流程</h4><p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%B5%81%E7%A8%8B.png" alt></p>
<p><strong><em>消息存储入口：DefaultMessageStore#putMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断Broker角色如果是从节点,则无需写入</span></span><br><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE == <span class="keyword">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">        <span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> ((value % <span class="number">50000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">"message store is slave mode, so putMessage is forbidden "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前写入状态如果是正在写入,则不能继续</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.runningFlags.isWriteable()) &#123;</span><br><span class="line">        <span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.printTimes.set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断消息主题长度是否超过最大限制</span></span><br><span class="line"><span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</span><br><span class="line">    log.warn(<span class="string">"putMessage message topic length too long "</span> + msg.getTopic().length());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断消息属性长度是否超过限制</span></span><br><span class="line"><span class="keyword">if</span> (msg.getPropertiesString() != <span class="keyword">null</span> &amp;&amp; msg.getPropertiesString().length() &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">    log.warn(<span class="string">"putMessage message properties length too long "</span> + msg.getPropertiesString().length());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断系统PageCache缓存去是否占用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isOSPageCacheBusy()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息写入CommitLog文件</span></span><br><span class="line">PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：CommitLog#putMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录消息存储时间msg.setStoreTimestamp(beginLockTimestamp);//判断如果mappedFile如果为空或者已满,创建新的mappedFile文件if (null == mappedFile || mappedFile.isFull()) &#123;    mappedFile = this.mappedFileQueue.getLastMappedFile(0); &#125;//如果创建失败,直接返回if (null == mappedFile) &#123;    log.error("create mapped file1 error, topic: " + msg.getTopic() + " clientAddr: " + msg.getBornHostString());    beginTimeInLock = 0;    return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null);&#125;//写入消息到mappedFile中result = mappedFile.appendMessage(msg, this.appendMessageCallback);</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：MappedFile#appendMessagesInner</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得文件的写入指针int currentPos = this.wrotePosition.get();//如果指针大于文件大小则直接返回if (currentPos &lt; this.fileSize) &#123;    //通过writeBuffer.slice()创建一个与MappedFile共享的内存区,并设置position为当前指针    ByteBuffer byteBuffer = writeBuffer != null ? writeBuffer.slice() : this.mappedByteBuffer.slice();    byteBuffer.position(currentPos);    AppendMessageResult result = null;    if (messageExt instanceof MessageExtBrokerInner) &#123;       	//通过回调方法写入        result = cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, (MessageExtBrokerInner) messageExt);    &#125; else if (messageExt instanceof MessageExtBatch) &#123;        result = cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, (MessageExtBatch) messageExt);    &#125; else &#123;        return new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);    &#125;    this.wrotePosition.addAndGet(result.getWroteBytes());    this.storeTimestamp = result.getStoreTimestamp();    return result;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：CommitLog#doAppend</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件写入位置long wroteOffset = fileFromOffset + byteBuffer.position();//设置消息IDthis.resetByteBuffer(hostHolder, 8);String msgId = MessageDecoder.createMessageId(this.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);//获得该消息在消息队列中的偏移量keyBuilder.setLength(0);keyBuilder.append(msgInner.getTopic());keyBuilder.append('-');keyBuilder.append(msgInner.getQueueId());String key = keyBuilder.toString();Long queueOffset = CommitLog.this.topicQueueTable.get(key);if (null == queueOffset) &#123;    queueOffset = 0L;    CommitLog.this.topicQueueTable.put(key, queueOffset);&#125;//获得消息属性长度final byte[] propertiesData =msgInner.getPropertiesString() == null ? null : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);final int propertiesLength = propertiesData == null ? 0 : propertiesData.length;if (propertiesLength &gt; Short.MAX_VALUE) &#123;    log.warn("putMessage message properties length too long. length=&#123;&#125;", propertiesData.length);    return new AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);&#125;//获得消息主题大小final byte[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);final int topicLength = topicData.length;//获得消息体大小final int bodyLength = msgInner.getBody() == null ? 0 : msgInner.getBody().length;//计算消息总长度final int msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：CommitLog#calMsgLength</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calMsgLength</span><span class="params">(<span class="keyword">int</span> bodyLength, <span class="keyword">int</span> topicLength, <span class="keyword">int</span> propertiesLength)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> msgLen = <span class="number">4</span> <span class="comment">//TOTALSIZE</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//MAGICCODE  </span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//BODYCRC</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//QUEUEID</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//FLAG</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//QUEUEOFFSET</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//PHYSICALOFFSET</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//SYSFLAG</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//BORNTIMESTAMP</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//BORNHOST</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//STORETIMESTAMP</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//STOREHOSTADDRESS</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//RECONSUMETIMES</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//Prepared Transaction Offset</span></span><br><span class="line">        + <span class="number">4</span> + (bodyLength &gt; <span class="number">0</span> ? bodyLength : <span class="number">0</span>) <span class="comment">//BODY</span></span><br><span class="line">        + <span class="number">1</span> + topicLength <span class="comment">//TOPIC</span></span><br><span class="line">        + <span class="number">2</span> + (propertiesLength &gt; <span class="number">0</span> ? propertiesLength : <span class="number">0</span>) <span class="comment">//propertiesLength</span></span><br><span class="line">        + <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> msgLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：CommitLog#doAppend</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息长度不能超过4M</span></span><br><span class="line"><span class="keyword">if</span> (msgLen &gt; <span class="keyword">this</span>.maxMessageSize) &#123;</span><br><span class="line">    CommitLog.log.warn(<span class="string">"message size exceeded, msg total size: "</span> + msgLen + <span class="string">", msg body size: "</span> + bodyLength</span><br><span class="line">        + <span class="string">", maxMessageSize: "</span> + <span class="keyword">this</span>.maxMessageSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息是如果没有足够的存储空间则新创建CommitLog文件</span></span><br><span class="line"><span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</span><br><span class="line">    <span class="keyword">this</span>.resetByteBuffer(<span class="keyword">this</span>.msgStoreItemMemory, maxBlank);</span><br><span class="line">    <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">    <span class="keyword">this</span>.msgStoreItemMemory.putInt(maxBlank);</span><br><span class="line">    <span class="comment">// 2 MAGICCODE</span></span><br><span class="line">    <span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</span><br><span class="line">    <span class="comment">// 3 The remaining space may be any value</span></span><br><span class="line">    <span class="comment">// Here the length of the specially set maxBlank</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line">    byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</span><br><span class="line">        queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息存储到ByteBuffer中,返回AppendMessageResult</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line"><span class="comment">// Write messages to the queue buffer</span></span><br><span class="line">byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, msgLen);</span><br><span class="line">AppendMessageResult result = <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, </span><br><span class="line">                                                     msgLen, msgId,msgInner.getStoreTimestamp(), </span><br><span class="line">                                                     queueOffset, </span><br><span class="line">                                                     CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() </span><br><span class="line">                                                     -beginTimeMills);</span><br><span class="line"><span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">        <span class="comment">//更新消息队列偏移量</span></span><br><span class="line">        CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, ++queueOffset);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：CommitLog#putMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放锁putMessageLock.unlock();//刷盘handleDiskFlush(result, putMessageResult, msg);//执行HA主从同步handleHA(result, putMessageResult, msg);</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-存储文件"><a href="#2-4-3-存储文件" class="headerlink" title="2.4.3 存储文件"></a>2.4.3 存储文件</h4><p><img src="/2021/07/28/rocketMQ/%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6.png" alt></p>
<ul>
<li>commitLog：消息存储目录</li>
<li>config：运行期间一些配置信息</li>
<li>consumerqueue：消息消费队列存储目录</li>
<li>index：消息索引文件存储目录</li>
<li>abort：如果存在改文件寿命Broker非正常关闭</li>
<li>checkpoint：文件检查点，存储CommitLog文件最后一次刷盘时间戳、consumerquueue最后一次刷盘时间，index索引文件最后一次刷盘时间戳。</li>
</ul>
<h4 id="2-4-4-存储文件内存映射"><a href="#2-4-4-存储文件内存映射" class="headerlink" title="2.4.4 存储文件内存映射"></a>2.4.4 存储文件内存映射</h4><p>RocketMQ通过使用内存映射文件提高IO访问性能，无论是CommitLog、ConsumerQueue还是IndexFile，单个文件都被设计为固定长度，如果一个文件写满以后再创建一个新文件，文件名就为该文件第一条消息对应的全局物理偏移量。</p>
<h5 id="1）MappedFileQueue"><a href="#1）MappedFileQueue" class="headerlink" title="1）MappedFileQueue"></a>1）MappedFileQueue</h5><p><img src="/2021/07/28/rocketMQ/MappedFileQueue.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String storePath;	<span class="comment">//存储目录int mappedFileSize;	// 单个文件大小CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles;	//MappedFile文件集合AllocateMappedFileService allocateMappedFileService;	//创建MapFile服务类long flushedWhere = 0;		//当前刷盘指针long committedWhere = 0;	//当前数据提交指针,内存中ByteBuffer当前的写指针,该值大于等于flushWhere</span></span><br></pre></td></tr></table></figure>

<ul>
<li>根据存储时间查询MappedFile</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">getMappedFileByTime</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timestamp)</span> </span>&#123;    Object[] mfs = <span class="keyword">this</span>.copyMappedFiles(<span class="number">0</span>);	    <span class="keyword">if</span> (<span class="keyword">null</span> == mfs)        <span class="keyword">return</span> <span class="keyword">null</span>;	<span class="comment">//遍历MappedFile文件数组    for (int i = 0; i &lt; mfs.length; i++) &#123;        MappedFile mappedFile = (MappedFile) mfs[i];        //MappedFile文件的最后修改时间大于指定时间戳则返回该文件        if (mappedFile.getLastModifiedTimestamp() &gt;= timestamp) &#123;            return mappedFile;        &#125;    &#125;    return (MappedFile) mfs[mfs.length - 1];&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>根据消息偏移量offset查找MappedFile</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">findMappedFileByOffset</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">boolean</span> returnFirstOnNotFound)</span> </span>&#123;    <span class="keyword">try</span> &#123;        <span class="comment">//获得第一个MappedFile文件        MappedFile firstMappedFile = this.getFirstMappedFile();        //获得最后一个MappedFile文件        MappedFile lastMappedFile = this.getLastMappedFile();        //第一个文件和最后一个文件均不为空,则进行处理        if (firstMappedFile != null &amp;&amp; lastMappedFile != null) &#123;            if (offset &lt; firstMappedFile.getFileFromOffset() ||                 offset &gt;= lastMappedFile.getFileFromOffset() + this.mappedFileSize) &#123;            &#125; else &#123;                //获得文件索引                int index = (int) ((offset / this.mappedFileSize)                                    - (firstMappedFile.getFileFromOffset() / this.mappedFileSize));                MappedFile targetFile = null;                try &#123;                    //根据索引返回目标文件                    targetFile = this.mappedFiles.get(index);                &#125; catch (Exception ignored) &#123;                &#125;                if (targetFile != null &amp;&amp; offset &gt;= targetFile.getFileFromOffset()                    &amp;&amp; offset &lt; targetFile.getFileFromOffset() + this.mappedFileSize) &#123;                    return targetFile;                &#125;                for (MappedFile tmpMappedFile : this.mappedFiles) &#123;                    if (offset &gt;= tmpMappedFile.getFileFromOffset()                        &amp;&amp; offset &lt; tmpMappedFile.getFileFromOffset() + this.mappedFileSize) &#123;                        return tmpMappedFile;                    &#125;                &#125;            &#125;            if (returnFirstOnNotFound) &#123;                return firstMappedFile;            &#125;        &#125;    &#125; catch (Exception e) &#123;        log.error("findMappedFileByOffset Exception", e);    &#125;    return null;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取存储文件最小偏移量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMinOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.mappedFiles.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.mappedFiles.get(<span class="number">0</span>).getFileFromOffset();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="comment">//continue;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"getMinOffset has exception."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取存储文件最大偏移量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MappedFile mappedFile = getLastMappedFile();</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mappedFile.getFileFromOffset() + mappedFile.getReadPosition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回存储文件当前写指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxWrotePosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MappedFile mappedFile = getLastMappedFile();</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mappedFile.getFileFromOffset() + mappedFile.getWrotePosition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）MappedFile"><a href="#2）MappedFile" class="headerlink" title="2）MappedFile"></a>2）MappedFile</h5><p><img src="/2021/07/28/rocketMQ/MappedFile.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_PAGE_SIZE = <span class="number">1024</span> * <span class="number">4</span>;		<span class="comment">//操作系统每页大小,默认4KAtomicLong TOTAL_MAPPED_VIRTUAL_MEMORY = new AtomicLong(0);	//当前JVM实例中MappedFile虚拟内存AtomicInteger TOTAL_MAPPED_FILES = new AtomicInteger(0);	//当前JVM实例中MappedFile对象个数AtomicInteger wrotePosition = new AtomicInteger(0);	//当前文件的写指针AtomicInteger committedPosition = new AtomicInteger(0);	//当前文件的提交指针AtomicInteger flushedPosition = new AtomicInteger(0);	//刷写到磁盘指针int fileSize;	//文件大小FileChannel fileChannel;	//文件通道	ByteBuffer writeBuffer = null;	//堆外内存ByteBufferTransientStorePool transientStorePool = null;	//堆外内存池String fileName;	//文件名称long fileFromOffset;	//该文件的处理偏移量File file;	//物理文件MappedByteBuffer mappedByteBuffer;	//物理文件对应的内存映射Buffervolatile long storeTimestamp = 0;	//文件最后一次内容写入时间boolean firstCreateInQueue = false;	//是否是MappedFileQueue队列中第一个文件</span></span><br></pre></td></tr></table></figure>

<p><strong><em>MappedFile初始化</em></strong></p>
<ul>
<li>未开启<code>transientStorePoolEnable</code>。<code>transientStorePoolEnable=true</code>为<code>true</code>表示数据先存储到堆外内存，然后通过<code>Commit</code>线程将数据提交到内存映射Buffer中，再通过<code>Flush</code>线程将内存映射<code>Buffer</code>中数据持久化磁盘。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    <span class="keyword">this</span>.fileSize = fileSize;</span><br><span class="line">    <span class="keyword">this</span>.file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">    <span class="keyword">this</span>.fileFromOffset = Long.parseLong(<span class="keyword">this</span>.file.getName());</span><br><span class="line">    <span class="keyword">boolean</span> ok = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">    ensureDirOK(<span class="keyword">this</span>.file.getParent());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.file, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">        <span class="keyword">this</span>.mappedByteBuffer = <span class="keyword">this</span>.fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, fileSize);</span><br><span class="line">        TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);</span><br><span class="line">        TOTAL_MAPPED_FILES.incrementAndGet();</span><br><span class="line">        ok = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(<span class="string">"create file channel "</span> + <span class="keyword">this</span>.fileName + <span class="string">" Failed. "</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">"map file "</span> + <span class="keyword">this</span>.fileName + <span class="string">" Failed. "</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ok &amp;&amp; <span class="keyword">this</span>.fileChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.fileChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启<code>transientStorePoolEnable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> TransientStorePool transientStorePool)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    init(fileName, fileSize);</span><br><span class="line">    <span class="keyword">this</span>.writeBuffer = transientStorePool.borrowBuffer();	<span class="comment">//初始化writeBuffer</span></span><br><span class="line">    <span class="keyword">this</span>.transientStorePool = transientStorePool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>MappedFile提交</em></strong></p>
<p>提交数据到FileChannel，commitLeastPages为本次提交最小的页数，如果待提交数据不满commitLeastPages，则不执行本次提交操作。如果writeBuffer如果为空，直接返回writePosition指针，无需执行commit操作，表名commit操作主体是writeBuffer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (writeBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//no need to commit data to file channel, so just regard wrotePosition as committedPosition.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否满足提交条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToCommit(commitLeastPages)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</span><br><span class="line">            commit0(commitLeastPages);</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"in commit, hold failed, commit offset = "</span> + <span class="keyword">this</span>.committedPosition.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有数据提交后,清空缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.transientStorePool != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.fileSize == <span class="keyword">this</span>.committedPosition.get()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.transientStorePool.returnBuffer(writeBuffer);</span><br><span class="line">        <span class="keyword">this</span>.writeBuffer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>MappedFile#isAbleToCommit</em></strong></p>
<p>判断是否执行commit操作，如果文件已满返回true；如果commitLeastpages大于0，则比较writePosition与上一次提交的指针commitPosition的差值，除以OS_PAGE_SIZE得到当前脏页的数量，如果大于commitLeastPages则返回true，如果commitLeastpages小于0表示只要存在脏页就提交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAbleToCommit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已经刷盘指针</span></span><br><span class="line">    <span class="keyword">int</span> flush = <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">    <span class="comment">//文件写指针</span></span><br><span class="line">    <span class="keyword">int</span> write = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line">	<span class="comment">//写满刷盘</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commitLeastPages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//文件内容达到commitLeastPages页数,则刷盘</span></span><br><span class="line">        <span class="keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= commitLeastPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> write &gt; flush;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>MappedFile#commit0</em></strong></p>
<p>具体提交的实现，首先创建WriteBuffer区共享缓存区，然后将新创建的position回退到上一次提交的位置（commitPosition），设置limit为wrotePosition（当前最大有效数据指针），然后把commitPosition到wrotePosition的数据写入到FileChannel中，然后更新committedPosition指针为wrotePosition。commit的作用就是将MappedFile的writeBuffer中数据提交到文件通道FileChannel中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commit0</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//写指针</span></span><br><span class="line">    <span class="keyword">int</span> writePos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line">    <span class="comment">//上次提交指针</span></span><br><span class="line">    <span class="keyword">int</span> lastCommittedPosition = <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writePos - <span class="keyword">this</span>.committedPosition.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//复制共享内存区域</span></span><br><span class="line">            ByteBuffer byteBuffer = writeBuffer.slice();</span><br><span class="line">            <span class="comment">//设置提交位置是上次提交位置</span></span><br><span class="line">            byteBuffer.position(lastCommittedPosition);</span><br><span class="line">            <span class="comment">//最大提交数量</span></span><br><span class="line">            byteBuffer.limit(writePos);</span><br><span class="line">            <span class="comment">//设置fileChannel位置为上次提交位置</span></span><br><span class="line">            <span class="keyword">this</span>.fileChannel.position(lastCommittedPosition);</span><br><span class="line">            <span class="comment">//将lastCommittedPosition到writePos的数据复制到FileChannel中</span></span><br><span class="line">            <span class="keyword">this</span>.fileChannel.write(byteBuffer);</span><br><span class="line">            <span class="comment">//重置提交位置</span></span><br><span class="line">            <span class="keyword">this</span>.committedPosition.set(writePos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error occurred when commit data to FileChannel."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>MappedFile#flush</em></strong></p>
<p>刷写磁盘，直接调用MappedByteBuffer或fileChannel的force方法将内存中的数据持久化到磁盘，那么flushedPosition应该等于MappedByteBuffer中的写指针；如果writeBuffer不为空，则flushPosition应该等于上一次的commit指针；因为上一次提交的数据就是进入到MappedByteBuffer中的数据；如果writeBuffer为空，数据时直接进入到MappedByteBuffer，wrotePosition代表的是MappedByteBuffer中的指针，故设置flushPosition为wrotePosition。</p>
<p><img src="/2021/07/28/rocketMQ/flush.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据达到刷盘条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToFlush(flushLeastPages)) &#123;</span><br><span class="line">        <span class="comment">//加锁，同步刷盘</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</span><br><span class="line">            <span class="comment">//获得读指针</span></span><br><span class="line">            <span class="keyword">int</span> value = getReadPosition();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//数据从writeBuffer提交数据到fileChannel再刷新到磁盘</span></span><br><span class="line">                <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> || <span class="keyword">this</span>.fileChannel.position() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.fileChannel.force(<span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//从mmap刷新数据到磁盘</span></span><br><span class="line">                    <span class="keyword">this</span>.mappedByteBuffer.force();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"Error occurred when force data to disk."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//更新刷盘位置</span></span><br><span class="line">            <span class="keyword">this</span>.flushedPosition.set(value);</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"in flush, hold failed, flush offset = "</span> + <span class="keyword">this</span>.flushedPosition.get());</span><br><span class="line">            <span class="keyword">this</span>.flushedPosition.set(getReadPosition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getFlushedPosition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>MappedFile#getReadPosition</em></strong></p>
<p>获取当前文件最大可读指针。如果writeBuffer为空，则直接返回当前的写指针；如果writeBuffer不为空，则返回上一次提交的指针。在MappedFile设置中,只有提交了的数据（写入到MappedByteBuffer或FileChannel中的数据）才是安全的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getReadPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果writeBuffer为空,刷盘的位置就是应该等于上次commit的位置,如果为空则为mmap的写指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writeBuffer == <span class="keyword">null</span> ? <span class="keyword">this</span>.wrotePosition.get() : <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>MappedFile#selectMappedBuffer</em></strong></p>
<p>查找pos到当前最大可读之间的数据，由于在整个写入期间都未曾改MappedByteBuffer的指针，如果mappedByteBuffer.slice()方法返回的共享缓存区空间为整个MappedFile，然后通过设置ByteBuffer的position为待查找的值，读取字节长度当前可读最大长度，最终返回的ByteBuffer的limit为size。整个共享缓存区的容量为（MappedFile#fileSize-pos）。故在操作SelectMappedBufferResult不能对包含在里面的ByteBuffer调用filp方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SelectMappedBufferResult <span class="title">selectMappedBuffer</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;    <span class="comment">//获得最大可读指针    int readPosition = getReadPosition();    //pos小于最大可读指针,并且大于0    if (pos &lt; readPosition &amp;&amp; pos &gt;= 0) &#123;        if (this.hold()) &#123;            //复制mappedByteBuffer读共享区            ByteBuffer byteBuffer = this.mappedByteBuffer.slice();            //设置读指针位置            byteBuffer.position(pos);            //获得可读范围            int size = readPosition - pos;            //设置最大刻度范围            ByteBuffer byteBufferNew = byteBuffer.slice();            byteBufferNew.limit(size);            return new SelectMappedBufferResult(this.fileFromOffset + pos, byteBufferNew, size, this);        &#125;    &#125;    return null;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>MappedFile#shutdown</em></strong></p>
<p>MappedFile文件销毁的实现方法为public boolean destory(long intervalForcibly)，intervalForcibly表示拒绝被销毁的最大存活时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> intervalForcibly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.available) &#123;</span><br><span class="line">        <span class="comment">//关闭MapedFile</span></span><br><span class="line">        <span class="keyword">this</span>.available = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//设置当前关闭时间戳</span></span><br><span class="line">        <span class="keyword">this</span>.firstShutdownTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">this</span>.release();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getRefCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((System.currentTimeMillis() - <span class="keyword">this</span>.firstShutdownTimestamp) &gt;= intervalForcibly) &#123;</span><br><span class="line">            <span class="keyword">this</span>.refCount.set(-<span class="number">1000</span> - <span class="keyword">this</span>.getRefCount());</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3）TransientStorePool"><a href="#3）TransientStorePool" class="headerlink" title="3）TransientStorePool"></a>3）TransientStorePool</h5><p>短暂的存储池。RocketMQ单独创建一个MappedByteBuffer内存缓存池，用来临时存储数据，数据先写入该内存映射中，然后由commit线程定时将数据从该内存复制到与目标物理文件对应的内存映射中。RocketMQ引入该机制主要的原因是提供一种内存锁定，将当前堆外内存一直锁定在内存中，避免被进程将内存交换到磁盘。</p>
<p><img src="/2021/07/28/rocketMQ/TransientStorePool.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> poolSize;		<span class="comment">//availableBuffers个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fileSize;		<span class="comment">//每隔ByteBuffer大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ByteBuffer&gt; availableBuffers;	<span class="comment">//ByteBuffer容器。双端队列</span></span><br></pre></td></tr></table></figure>

<p><strong><em>初始化</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建poolSize个堆外内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(fileSize);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> address = ((DirectBuffer) byteBuffer).address();</span><br><span class="line">        Pointer pointer = <span class="keyword">new</span> Pointer(address);</span><br><span class="line">        <span class="comment">//使用com.sun.jna.Library类库将该批内存锁定,避免被置换到交换区,提高存储性能</span></span><br><span class="line">        LibC.INSTANCE.mlock(pointer, <span class="keyword">new</span> NativeLong(fileSize));</span><br><span class="line"></span><br><span class="line">        availableBuffers.offer(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-5-实时更新消息消费队列与索引文件"><a href="#2-4-5-实时更新消息消费队列与索引文件" class="headerlink" title="2.4.5 实时更新消息消费队列与索引文件"></a>2.4.5 实时更新消息消费队列与索引文件</h4><p>消息消费队文件、消息属性索引文件都是基于CommitLog文件构建的，当消息生产者提交的消息存储在CommitLog文件中，ConsumerQueue、IndexFile需要及时更新，否则消息无法及时被消费，根据消息属性查找消息也会出现较大延迟。RocketMQ通过开启一个线程ReputMessageService来准实时转发CommitLog文件更新事件，相应的任务处理器根据转发的消息及时更新ConsumerQueue、IndexFile文件。</p>
<p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt></p>
<p><img src="/2021/07/28/rocketMQ/%E6%9E%84%E5%BB%BA%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97%E5%92%8C%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png" alt></p>
<p><strong><em>代码：DefaultMessageStore：start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置CommitLog内存中最大偏移量</span></span><br><span class="line"><span class="keyword">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line"><span class="keyword">this</span>.reputMessageService.start();</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore：run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">	<span class="comment">//每隔1毫秒就继续尝试推送消息到消息消费队列和索引文件</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.doReput();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore：deReput</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从result中循环遍历消息,一次读一条,创建DispatherRequest对象。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> readSize = <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">	DispatchRequest dispatchRequest =                               DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">int</span> size = dispatchRequest.getBufferSize() == -<span class="number">1</span> ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	        DefaultMessageStore.<span class="keyword">this</span>.doDispatch(dispatchRequest);</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>DispatchRequest</em></strong></p>
<p><img src="/2021/07/28/rocketMQ/DispatchRequest.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String topic; <span class="comment">//消息主题名称</span></span><br><span class="line"><span class="keyword">int</span> queueId;  <span class="comment">//消息队列ID</span></span><br><span class="line"><span class="keyword">long</span> commitLogOffset;	<span class="comment">//消息物理偏移量</span></span><br><span class="line"><span class="keyword">int</span> msgSize;	<span class="comment">//消息长度</span></span><br><span class="line"><span class="keyword">long</span> tagsCode;	<span class="comment">//消息过滤tag hashCode</span></span><br><span class="line"><span class="keyword">long</span> storeTimestamp;	<span class="comment">//消息存储时间戳</span></span><br><span class="line"><span class="keyword">long</span> consumeQueueOffset;	<span class="comment">//消息队列偏移量</span></span><br><span class="line">String keys;	<span class="comment">//消息索引key</span></span><br><span class="line"><span class="keyword">boolean</span> success;	<span class="comment">//是否成功解析到完整的消息</span></span><br><span class="line">String uniqKey;	<span class="comment">//消息唯一键</span></span><br><span class="line"><span class="keyword">int</span> sysFlag;	<span class="comment">//消息系统标记</span></span><br><span class="line"><span class="keyword">long</span> preparedTransactionOffset;	<span class="comment">//消息预处理事务偏移量</span></span><br><span class="line">Map&lt;String, String&gt; propertiesMap;	<span class="comment">//消息属性</span></span><br><span class="line"><span class="keyword">byte</span>[] bitMap;	<span class="comment">//位图</span></span><br></pre></td></tr></table></figure>

<h5 id="1）转发到ConsumerQueue"><a href="#1）转发到ConsumerQueue" class="headerlink" title="1）转发到ConsumerQueue"></a>1）转发到ConsumerQueue</h5><p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E5%88%B0%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildConsumeQueue</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());</span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                <span class="comment">//消息分发</span></span><br><span class="line">                DefaultMessageStore.<span class="keyword">this</span>.putMessagePositionInfo(request);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore#putMessagePositionInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfo</span><span class="params">(DispatchRequest dispatchRequest)</span> </span>&#123;    <span class="comment">//获得消费队列    ConsumeQueue cq = this.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());    //消费队列分发消息    cq.putMessagePositionInfoWrapper(dispatchRequest);&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore#putMessagePositionInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依次将消息偏移量、消息长度、tag写入到ByteBuffer中this.byteBufferIndex.flip();this.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);this.byteBufferIndex.putLong(offset);this.byteBufferIndex.putInt(size);this.byteBufferIndex.putLong(tagsCode);//获得内存映射文件MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile(expectLogicOffset);if (mappedFile != null) &#123;    //将消息追加到内存映射文件,异步输盘    return mappedFile.appendMessage(this.byteBufferIndex.array());&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="2）转发到Index"><a href="#2）转发到Index" class="headerlink" title="2）转发到Index"></a>2）转发到Index</h5><p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E5%88%B0%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildIndex</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.indexService.buildIndex(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore#buildIndex</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildIndex</span><span class="params">(DispatchRequest req)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得索引文件</span></span><br><span class="line">    IndexFile indexFile = retryGetAndCreateIndexFile();</span><br><span class="line">    <span class="keyword">if</span> (indexFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获得文件最大物理偏移量</span></span><br><span class="line">        <span class="keyword">long</span> endPhyOffset = indexFile.getEndPhyOffset();</span><br><span class="line">        DispatchRequest msg = req;</span><br><span class="line">        String topic = msg.getTopic();</span><br><span class="line">        String keys = msg.getKeys();</span><br><span class="line">        <span class="comment">//如果该消息的物理偏移量小于索引文件中的最大物理偏移量,则说明是重复数据,忽略本次索引构建</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getCommitLogOffset() &lt; endPhyOffset) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果消息ID不为空,则添加到Hash索引中</span></span><br><span class="line">        <span class="keyword">if</span> (req.getUniqKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));</span><br><span class="line">            <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//构建索引key,RocketMQ支持为同一个消息建立多个索引,多个索引键空格隔开.</span></span><br><span class="line">        <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; keys.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyset.length; i++) &#123;</span><br><span class="line">                String key = keyset[i];</span><br><span class="line">                <span class="keyword">if</span> (key.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    indexFile = putKey(indexFile, msg, buildKey(topic, key));</span><br><span class="line">                    <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">"build index error, stop building index"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-6-消息队列和索引文件恢复"><a href="#2-4-6-消息队列和索引文件恢复" class="headerlink" title="2.4.6 消息队列和索引文件恢复"></a>2.4.6 消息队列和索引文件恢复</h4><p>由于RocketMQ存储首先将消息全量存储在CommitLog文件中，然后异步生成转发任务更新ConsumerQueue和Index文件。如果消息成功存储到CommitLog文件中，转发任务未成功执行，此时消息服务器Broker由于某个愿意宕机，导致CommitLog、ConsumerQueue、IndexFile文件数据不一致。如果不加以人工修复的话，会有一部分消息即便在CommitLog中文件中存在，但由于没有转发到ConsumerQueue，这部分消息将永远复发被消费者消费。</p>
<p><img src="/2021/07/28/rocketMQ/%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt></p>
<h5 id="1）存储文件加载"><a href="#1）存储文件加载" class="headerlink" title="1）存储文件加载"></a>1）存储文件加载</h5><p><strong><em>代码：DefaultMessageStore#load</em></strong></p>
<p>判断上一次是否异常退出。实现机制是Broker在启动时创建abort文件，在退出时通过JVM钩子函数删除abort文件。如果下次启动时存在abort文件。说明Broker时异常退出的，CommitLog与ConsumerQueue数据有可能不一致，需要进行修复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断临时文件是否存在boolean lastExitOK = !this.isTempFileExist();//根据临时文件判断当前Broker是否异常退出private boolean isTempFileExist() &#123;    String fileName = StorePathConfigHelper        .getAbortFile(this.messageStoreConfig.getStorePathRootDir());    File file = new File(fileName);    return file.exists();&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore#load</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载延时队列</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != scheduleMessageService) &#123;</span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.scheduleMessageService.load();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载CommitLog文件</span></span><br><span class="line">result = result &amp;&amp; <span class="keyword">this</span>.commitLog.load();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载消费队列文件</span></span><br><span class="line">result = result &amp;&amp; <span class="keyword">this</span>.loadConsumeQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">	<span class="comment">//加载存储监测点,监测点主要记录CommitLog文件、ConsumerQueue文件、Index索引文件的刷盘点</span></span><br><span class="line">    <span class="keyword">this</span>.storeCheckpoint =<span class="keyword">new</span> StoreCheckpoint(StorePathConfigHelper.getStoreCheckpoint(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class="line">	<span class="comment">//加载index文件</span></span><br><span class="line">    <span class="keyword">this</span>.indexService.load(lastExitOK);</span><br><span class="line">	<span class="comment">//根据Broker是否异常退出,执行不同的恢复策略</span></span><br><span class="line">    <span class="keyword">this</span>.recover(lastExitOK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：MappedFileQueue#load</em></strong></p>
<p>加载CommitLog到映射文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向CommitLog文件目录</span></span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="keyword">this</span>.storePath);</span><br><span class="line"><span class="comment">//获得文件数组</span></span><br><span class="line">File[] files = dir.listFiles();</span><br><span class="line"><span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 文件排序</span></span><br><span class="line">    Arrays.sort(files);</span><br><span class="line">    <span class="comment">//遍历文件</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">		<span class="comment">//如果文件大小和配置文件不一致,退出</span></span><br><span class="line">        <span class="keyword">if</span> (file.length() != <span class="keyword">this</span>.mappedFileSize) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建映射文件</span></span><br><span class="line">            MappedFile mappedFile = <span class="keyword">new</span> MappedFile(file.getPath(), mappedFileSize);</span><br><span class="line">            mappedFile.setWrotePosition(<span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">            mappedFile.setFlushedPosition(<span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">            mappedFile.setCommittedPosition(<span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">            <span class="comment">//将映射文件添加到队列</span></span><br><span class="line">            <span class="keyword">this</span>.mappedFiles.add(mappedFile);</span><br><span class="line">            log.info(<span class="string">"load "</span> + file.getPath() + <span class="string">" OK"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"load file "</span> + file + <span class="string">" error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore#loadConsumeQueue</em></strong></p>
<p>加载消息消费队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行消费队列目录</span></span><br><span class="line">File dirLogic = <span class="keyword">new</span> File(StorePathConfigHelper.getStorePathConsumeQueue(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class="line"><span class="comment">//遍历消费队列目录</span></span><br><span class="line">File[] fileTopicList = dirLogic.listFiles();</span><br><span class="line"><span class="keyword">if</span> (fileTopicList != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File fileTopic : fileTopicList) &#123;</span><br><span class="line">        <span class="comment">//获得子目录名称,即topic名称</span></span><br><span class="line">        String topic = fileTopic.getName();</span><br><span class="line">		<span class="comment">//遍历子目录下的消费队列文件</span></span><br><span class="line">        File[] fileQueueIdList = fileTopic.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (fileQueueIdList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历文件</span></span><br><span class="line">            <span class="keyword">for</span> (File fileQueueId : fileQueueIdList) &#123;</span><br><span class="line">                <span class="comment">//文件名称即队列ID</span></span><br><span class="line">                <span class="keyword">int</span> queueId;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queueId = Integer.parseInt(fileQueueId.getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//创建消费队列并加载到内存</span></span><br><span class="line">                ConsumeQueue logic = <span class="keyword">new</span> ConsumeQueue(</span><br><span class="line">                    topic,</span><br><span class="line">                    queueId,</span><br><span class="line">                    StorePathConfigHelper.getStorePathConsumeQueue(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()),</span><br><span class="line">            <span class="keyword">this</span>.getMessageStoreConfig().getMapedFileSizeConsumeQueue(),</span><br><span class="line">                    <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">this</span>.putConsumeQueue(topic, queueId, logic);</span><br><span class="line">                <span class="keyword">if</span> (!logic.load()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"load logics queue all over, OK"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：IndexService#load</em></strong></p>
<p>加载索引文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> lastExitOK)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//索引文件目录</span></span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="keyword">this</span>.storePath);</span><br><span class="line">    <span class="comment">//遍历索引文件</span></span><br><span class="line">    File[] files = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//文件排序</span></span><br><span class="line">        Arrays.sort(files);</span><br><span class="line">        <span class="comment">//遍历文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//加载索引文件</span></span><br><span class="line">                IndexFile f = <span class="keyword">new</span> IndexFile(file.getPath(), <span class="keyword">this</span>.hashSlotNum, <span class="keyword">this</span>.indexNum, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                f.load();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!lastExitOK) &#123;</span><br><span class="line">                    <span class="comment">//索引文件上次的刷盘时间小于该索引文件的消息时间戳,该文件将立即删除</span></span><br><span class="line">                    <span class="keyword">if</span> (f.getEndTimestamp() &gt; <span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint()</span><br><span class="line">                        .getIndexMsgTimestamp()) &#123;</span><br><span class="line">                        f.destroy(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//将索引文件添加到队列</span></span><br><span class="line">                log.info(<span class="string">"load index file OK, "</span> + f.getFileName());</span><br><span class="line">                <span class="keyword">this</span>.indexFileList.add(f);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">"load file &#123;&#125; error"</span>, file, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                log.error(<span class="string">"load file &#123;&#125; error"</span>, file, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore#recover</em></strong></p>
<p>文件恢复，根据Broker是否正常退出执行不同的恢复策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> lastExitOK)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得最大的物理便宜消费队列</span></span><br><span class="line">    <span class="keyword">long</span> maxPhyOffsetOfConsumeQueue = <span class="keyword">this</span>.recoverConsumeQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastExitOK) &#123;</span><br><span class="line">        <span class="comment">//正常恢复</span></span><br><span class="line">        <span class="keyword">this</span>.commitLog.recoverNormally(maxPhyOffsetOfConsumeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//异常恢复</span></span><br><span class="line">        <span class="keyword">this</span>.commitLog.recoverAbnormally(maxPhyOffsetOfConsumeQueue);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//在CommitLog中保存每个消息消费队列当前的存储逻辑偏移量</span></span><br><span class="line">    <span class="keyword">this</span>.recoverTopicQueueTable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore#recoverTopicQueueTable</em></strong></p>
<p>恢复ConsumerQueue后，将在CommitLog实例中保存每隔消息队列当前的存储逻辑偏移量，这也是消息中不仅存储主题、消息队列ID、还存储了消息队列的关键所在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTopicQueueTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String<span class="comment">/* topic-queueid */</span>, Long<span class="comment">/* offset */</span>&gt; table = <span class="keyword">new</span> HashMap&lt;String, Long&gt;(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//CommitLog最小偏移量</span></span><br><span class="line">    <span class="keyword">long</span> minPhyOffset = <span class="keyword">this</span>.commitLog.getMinOffset();</span><br><span class="line">    <span class="comment">//遍历消费队列,将消费队列保存在CommitLog中</span></span><br><span class="line">    <span class="keyword">for</span> (ConcurrentMap&lt;Integer, ConsumeQueue&gt; maps : <span class="keyword">this</span>.consumeQueueTable.values()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ConsumeQueue logic : maps.values()) &#123;</span><br><span class="line">            String key = logic.getTopic() + <span class="string">"-"</span> + logic.getQueueId();</span><br><span class="line">            table.put(key, logic.getMaxOffsetInQueue());</span><br><span class="line">            logic.correctMinOffset(minPhyOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.commitLog.setTopicQueueTable(table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）正常恢复"><a href="#2）正常恢复" class="headerlink" title="2）正常恢复"></a>2）正常恢复</h5><p><strong><em>代码：CommitLog#recoverNormally</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverNormally</span><span class="params">(<span class="keyword">long</span> maxPhyOffsetOfConsumeQueue)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">final</span> List&lt;MappedFile&gt; mappedFiles = <span class="keyword">this</span>.mappedFileQueue.getMappedFiles();</span><br><span class="line">    <span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class="line">         <span class="comment">//Broker正常停止再重启时,从倒数第三个开始恢复,如果不足3个文件,则从第一个文件开始恢复。</span></span><br><span class="line">        <span class="keyword">int</span> index = mappedFiles.size() - <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        MappedFile mappedFile = mappedFiles.get(index);</span><br><span class="line">        ByteBuffer byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">        <span class="keyword">long</span> processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">        <span class="comment">//代表当前已校验通过的offset</span></span><br><span class="line">        <span class="keyword">long</span> mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//查找消息</span></span><br><span class="line">            DispatchRequest dispatchRequest = <span class="keyword">this</span>.checkMessageAndReturnSize(byteBuffer, checkCRCOnRecover);</span><br><span class="line">            <span class="comment">//消息长度</span></span><br><span class="line">            <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line">           	<span class="comment">//查找结果为true,并且消息长度大于0,表示消息正确.mappedFileOffset向前移动本消息长度</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mappedFileOffset += size;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//如果查找结果为true且消息长度等于0,表示已到该文件末尾,如果还有下一个文件,则重置processOffset和MappedFileOffset重复查找下一个文件,否则跳出循环。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size == <span class="number">0</span>) &#123;</span><br><span class="line">              index++;</span><br><span class="line">              <span class="keyword">if</span> (index &gt;= mappedFiles.size()) &#123;</span><br><span class="line">                  <span class="comment">// Current branch can not happen</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//取出每个文件</span></span><br><span class="line">                  mappedFile = mappedFiles.get(index);</span><br><span class="line">                  byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">                  processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">                  mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">                  </span><br><span class="line">          		&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查找结果为false，表明该文件未填满所有消息，跳出循环，结束循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                log.info(<span class="string">"recover physics file end, "</span> + mappedFile.getFileName());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//更新MappedFileQueue的flushedWhere和committedWhere指针</span></span><br><span class="line">        processOffset += mappedFileOffset;</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(processOffset);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(processOffset);</span><br><span class="line">        <span class="comment">//删除offset之后的所有文件</span></span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.truncateDirtyFiles(processOffset);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (maxPhyOffsetOfConsumeQueue &gt;= processOffset) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defaultMessageStore.truncateDirtyLogicFiles(processOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.destroyLogics();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：MappedFileQueue#truncateDirtyFiles</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">truncateDirtyFiles</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;    List&lt;MappedFile&gt; willRemoveFiles = <span class="keyword">new</span> ArrayList&lt;MappedFile&gt;();	<span class="comment">//遍历目录下文件    for (MappedFile file : this.mappedFiles) &#123;        //文件尾部的偏移量        long fileTailOffset = file.getFileFromOffset() + this.mappedFileSize;        //文件尾部的偏移量大于offset        if (fileTailOffset &gt; offset) &#123;            //offset大于文件的起始偏移量            if (offset &gt;= file.getFileFromOffset()) &#123;                //更新wrotePosition、committedPosition、flushedPosistion                file.setWrotePosition((int) (offset % this.mappedFileSize));                file.setCommittedPosition((int) (offset % this.mappedFileSize));                file.setFlushedPosition((int) (offset % this.mappedFileSize));            &#125; else &#123;                //offset小于文件的起始偏移量,说明该文件是有效文件后面创建的,释放mappedFile占用内存,删除文件                file.destroy(1000);                willRemoveFiles.add(file);            &#125;        &#125;    &#125;    this.deleteExpiredFile(willRemoveFiles);&#125;</span></span><br></pre></td></tr></table></figure>

<p>####3）异常恢复</p>
<p>Broker异常停止文件恢复的实现为CommitLog#recoverAbnormally。异常文件恢复步骤与正常停止文件恢复流程基本相同，其主要差别有两个。首先，正常停止默认从倒数第三个文件开始进行恢复，而异常停止则需要从最后一个文件往前走，找到第一个消息存储正常的文件。其次，如果CommitLog目录没有消息文件，如果消息消费队列目录下存在文件，则需要销毁。</p>
<p><strong><em>代码：CommitLog#recoverAbnormally</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// Looking beginning to recover from which file</span></span><br><span class="line">    <span class="keyword">int</span> index = mappedFiles.size() - <span class="number">1</span>;</span><br><span class="line">    MappedFile mappedFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">        mappedFile = mappedFiles.get(index);</span><br><span class="line">        <span class="comment">//判断消息文件是否是一个正确的文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isMappedFileMatchedRecover(mappedFile)) &#123;</span><br><span class="line">            log.info(<span class="string">"recover from this mapped file "</span> + mappedFile.getFileName());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//根据索引取出mappedFile文件</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        mappedFile = mappedFiles.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...验证消息的合法性,并将消息转发到消息消费队列和索引文件</span></span><br><span class="line">       </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//未找到mappedFile,重置flushWhere、committedWhere都为0，销毁消息队列文件</span></span><br><span class="line">    <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.defaultMessageStore.destroyLogics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-7-刷盘机制"><a href="#2-4-7-刷盘机制" class="headerlink" title="2.4.7 刷盘机制"></a>2.4.7 刷盘机制</h4><p>RocketMQ的存储是基于JDK NIO的内存映射机制（MappedByteBuffer）的，消息存储首先将消息追加到内存，再根据配置的刷盘策略在不同时间进行刷写磁盘。</p>
<h5 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h5><p>消息追加到内存后，立即将数据刷写到磁盘文件</p>
<p><img src="/2021/07/28/rocketMQ/%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98%E6%B5%81%E7%A8%8B.png" alt></p>
<p><strong><em>代码：CommitLog#handleDiskFlush</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刷盘服务</span></span><br><span class="line"><span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</span><br><span class="line"><span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">    <span class="comment">//封装刷盘请求</span></span><br><span class="line">    GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">    <span class="comment">//提交刷盘请求</span></span><br><span class="line">    service.putRequest(request);</span><br><span class="line">    <span class="comment">//线程阻塞5秒，等待刷盘结束</span></span><br><span class="line">    <span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line">    <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">        putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>GroupCommitRequest</em></strong></p>
<p><img src="/2021/07/28/rocketMQ/GroupCommitRequest.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> nextOffset;	<span class="comment">//刷盘点偏移量CountDownLatch countDownLatch = new CountDownLatch(1);	//倒计树锁存器volatile boolean flushOK = false;	//刷盘结果;默认为false</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：GroupCommitService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;        <span class="keyword">try</span> &#123;            <span class="comment">//线程等待10ms            this.waitForRunning(10);            //执行提交            this.doCommit();        &#125; catch (Exception e) &#123;            CommitLog.log.warn(this.getServiceName() + " service has exception. ", e);        &#125;    &#125;	...&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：GroupCommitService#doCommit</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//遍历requestsRead</span></span><br><span class="line">            <span class="keyword">for</span> (GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">                <span class="comment">// There may be a message in the next file, so a maximum of</span></span><br><span class="line">                <span class="comment">// two times the flush</span></span><br><span class="line">                <span class="keyword">boolean</span> flushOK = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; !flushOK; i++) &#123;</span><br><span class="line">                    flushOK = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line">					<span class="comment">//刷盘</span></span><br><span class="line">                    <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">                        CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//唤醒发送消息客户端</span></span><br><span class="line">                req.wakeupCustomer(flushOK);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//更新刷盘监测点</span></span><br><span class="line">            <span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">            <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;               CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="keyword">this</span>.requestsRead.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Because of individual messages is set to not sync flush, it</span></span><br><span class="line">            <span class="comment">// will come to this process</span></span><br><span class="line">            CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h5><p>在消息追加到内存后，立即返回给消息发送端。如果开启transientStorePoolEnable，RocketMQ会单独申请一个与目标物理文件（commitLog）同样大小的堆外内存，该堆外内存将使用内存锁定，确保不会被置换到虚拟内存中去，消息首先追加到堆外内存，然后提交到物理文件的内存映射中，然后刷写到磁盘。如果未开启transientStorePoolEnable，消息直接追加到物理文件直接映射文件中，然后刷写到磁盘中。</p>
<p><img src="/2021/07/28/rocketMQ/%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98%E6%B5%81%E7%A8%8B.png" alt></p>
<p>开启transientStorePoolEnable后异步刷盘步骤:</p>
<ol>
<li>将消息直接追加到ByteBuffer（堆外内存）</li>
<li>CommitRealTimeService线程每隔200ms将ByteBuffer新追加内容提交到MappedByteBuffer中</li>
<li>MappedByteBuffer在内存中追加提交的内容，wrotePosition指针向后移动</li>
<li>commit操作成功返回，将committedPosition位置恢复</li>
<li>FlushRealTimeService线程默认每500ms将MappedByteBuffer中新追加的内存刷写到磁盘</li>
</ol>
<p><strong><em>代码：CommitLog$CommitRealTimeService#run</em></strong></p>
<p>提交线程工作机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//间隔时间,默认200msint interval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();//一次提交的至少页数int commitDataLeastPages = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();//两次真实提交的最大间隔,默认200msint commitDataThoroughInterval =CommitLog.this.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();//上次提交间隔超过commitDataThoroughInterval,则忽略提交commitDataThoroughInterval参数,直接提交long begin = System.currentTimeMillis();if (begin &gt;= (this.lastCommitTimestamp + commitDataThoroughInterval)) &#123;    this.lastCommitTimestamp = begin;    commitDataLeastPages = 0;&#125;//执行提交操作,将待提交数据提交到物理文件的内存映射区boolean result = CommitLog.this.mappedFileQueue.commit(commitDataLeastPages);long end = System.currentTimeMillis();if (!result) &#123;    this.lastCommitTimestamp = end; // result = false means some data committed.    //now wake up flush thread.    //唤醒刷盘线程    flushCommitLogService.wakeup();&#125;if (end - begin &gt; 500) &#123;    log.info("Commit data to file costs &#123;&#125; ms", end - begin);&#125;this.waitForRunning(interval);</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：CommitLog$FlushRealTimeService#run</em></strong></p>
<p>刷盘线程工作机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示await方法等待,默认false</span></span><br><span class="line"><span class="keyword">boolean</span> flushCommitLogTimed = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();</span><br><span class="line"><span class="comment">//线程执行时间间隔</span></span><br><span class="line"><span class="keyword">int</span> interval = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();</span><br><span class="line"><span class="comment">//一次刷写任务至少包含页数</span></span><br><span class="line"><span class="keyword">int</span> flushPhysicQueueLeastPages = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();</span><br><span class="line"><span class="comment">//两次真实刷写任务最大间隔</span></span><br><span class="line"><span class="keyword">int</span> flushPhysicQueueThoroughInterval =</span><br><span class="line">CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//距离上次提交间隔超过flushPhysicQueueThoroughInterval,则本次刷盘任务将忽略flushPhysicQueueLeastPages,直接提交</span></span><br><span class="line"><span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">if</span> (currentTimeMillis &gt;= (<span class="keyword">this</span>.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lastFlushTimestamp = currentTimeMillis;</span><br><span class="line">    flushPhysicQueueLeastPages = <span class="number">0</span>;</span><br><span class="line">    printFlushProgress = (printTimes++ % <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//执行一次刷盘前,先等待指定时间间隔</span></span><br><span class="line"><span class="keyword">if</span> (flushCommitLogTimed) &#123;</span><br><span class="line">    Thread.sleep(interval);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.waitForRunning(interval);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//刷写磁盘</span></span><br><span class="line">CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br><span class="line"><span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line"><span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//更新存储监测点文件的时间戳</span></span><br><span class="line">CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-8-过期文件删除机制"><a href="#2-4-8-过期文件删除机制" class="headerlink" title="2.4.8 过期文件删除机制"></a>2.4.8 过期文件删除机制</h4><p>由于RocketMQ操作CommitLog、ConsumerQueue文件是基于内存映射机制并在启动的时候回加载CommitLog、ConsumerQueue目录下的所有文件，为了避免内存与磁盘的浪费，不可能将消息永久存储在消息服务器上，所以要引入一种机制来删除已过期的文件。RocketMQ顺序写CommitLog、ConsumerQueue文件，所有写操作全部落在最后一个CommitLog或者ConsumerQueue文件上，之前的文件在下一个文件创建后将不会再被更新。RocketMQ清除过期文件的方法时：如果当前文件在在一定时间间隔内没有再次被消费，则认为是过期文件，可以被删除，RocketMQ不会关注这个文件上的消息是否全部被消费。默认每个文件的过期时间为72小时，通过在Broker配置文件中设置fileReservedTime来改变过期时间，单位为小时。</p>
<p><strong><em>代码：DefaultMessageStore#addScheduleTask</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addScheduleTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//每隔10s调度一次清除文件</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.cleanFilesPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">60</span>, <span class="keyword">this</span>.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore#cleanFilesPeriodically</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanFilesPeriodically</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清除存储文件</span></span><br><span class="line">    <span class="keyword">this</span>.cleanCommitLogService.run();</span><br><span class="line">    <span class="comment">//清除消息消费队列文件</span></span><br><span class="line">    <span class="keyword">this</span>.cleanConsumeQueueService.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore#deleteExpiredFiles</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteExpiredFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除的数量</span></span><br><span class="line">    <span class="keyword">int</span> deleteCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//文件保留的时间</span></span><br><span class="line">    <span class="keyword">long</span> fileReservedTime = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getFileReservedTime();</span><br><span class="line">    <span class="comment">//删除物理文件的间隔</span></span><br><span class="line">    <span class="keyword">int</span> deletePhysicFilesInterval = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDeleteCommitLogFilesInterval();</span><br><span class="line">    <span class="comment">//线程被占用,第一次拒绝删除后能保留的最大时间,超过该时间,文件将被强制删除</span></span><br><span class="line">    <span class="keyword">int</span> destroyMapedFileIntervalForcibly = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDestroyMapedFileIntervalForcibly();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> timeup = <span class="keyword">this</span>.isTimeToDelete();</span><br><span class="line"><span class="keyword">boolean</span> spacefull = <span class="keyword">this</span>.isSpaceToDelete();</span><br><span class="line"><span class="keyword">boolean</span> manualDelete = <span class="keyword">this</span>.manualDeleteFileSeveralTimes &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (timeup || spacefull || manualDelete) &#123;</span><br><span class="line">	...执行删除逻辑</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...无作为</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除文件操作的条件</p>
<ol>
<li>指定删除文件的时间点，RocketMQ通过deleteWhen设置一天的固定时间执行一次删除过期文件操作，默认4点</li>
<li>磁盘空间如果不充足，删除过期文件</li>
<li>预留，手工触发。</li>
</ol>
<p><strong><em>代码：CleanCommitLogService#isSpaceToDelete</em></strong></p>
<p>当磁盘空间不足时执行删除过期文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSpaceToDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//磁盘分区的最大使用量</span></span><br><span class="line">    <span class="keyword">double</span> ratio = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDiskMaxUsedSpaceRatio() / <span class="number">100.0</span>;</span><br><span class="line">	<span class="comment">//是否需要立即执行删除过期文件操作</span></span><br><span class="line">    cleanImmediately = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        String storePathPhysic = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getStorePathCommitLog();</span><br><span class="line">        <span class="comment">//当前CommitLog目录所在的磁盘分区的磁盘使用率</span></span><br><span class="line">        <span class="keyword">double</span> physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic);</span><br><span class="line">        <span class="comment">//diskSpaceWarningLevelRatio:磁盘使用率警告阈值,默认0.90</span></span><br><span class="line">        <span class="keyword">if</span> (physicRatio &gt; diskSpaceWarningLevelRatio) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> diskok = DefaultMessageStore.<span class="keyword">this</span>.runningFlags.getAndMakeDiskFull();</span><br><span class="line">            <span class="keyword">if</span> (diskok) &#123;</span><br><span class="line">                DefaultMessageStore.log.error(<span class="string">"physic disk maybe full soon "</span> + physicRatio + <span class="string">", so mark disk full"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//diskSpaceCleanForciblyRatio:强制清除阈值,默认0.85</span></span><br><span class="line">            cleanImmediately = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (physicRatio &gt; diskSpaceCleanForciblyRatio) &#123;</span><br><span class="line">            cleanImmediately = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> diskok = DefaultMessageStore.<span class="keyword">this</span>.runningFlags.getAndMakeDiskOK();</span><br><span class="line">            <span class="keyword">if</span> (!diskok) &#123;</span><br><span class="line">            DefaultMessageStore.log.info(<span class="string">"physic disk space OK "</span> + physicRatio + <span class="string">", so mark disk ok"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (physicRatio &lt; <span class="number">0</span> || physicRatio &gt; ratio) &#123;</span><br><span class="line">        DefaultMessageStore.log.info(<span class="string">"physic disk maybe full soon, so reclaim space, "</span> + physicRatio);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：MappedFileQueue#deleteExpiredFileByTime</em></strong></p>
<p>执行文件销毁和删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mfsLength; i++) &#123;    <span class="comment">//遍历每隔文件    MappedFile mappedFile = (MappedFile) mfs[i];    //计算文件存活时间    long liveMaxTimestamp = mappedFile.getLastModifiedTimestamp() + expiredTime;    //如果超过72小时,执行文件删除    if (System.currentTimeMillis() &gt;= liveMaxTimestamp || cleanImmediately) &#123;        if (mappedFile.destroy(intervalForcibly)) &#123;            files.add(mappedFile);            deleteCount++;            if (files.size() &gt;= DELETE_FILES_BATCH_MAX) &#123;                break;            &#125;            if (deleteFilesInterval &gt; 0 &amp;&amp; (i + 1) &lt; mfsLength) &#123;                try &#123;                    Thread.sleep(deleteFilesInterval);                &#125; catch (InterruptedException e) &#123;                &#125;            &#125;        &#125; else &#123;            break;        &#125;    &#125; else &#123;        //avoid deleting files in the middle        break;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-9-小结"><a href="#2-4-9-小结" class="headerlink" title="2.4.9 小结"></a>2.4.9 小结</h4><p>RocketMQ的存储文件包括消息文件（Commitlog）、消息消费队列文件（ConsumerQueue）、Hash索引文件（IndexFile）、监测点文件（checkPoint）、abort（关闭异常文件）。单个消息存储文件、消息消费队列文件、Hash索引文件长度固定以便使用内存映射机制进行文件的读写操作。RocketMQ组织文件以文件的起始偏移量来命令文件，这样根据偏移量能快速定位到真实的物理文件。RocketMQ基于内存映射文件机制提供了同步刷盘和异步刷盘两种机制，异步刷盘是指在消息存储时先追加到内存映射文件，然后启动专门的刷盘线程定时将内存中的文件数据刷写到磁盘。</p>
<p>CommitLog，消息存储文件，RocketMQ为了保证消息发送的高吞吐量，采用单一文件存储所有主题消息，保证消息存储是完全的顺序写，但这样给文件读取带来了不便，为此RocketMQ为了方便消息消费构建了消息消费队列文件，基于主题与队列进行组织，同时RocketMQ为消息实现了Hash索引，可以为消息设置索引键，根据所以能够快速从CommitLog文件中检索消息。</p>
<p>当消息达到CommitLog后，会通过ReputMessageService线程接近实时地将消息转发给消息消费队列文件与索引文件。为了安全起见，RocketMQ引入abort文件，记录Broker的停机是否是正常关闭还是异常关闭，在重启Broker时为了保证CommitLog文件，消息消费队列文件与Hash索引文件的正确性，分别采用不同策略来恢复文件。</p>
<p>RocketMQ不会永久存储消息文件、消息消费队列文件，而是启动文件过期机制并在磁盘空间不足或者默认凌晨4点删除过期文件，文件保存72小时并且在删除文件时并不会判断该消息文件上的消息是否被消费。</p>
<h3 id="2-5-Consumer"><a href="#2-5-Consumer" class="headerlink" title="2.5 Consumer"></a>2.5 Consumer</h3><h4 id="2-5-1-消息消费概述"><a href="#2-5-1-消息消费概述" class="headerlink" title="2.5.1 消息消费概述"></a>2.5.1 消息消费概述</h4><p>消息消费以组的模式开展，一个消费组内可以包含多个消费者，每一个消费者组可订阅多个主题，消费组之间有ff式和广播模式两种消费模式。集群模式，主题下的同一条消息只允许被其中一个消费者消费。广播模式，主题下的同一条消息，将被集群内的所有消费者消费一次。消息服务器与消费者之间的消息传递也有两种模式：推模式、拉模式。所谓的拉模式，是消费端主动拉起拉消息请求，而推模式是消息达到消息服务器后，推送给消息消费者。RocketMQ消息推模式的实现基于拉模式，在拉模式上包装一层，一个拉取任务完成后开始下一个拉取任务。</p>
<p>集群模式下，多个消费者如何对消息队列进行负载呢？消息队列负载机制遵循一个通用思想：一个消息队列同一个时间只允许被一个消费者消费，一个消费者可以消费多个消息队列。</p>
<p>RocketMQ支持局部顺序消息消费，也就是保证同一个消息队列上的消息顺序消费。不支持消息全局顺序消费，如果要实现某一个主题的全局顺序消费，可以将该主题的队列数设置为1，牺牲高可用性。</p>
<h4 id="2-5-2-消息消费初探"><a href="#2-5-2-消息消费初探" class="headerlink" title="2.5.2 消息消费初探"></a>2.5.2 消息消费初探</h4><p><strong><u>消息推送模式</u></strong></p>
<p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81.png" alt></p>
<p><strong><u>消息消费重要方法</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> <span class="keyword">int</span> delayLevel, <span class="keyword">final</span> String brokerName)</span>：发送消息确认Set&lt;MessageQueue&gt; <span class="title">fetchSubscribeMessageQueues</span><span class="params">(<span class="keyword">final</span> String topic)</span> :获取消费者对主题分配了那些消息队列<span class="keyword">void</span> <span class="title">registerMessageListener</span><span class="params">(<span class="keyword">final</span> MessageListenerConcurrently messageListener)</span>：注册并发事件监听器<span class="keyword">void</span> <span class="title">registerMessageListener</span><span class="params">(<span class="keyword">final</span> MessageListenerOrderly messageListener)</span>：注册顺序消息事件监听器<span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String subExpression)</span>：基于主题订阅消息，消息过滤使用表达式<span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String fullClassName,<span class="keyword">final</span> String filterClassSource)</span>：基于主题订阅消息，消息过滤使用类模式<span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> MessageSelector selector)</span> ：订阅消息，并指定队列选择器<span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(<span class="keyword">final</span> String topic)</span>：取消消息订阅</span></span><br></pre></td></tr></table></figure>

<p><strong><u>DefaultMQPushConsumer</u></strong></p>
<p><img src="/2021/07/28/rocketMQ/DefaultMQPushConsumer.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者组private String consumerGroup;	//消息消费模式private MessageModel messageModel = MessageModel.CLUSTERING;	//指定消费开始偏移量（最大偏移量、最小偏移量、启动时间戳）开始消费private ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;//集群模式下的消息队列负载策略private AllocateMessageQueueStrategy allocateMessageQueueStrategy;//订阅信息private Map&lt;String /* topic */, String /* sub expression */&gt; subscription = new HashMap&lt;String, String&gt;();//消息业务监听器private MessageListener messageListener;//消息消费进度存储器private OffsetStore offsetStore;//消费者最小线程数量private int consumeThreadMin = 20;//消费者最大线程数量private int consumeThreadMax = 20;//并发消息消费时处理队列最大跨度private int consumeConcurrentlyMaxSpan = 2000;//每1000次流控后打印流控日志private int pullThresholdForQueue = 1000;//推模式下任务间隔时间private long pullInterval = 0;//推模式下任务拉取的条数,默认32条private int pullBatchSize = 32;//每次传入MessageListener#consumerMessage中消息的数量private int consumeMessageBatchMaxSize = 1;//是否每次拉取消息都订阅消息private boolean postSubscriptionWhenPull = false;//消息重试次数,-1代表16次private int maxReconsumeTimes = -1;//消息消费超时时间private long consumeTimeout = 15;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-消费者启动流程"><a href="#2-5-3-消费者启动流程" class="headerlink" title="2.5.3 消费者启动流程"></a>2.5.3 消费者启动流程</h4><p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt></p>
<p><strong><em>代码：DefaultMQPushConsumerImpl#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="keyword">this</span>.defaultMQPushConsumer.isUnitMode());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">			<span class="comment">//检查消息者是否合法</span></span><br><span class="line">            <span class="keyword">this</span>.checkConfig();</span><br><span class="line">			<span class="comment">//构建主题订阅信息</span></span><br><span class="line">            <span class="keyword">this</span>.copySubscription();</span><br><span class="line">			<span class="comment">//设置消费者客户端实例名称为进程ID</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//创建MQClient实例</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line">			<span class="comment">//构建rebalanceImpl</span></span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactor</span><br><span class="line">            <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">                mQClientFactory,</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">            <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookLis</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           		<span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">               </span><br><span class="line">           	    <span class="keyword">case</span> BROADCASTING:	 <span class="comment">//消息消费广播模式,将消费进度保存在本地</span></span><br><span class="line">           	        <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">           	            <span class="keyword">break</span>;</span><br><span class="line">           	        <span class="keyword">case</span> CLUSTERING:	<span class="comment">//消息消费集群模式,将消费进度保存在远端Broker</span></span><br><span class="line">           	            <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">           	            <span class="keyword">break</span>;</span><br><span class="line">           	        <span class="keyword">default</span>:</span><br><span class="line">           	            <span class="keyword">break</span>;</span><br><span class="line">           	    &#125;</span><br><span class="line">           	    <span class="keyword">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="keyword">this</span>.offsetStore);</span><br><span class="line">           	&#125;</span><br><span class="line">            <span class="keyword">this</span>.offsetStore.load</span><br><span class="line">            <span class="comment">//创建顺序消息消费服务</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">                <span class="comment">//创建并发消息消费服务</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//消息消费服务启动</span></span><br><span class="line">            <span class="keyword">this</span>.consumeMessageService.start();</span><br><span class="line">            <span class="comment">//注册消费者实例</span></span><br><span class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The consumer group["</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//启动消费者客户端</span></span><br><span class="line">            mQClientFactory.start();</span><br><span class="line">            log.info(<span class="string">"the consumer [&#123;&#125;] start OK."</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">            <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The PushConsumer service state not OK, maybe started once, "</span></span><br><span class="line">                + <span class="keyword">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-4-消息拉取"><a href="#2-5-4-消息拉取" class="headerlink" title="2.5.4 消息拉取"></a>2.5.4 消息拉取</h4><p>消息消费模式有两种模式：广播模式与集群模式。广播模式比较简单，每一个消费者需要拉取订阅主题下所有队列的消息。本文重点讲解集群模式。在集群模式下，同一个消费者组内有多个消息消费者，同一个主题存在多个消费队列，消费者通过负载均衡的方式消费消息。</p>
<p>消息队列负载均衡，通常的作法是一个消息队列在同一个时间只允许被一个消费消费者消费，一个消息消费者可以同时消费多个消息队列。</p>
<h5 id="1）PullMessageService实现机制"><a href="#1）PullMessageService实现机制" class="headerlink" title="1）PullMessageService实现机制"></a>1）PullMessageService实现机制</h5><p>从MQClientInstance的启动流程中可以看出，RocketMQ使用一个单独的线程PullMessageService来负责消息的拉取。</p>
<p><img src="/2021/07/28/rocketMQ/pullMessageService%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6.png" alt></p>
<p><strong><em>代码：PullMessageService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);	<span class="comment">//循环拉取消息    while (!this.isStopped()) &#123;        try &#123;            //从请求队列中获取拉取消息请求            PullRequest pullRequest = this.pullRequestQueue.take();            //拉取消息            this.pullMessage(pullRequest);        &#125; catch (InterruptedException ignored) &#123;        &#125; catch (Exception e) &#123;            log.error("Pull Message Service Run Method exception", e);        &#125;    &#125;    log.info(this.getServiceName() + " service end");&#125;</span></span><br></pre></td></tr></table></figure>

<p><u><strong>PullRequest</strong></u></p>
<p><img src="/2021/07/28/rocketMQ/PullRequest.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String consumerGroup;	<span class="comment">//消费者组private MessageQueue messageQueue;	//待拉取消息队列private ProcessQueue processQueue;	//消息处理队列private long nextOffset;	//待拉取的MessageQueue偏移量private boolean lockedFirst = false;	//是否被锁定</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：PullMessageService#pullMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;    <span class="comment">//获得消费者实例    final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());    if (consumer != null) &#123;        //强转为推送模式消费者        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;        //推送消息        impl.pullMessage(pullRequest);    &#125; else &#123;        log.warn("No matched consumer for the PullRequest &#123;&#125;, drop it", pullRequest);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="2）ProcessQueue实现机制"><a href="#2）ProcessQueue实现机制" class="headerlink" title="2）ProcessQueue实现机制"></a>2）ProcessQueue实现机制</h5><p>ProcessQueue是MessageQueue在消费端的重现、快照。PullMessageService从消息服务器默认每次拉取32条消息，按照消息的队列偏移量顺序存放在ProcessQueue中，PullMessageService然后将消息提交到消费者消费线程池，消息成功消费后从ProcessQueue中移除。</p>
<p><img src="/2021/07/28/rocketMQ/ProcessQueue.png" alt></p>
<p><strong><u>属性</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class="keyword">new</span> TreeMap&lt;Long, MessageExt&gt;();<span class="comment">//读写锁private final ReadWriteLock lockTreeMap = new ReentrantReadWriteLock();//ProcessQueue总消息树private final AtomicLong msgCount = new AtomicLong();//ProcessQueue队列最大偏移量private volatile long queueOffsetMax = 0L;//当前ProcessQueue是否被丢弃private volatile boolean dropped = false;//上一次拉取时间戳private volatile long lastPullTimestamp = System.currentTimeMillis();//上一次消费时间戳private volatile long lastConsumeTimestamp = System.currentTimeMillis();</span></span><br></pre></td></tr></table></figure>

<p><strong><u>方法</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除消费超时消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredMsg</span><span class="params">(DefaultMQPushConsumer pushConsumer)</span></span></span><br><span class="line"><span class="function"><span class="comment">//添加消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取消息最大间隔</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxSpan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//移除消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">removeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将consumingMsgOrderlyTreeMap中消息重新放在msgTreeMap,并清空consumingMsgOrderlyTreeMap   </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//将consumingMsgOrderlyTreeMap消息清除,表示成功处理该批消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">commit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//重新处理该批消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMessageToCosumeAgain</span><span class="params">(List&lt;MessageExt&gt; msgs)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//从processQueue中取出batchSize条消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MessageExt&gt; <span class="title">takeMessags</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> batchSize)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="3）消息拉取基本流程"><a href="#3）消息拉取基本流程" class="headerlink" title="3）消息拉取基本流程"></a>3）消息拉取基本流程</h5><h6 id="1-客户端发起拉取请求"><a href="#1-客户端发起拉取请求" class="headerlink" title="1.客户端发起拉取请求"></a>1.客户端发起拉取请求</h6><p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt></p>
<p><strong><em>代码：DefaultMQPushConsumerImpl#pullMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;    <span class="comment">//从pullRequest获得ProcessQueue    final ProcessQueue processQueue = pullRequest.getProcessQueue();    //如果处理队列被丢弃,直接返回    if (processQueue.isDropped()) &#123;        log.info("the pull request[&#123;&#125;] is dropped.", pullRequest.toString());        return;    &#125;	//如果处理队列未被丢弃,更新时间戳    pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());    try &#123;        this.makeSureStateOK();    &#125; catch (MQClientException e) &#123;        log.warn("pullMessage exception, consumer state not ok", e);        this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);        return;    &#125;	//如果处理队列被挂起,延迟1s后再执行    if (this.isPause()) &#123;        log.warn("consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;", this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());        this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);        return;    &#125;	//获得最大待处理消息数量	long cachedMessageCount = processQueue.getMsgCount().get();    //获得最大待处理消息大小	long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);	//从数量进行流控	if (cachedMessageCount &gt; this.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;	    this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);	    if ((queueFlowControlTimes++ % 1000) == 0) &#123;	        log.warn(	            "the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;",	            this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);	    &#125;	    return;	&#125;	//从消息大小进行流控	if (cachedMessageSizeInMiB &gt; this.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;	    this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);	    if ((queueFlowControlTimes++ % 1000) == 0) &#123;	        log.warn(	            "the cached message size exceeds the threshold &#123;&#125; MiB, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;",	            this.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);	    &#125;	    return;    &#125;    	//获得订阅信息		 final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());    	if (null == subscriptionData) &#123;    	    this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);    	    log.warn("find the consumer's subscription failed, &#123;&#125;", pullRequest);    	    return;		//与服务端交互,获取消息	    this.pullAPIWrapper.pullKernelImpl(	    pullRequest.getMessageQueue(),	    subExpression,	    subscriptionData.getExpressionType(),	    subscriptionData.getSubVersion(),	    pullRequest.getNextOffset(),	    this.defaultMQPushConsumer.getPullBatchSize(),	    sysFlag,	    commitOffsetValue,	    BROKER_SUSPEND_MAX_TIME_MILLIS,	    CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,	    CommunicationMode.ASYNC,	    pullCallback	);            &#125;</span></span><br></pre></td></tr></table></figure>

<h6 id="2-消息服务端Broker组装消息"><a href="#2-消息服务端Broker组装消息" class="headerlink" title="2.消息服务端Broker组装消息"></a>2.消息服务端Broker组装消息</h6><p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%E7%AB%AFBroker%E7%BB%84%E8%A3%85%E6%B6%88%E6%81%AF.png" alt></p>
<p><strong><em>代码：PullMessageProcessor#processRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建消息过滤器MessageFilter messageFilter;if (this.brokerController.getBrokerConfig().isFilterSupportRetry()) &#123;    messageFilter = new ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,        this.brokerController.getConsumerFilterManager());&#125; else &#123;    messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,        this.brokerController.getConsumerFilterManager());&#125;//调用MessageStore.getMessage查找消息final GetMessageResult getMessageResult =    this.brokerController.getMessageStore().getMessage(    				requestHeader.getConsumerGroup(), //消费组名称								    				requestHeader.getTopic(),	//主题名称        			requestHeader.getQueueId(), //队列ID    				requestHeader.getQueueOffset(), 	//待拉取偏移量    				requestHeader.getMaxMsgNums(), 	//最大拉取消息条数    				messageFilter	//消息过滤器    		);</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore#getMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;<span class="keyword">long</span> nextBeginOffset = offset;	<span class="comment">//查找下一次队列偏移量long minOffset = 0;		//当前消息队列最小偏移量long maxOffset = 0;		//当前消息队列最大偏移量GetMessageResult getResult = new GetMessageResult();final long maxOffsetPy = this.commitLog.getMaxOffset();	//当前commitLog最大偏移量//根据主题名称和队列编号获取消息消费队列ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);...minOffset = consumeQueue.getMinOffsetInQueue();maxOffset = consumeQueue.getMaxOffsetInQueue();//消息偏移量异常情况校对下一次拉取偏移量if (maxOffset == 0) &#123;	//表示当前消息队列中没有消息    status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;    nextBeginOffset = nextOffsetCorrection(offset, 0);&#125; else if (offset &lt; minOffset) &#123;	//待拉取消息的偏移量小于队列的其实偏移量    status = GetMessageStatus.OFFSET_TOO_SMALL;    nextBeginOffset = nextOffsetCorrection(offset, minOffset);&#125; else if (offset == maxOffset) &#123;	//待拉取偏移量为队列最大偏移量    status = GetMessageStatus.OFFSET_OVERFLOW_ONE;    nextBeginOffset = nextOffsetCorrection(offset, offset);&#125; else if (offset &gt; maxOffset) &#123;	//偏移量越界    status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;    if (0 == minOffset) &#123;        nextBeginOffset = nextOffsetCorrection(offset, minOffset);    &#125; else &#123;        nextBeginOffset = nextOffsetCorrection(offset, maxOffset);    &#125;&#125;...//根据偏移量从CommitLog中拉取32条消息SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy);</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：PullMessageProcessor#processRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据拉取结果填充responseHeaderresponse.setRemark(getMessageResult.getStatus().name());responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());responseHeader.setMinOffset(getMessageResult.getMinOffset());responseHeader.setMaxOffset(getMessageResult.getMaxOffset());//判断如果存在主从同步慢,设置下一次拉取任务的ID为主节点switch (this.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;    case ASYNC_MASTER:    case SYNC_MASTER:        break;    case SLAVE:        if (!this.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;            response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);        &#125;        break;&#125;...//GetMessageResult与Response的Code转换switch (getMessageResult.getStatus()) &#123;    case FOUND:			//成功        response.setCode(ResponseCode.SUCCESS);        break;    case MESSAGE_WAS_REMOVING:	//消息存放在下一个commitLog中        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);	//消息重试        break;    case NO_MATCHED_LOGIC_QUEUE:	//未找到队列    case NO_MESSAGE_IN_QUEUE:	//队列中未包含消息        if (0 != requestHeader.getQueueOffset()) &#123;            response.setCode(ResponseCode.PULL_OFFSET_MOVED);            requestHeader.getQueueOffset(),            getMessageResult.getNextBeginOffset(),            requestHeader.getTopic(),            requestHeader.getQueueId(),            requestHeader.getConsumerGroup()            );        &#125; else &#123;            response.setCode(ResponseCode.PULL_NOT_FOUND);        &#125;        break;    case NO_MATCHED_MESSAGE:	//未找到消息        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);        break;    case OFFSET_FOUND_NULL:	//消息物理偏移量为空        response.setCode(ResponseCode.PULL_NOT_FOUND);        break;    case OFFSET_OVERFLOW_BADLY:	//offset越界        response.setCode(ResponseCode.PULL_OFFSET_MOVED);        // <span class="doctag">XXX:</span> warn and notify me        log.info("the request offset: &#123;&#125; over flow badly, broker max offset: &#123;&#125;, consumer: &#123;&#125;",                requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());        break;    case OFFSET_OVERFLOW_ONE:	//offset在队列中未找到        response.setCode(ResponseCode.PULL_NOT_FOUND);        break;    case OFFSET_TOO_SMALL:	//offset未在队列中        response.setCode(ResponseCode.PULL_OFFSET_MOVED);        requestHeader.getConsumerGroup(),         requestHeader.getTopic(),         requestHeader.getQueueOffset(),        getMessageResult.getMinOffset(), channel.remoteAddress());        break;    default:        assert false;        break;&#125;...//如果CommitLog标记可用,并且当前Broker为主节点,则更新消息消费进度boolean storeOffsetEnable = brokerAllowSuspend;storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;storeOffsetEnable = storeOffsetEnable    &amp;&amp; this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;if (storeOffsetEnable) &#123;    this.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),        requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());&#125;</span></span><br></pre></td></tr></table></figure>

<h6 id="3-消息拉取客户端处理消息"><a href="#3-消息拉取客户端处理消息" class="headerlink" title="3.消息拉取客户端处理消息"></a>3.消息拉取客户端处理消息</h6><p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF.png" alt></p>
<p><strong><em>代码：MQClientAPIImpl#processPullResponse</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PullResult <span class="title">processPullResponse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> RemotingCommand response)</span> <span class="keyword">throws</span> MQBrokerException, RemotingCommandException </span>&#123;</span><br><span class="line">    PullStatus pullStatus = PullStatus.NO_NEW_MSG;</span><br><span class="line">   	<span class="comment">//判断响应结果</span></span><br><span class="line">    <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.SUCCESS:</span><br><span class="line">            pullStatus = PullStatus.FOUND;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line">            pullStatus = PullStatus.NO_NEW_MSG;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</span><br><span class="line">            pullStatus = PullStatus.NO_MATCHED_MSG;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_OFFSET_MOVED:</span><br><span class="line">            pullStatus = PullStatus.OFFSET_ILLEGAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQBrokerException(response.getCode(), response.getRemark());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//解码响应头</span></span><br><span class="line">    PullMessageResponseHeader responseHeader =</span><br><span class="line">        (PullMessageResponseHeader) response.decodeCommandCustomHeader(PullMessageResponseHeader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="comment">//封装PullResultExt返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PullResultExt(pullStatus, responseHeader.getNextBeginOffset(), responseHeader.getMinOffset(),</span><br><span class="line">        responseHeader.getMaxOffset(), <span class="keyword">null</span>, responseHeader.getSuggestWhichBrokerId(), response.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>PullResult类</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PullStatus pullStatus;	<span class="comment">//拉取结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> nextBeginOffset;	<span class="comment">//下次拉取偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> minOffset;	<span class="comment">//消息队列最小偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxOffset;	<span class="comment">//消息队列最大偏移量</span></span><br><span class="line"><span class="keyword">private</span> List&lt;MessageExt&gt; msgFoundList;	<span class="comment">//拉取的消息列表</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/28/rocketMQ/PullStatus.png" alt></p>
<p><strong><em>代码：DefaultMQPushConsumerImpl$PullCallback#OnSuccess</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将拉取到的消息存入processQueueboolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());//将processQueue提交到consumeMessageService中供消费者消费DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(    pullResult.getMsgFoundList(),    processQueue,    pullRequest.getMessageQueue(),    dispatchToConsume);//如果pullInterval大于0,则等待pullInterval毫秒后将pullRequest对象放入到PullMessageService中的pullRequestQueue队列中if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() &gt; 0) &#123;    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,        DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());&#125; else &#123;    DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);&#125;</span></span><br></pre></td></tr></table></figure>

<h6 id="4-消息拉取总结"><a href="#4-消息拉取总结" class="headerlink" title="4.消息拉取总结"></a>4.消息拉取总结</h6><p><img src="/2021/07/28/rocketMQ/%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93.png" alt></p>
<h5 id="4）消息拉取长轮询机制分析"><a href="#4）消息拉取长轮询机制分析" class="headerlink" title="4）消息拉取长轮询机制分析"></a>4）消息拉取长轮询机制分析</h5><p>RocketMQ未真正实现消息推模式，而是消费者主动向消息服务器拉取消息，RocketMQ推模式是循环向消息服务端发起消息拉取请求，如果消息消费者向RocketMQ拉取消息时，消息未到达消费队列时，如果不启用长轮询机制，则会在服务端等待shortPollingTimeMills时间后（挂起）再去判断消息是否已经到达指定消息队列，如果消息仍未到达则提示拉取消息客户端PULL—NOT—FOUND（消息不存在）；如果开启长轮询模式，RocketMQ一方面会每隔5s轮询检查一次消息是否可达，同时一有消息达到后立马通知挂起线程再次验证消息是否是自己感兴趣的消息，如果是则从CommitLog文件中提取消息返回给消息拉取客户端，否则直到挂起超时，超时时间由消息拉取方在消息拉取是封装在请求参数中，PUSH模式为15s，PULL模式通过DefaultMQPullConsumer#setBrokerSuspendMaxTimeMillis设置。RocketMQ通过在Broker客户端配置longPollingEnable为true来开启长轮询模式。</p>
<p><strong><em>代码：PullMessageProcessor#processRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当没有拉取到消息时，通过长轮询方式继续拉取消息case ResponseCode.PULL_NOT_FOUND:    if (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;        long pollingTimeMills = suspendTimeoutMillisLong;        if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;            pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills();        &#125;        String topic = requestHeader.getTopic();        long offset = requestHeader.getQueueOffset();        int queueId = requestHeader.getQueueId();        //构建拉取请求对象        PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills,            this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);        //处理拉取请求        this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);        response = null;        break;    &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><u>PullRequestHoldService方式实现长轮询</u></strong></p>
<p><strong><em>代码：PullRequestHoldService#suspendPullRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将拉取消息请求，放置在ManyPullRequest集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspendPullRequest</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    String key = <span class="keyword">this</span>.buildKey(topic, queueId);</span><br><span class="line">    ManyPullRequest mpr = <span class="keyword">this</span>.pullRequestTable.get(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mpr) &#123;</span><br><span class="line">        mpr = <span class="keyword">new</span> ManyPullRequest();</span><br><span class="line">        ManyPullRequest prev = <span class="keyword">this</span>.pullRequestTable.putIfAbsent(key, mpr);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mpr = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mpr.addPullRequest(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：PullRequestHoldService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"&#123;&#125; service started"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果开启长轮询每隔5秒判断消息是否到达</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有开启长轮询,每隔1s再次尝试</span></span><br><span class="line">              <span class="keyword">this</span>.waitForRunning(<span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.systemClock.now();</span><br><span class="line">            <span class="keyword">this</span>.checkHoldRequest();</span><br><span class="line">            <span class="keyword">long</span> costTime = <span class="keyword">this</span>.systemClock.now() - beginLockTimestamp;</span><br><span class="line">            <span class="keyword">if</span> (costTime &gt; <span class="number">5</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                log.info(<span class="string">"[NOTIFYME] check hold request cost &#123;&#125; ms."</span>, costTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"&#123;&#125; service end"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：PullRequestHoldService#checkHoldRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历拉取任务private void checkHoldRequest() &#123;    for (String key : this.pullRequestTable.keySet()) &#123;        String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);        if (2 == kArray.length) &#123;            String topic = kArray[0];            int queueId = Integer.parseInt(kArray[1]);            //获得消息偏移量            final long offset = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);            try &#123;                //通知有消息达到                this.notifyMessageArriving(topic, queueId, offset);            &#125; catch (Throwable e) &#123;                log.error("check hold request failed. topic=&#123;&#125;, queueId=&#123;&#125;", topic, queueId, e);            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>代码：PullRequestHoldService#notifyMessageArriving</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果拉取消息偏移大于请求偏移量,如果消息匹配调用executeRequestWhenWakeup处理消息</span></span><br><span class="line"><span class="keyword">if</span> (newestOffset &gt; request.getPullFromThisOffset()) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,</span><br><span class="line">        <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));</span><br><span class="line">    <span class="comment">// match by bit map, need eval again when properties is not null.</span></span><br><span class="line">    <span class="keyword">if</span> (match &amp;&amp; properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        match = request.getMessageFilter().isMatchedByCommitLog(<span class="keyword">null</span>, properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                request.getRequestCommand());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果过期时间超时,则不继续等待将直接返回给客户端消息未找到</span></span><br><span class="line"><span class="keyword">if</span> (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">            request.getRequestCommand());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果开启了长轮询机制，PullRequestHoldService会每隔5s被唤醒去尝试检测是否有新的消息的到来才给客户端响应，或者直到超时才给客户端进行响应，消息实时性比较差，为了避免这种情况，RocketMQ引入另外一种机制：当消息到达时唤醒挂起线程触发一次检查。</p>
<p><strong><u>DefaultMessageStore$ReputMessageService机制</u></strong></p>
<p><strong><em>代码：DefaultMessageStore#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//长轮询入口</span></span><br><span class="line"><span class="keyword">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</span><br><span class="line"><span class="keyword">this</span>.reputMessageService.start();</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore$ReputMessageService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//长轮询核心逻辑代码入口</span></span><br><span class="line">            <span class="keyword">this</span>.doReput();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：DefaultMessageStore$ReputMessageService#deReput</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当新消息达到是,进行通知监听器进行处理</span></span><br><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">    &amp;&amp; DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.isLongPollingEnable()) &#123;</span><br><span class="line">    DefaultMessageStore.<span class="keyword">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">        dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">        dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</span><br><span class="line">        dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：NotifyMessageArrivingListener#arriving</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arriving</span><span class="params">(String topic, <span class="keyword">int</span> queueId, <span class="keyword">long</span> logicOffset, <span class="keyword">long</span> tagsCode,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> msgStoreTime, <span class="keyword">byte</span>[] filterBitMap, Map&lt;String, String&gt; properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pullRequestHoldService.notifyMessageArriving(topic, queueId, logicOffset, tagsCode,</span><br><span class="line">        msgStoreTime, filterBitMap, properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-5-消息队列负载与重新分布机制"><a href="#2-5-5-消息队列负载与重新分布机制" class="headerlink" title="2.5.5 消息队列负载与重新分布机制"></a>2.5.5 消息队列负载与重新分布机制</h4><p>RocketMQ消息队列重新分配是由RebalanceService线程来实现。一个MQClientInstance持有一个RebalanceService实现，并随着MQClientInstance的启动而启动。</p>
<p><strong><em>代码：RebalanceService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">	<span class="comment">//RebalanceService线程默认每隔20s执行一次mqClientFactory.doRebalance方法</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitForRunning(waitInterval);</span><br><span class="line">        <span class="keyword">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：MQClientInstance#doRebalance</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//MQClientInstance遍历以注册的消费者,对消费者执行doRebalance()方法</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class="keyword">this</span>.consumerTable.entrySet()) &#123;</span><br><span class="line">        MQConsumerInner impl = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                impl.doRebalance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"doRebalance exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：RebalanceImpl#doRebalance</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历订阅消息对每个主题的订阅的队列进行重新负载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, SubscriptionData&gt; subTable = <span class="keyword">this</span>.getSubscriptionInner();</span><br><span class="line">    <span class="keyword">if</span> (subTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> String topic = entry.getKey();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.rebalanceByTopic(topic, isOrder);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                    log.warn(<span class="string">"rebalanceByTopic Exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.truncateMessageQueueNotMyTopic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：RebalanceImpl#rebalanceByTopic</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从主题订阅消息缓存表中获取主题的队列信息</span></span><br><span class="line">Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line"><span class="comment">//查找该主题订阅组所有的消费者ID</span></span><br><span class="line">List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给消费者重新分配队列</span></span><br><span class="line"><span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">    List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">    mqAll.addAll(mqSet);</span><br><span class="line"></span><br><span class="line">    Collections.sort(mqAll);</span><br><span class="line">    Collections.sort(cidAll);</span><br><span class="line"></span><br><span class="line">    AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">    List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        allocateResult = strategy.allocate(</span><br><span class="line">            <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">            mqAll,</span><br><span class="line">            cidAll);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(<span class="string">"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;"</span>, strategy.getName(),</span><br><span class="line">            e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>RocketMQ默认提供5中负载均衡分配算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AllocateMessageQueueAveragely:平均分配</span><br><span class="line">举例:<span class="number">8</span>个队列q1,q2,q3,q4,q5,a6,q7,q8,消费者<span class="number">3</span>个:c1,c2,c3</span><br><span class="line">分配如下:</span><br><span class="line">c1:q1,q2,q3</span><br><span class="line">c2:q4,q5,a6</span><br><span class="line">c3:q7,q8</span><br><span class="line">AllocateMessageQueueAveragelyByCircle:平均轮询分配</span><br><span class="line">举例:<span class="number">8</span>个队列q1,q2,q3,q4,q5,a6,q7,q8,消费者<span class="number">3</span>个:c1,c2,c3</span><br><span class="line">分配如下:</span><br><span class="line">c1:q1,q4,q7</span><br><span class="line">c2:q2,q5,a8</span><br><span class="line">c3:q3,q6</span><br></pre></td></tr></table></figure>

<p>注意：消息队列的分配遵循一个消费者可以分配到多个队列，但同一个消息队列只会分配给一个消费者，故如果出现消费者个数大于消息队列数量，则有些消费者无法消费消息。</p>
<h4 id="2-5-6-消息消费过程"><a href="#2-5-6-消息消费过程" class="headerlink" title="2.5.6 消息消费过程"></a>2.5.6 消息消费过程</h4><p>PullMessageService负责对消息队列进行消息拉取，从远端服务器拉取消息后将消息存储ProcessQueue消息队列处理队列中，然后调用ConsumeMessageService#submitConsumeRequest方法进行消息消费，使用线程池来消费消息，确保了消息拉取与消息消费的解耦。ConsumeMessageService支持顺序消息和并发消息，核心类图如下：</p>
<p><img src="/2021/07/28/rocketMQ/ConsumeMessageService.png" alt></p>
<p><strong><u>并发消息消费</u></strong></p>
<p><strong><em>代码：ConsumeMessageConcurrentlyService#submitConsumeRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息批次单次</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize = <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line"><span class="comment">//msgs.size()默认最多为32条。</span></span><br><span class="line"><span class="comment">//如果msgs.size()小于consumeBatchSize,则直接将拉取到的消息放入到consumeRequest,然后将consumeRequest提交到消费者线程池中</span></span><br><span class="line"><span class="keyword">if</span> (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">    ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;	<span class="comment">//如果拉取的消息条数大于consumeBatchSize,则对拉取消息进行分页</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> total = <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</span><br><span class="line">   		    List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">   		    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">   		        <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</span><br><span class="line">   		            msgThis.add(msgs.get(total));</span><br><span class="line">   		        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   		            <span class="keyword">break</span>;</span><br><span class="line">   		        &#125;</span><br><span class="line">   		</span><br><span class="line">   		    ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</span><br><span class="line">   		    <span class="keyword">try</span> &#123;</span><br><span class="line">   		        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">   		    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">   		        <span class="keyword">for</span> (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">   		            msgThis.add(msgs.get(total));</span><br><span class="line">   		 </span><br><span class="line">   		        <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">   		    &#125;</span><br><span class="line">   		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：ConsumeMessageConcurrentlyService$ConsumeRequest#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查processQueue的dropped,如果为true,则停止该队列消费。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">    log.info(<span class="string">"the message queue not be able to consume, because it's dropped. group=&#123;&#125; &#123;&#125;"</span>, ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//执行消息处理的钩子函数</span></span><br><span class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">    consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());</span><br><span class="line">    consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    consumeMessageContext.setProps(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">    consumeMessageContext.setMq(messageQueue);</span><br><span class="line">    consumeMessageContext.setMsgList(msgs);</span><br><span class="line">    consumeMessageContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//调用应用程序消息监听器的consumeMessage方法,进入到具体的消息消费业务处理逻辑</span></span><br><span class="line">status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行消息处理后的钩子函数</span></span><br><span class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext.setStatus(status.toString());</span><br><span class="line">    consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);</span><br><span class="line">    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-7-定时消息机制"><a href="#2-5-7-定时消息机制" class="headerlink" title="2.5.7 定时消息机制"></a>2.5.7 定时消息机制</h4><p>定时消息是消息发送到Broker后，并不立即被消费者消费而是要等到特定的时间后才能被消费，RocketMQ并不支持任意的时间精度，如果要支持任意时间精度定时调度，不可避免地需要在Broker层做消息排序，再加上持久化方面的考量，将不可避免的带来巨大的性能消耗，所以RocketMQ只支持特定级别的延迟消息。消息延迟级别在Broker端通过messageDelayLevel配置，默认为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，delayLevel=1表示延迟消息1s,delayLevel=2表示延迟5s,依次类推。</p>
<p>RocketMQ定时消息实现类为ScheduleMessageService，该类在DefaultMessageStore中创建。通过在DefaultMessageStore中调用load方法加载该类并调用start方法启动。</p>
<p><strong><em>代码：ScheduleMessageService#load</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载延迟消息消费进度的加载与delayLevelTable的构造。延迟消息的进度默认存储路径为/store/config/delayOffset.json</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">super</span>.load();</span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.parseDelayLevel();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：ScheduleMessageService#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历延迟队列创建定时任务,遍历延迟级别，根据延迟级别level从offsetTable中获取消费队列的消费进度。如果不存在，则使用0</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Long&gt; entry : <span class="keyword">this</span>.delayLevelTable.entrySet()) &#123;</span><br><span class="line">    Integer level = entry.getKey();</span><br><span class="line">    Long timeDelay = entry.getValue();</span><br><span class="line">    Long offset = <span class="keyword">this</span>.offsetTable.get(level);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == offset) &#123;</span><br><span class="line">        offset = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeDelay != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每隔10s持久化一次延迟队列的消息消费进度</span></span><br><span class="line"><span class="keyword">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (started.get()) ScheduleMessageService.<span class="keyword">this</span>.persist();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"scheduleAtFixedRate flush exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">10000</span>, <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</span><br></pre></td></tr></table></figure>

<p><strong><u>调度机制</u></strong></p>
<p>ScheduleMessageService的start方法启动后，会为每一个延迟级别创建一个调度任务，每一个延迟级别对应SCHEDULE_TOPIC_XXXX主题下的一个消息消费队列。定时调度任务的实现类为DeliverDelayedMessageTimerTask，核心实现方法为executeOnTimeup</p>
<p><strong><em>代码：ScheduleMessageService$DeliverDelayedMessageTimerTask#executeOnTimeup</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据队列ID与延迟主题查找消息消费队列</span></span><br><span class="line">ConsumeQueue cq =</span><br><span class="line">    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,</span><br><span class="line">        delayLevel2QueueId(delayLevel));</span><br><span class="line">...</span><br><span class="line"><span class="comment">//根据偏移量从消息消费队列中获取当前队列中所有有效的消息</span></span><br><span class="line">SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(<span class="keyword">this</span>.offset);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//遍历ConsumeQueue,解析消息队列中消息</span></span><br><span class="line"><span class="keyword">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">    <span class="keyword">long</span> offsetPy = bufferCQ.getByteBuffer().getLong();</span><br><span class="line">    <span class="keyword">int</span> sizePy = bufferCQ.getByteBuffer().getInt();</span><br><span class="line">    <span class="keyword">long</span> tagsCode = bufferCQ.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cq.isExtAddr(tagsCode)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cq.getExt(tagsCode, cqExtUnit)) &#123;</span><br><span class="line">            tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//can't find ext content.So re compute tags code.</span></span><br><span class="line">            log.error(<span class="string">"[BUG] can't find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;"</span>,</span><br><span class="line">                tagsCode, offsetPy, sizePy);</span><br><span class="line">            <span class="keyword">long</span> msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);</span><br><span class="line">            tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> deliverTimestamp = <span class="keyword">this</span>.correctDeliverTimestamp(now, tagsCode);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//根据消息偏移量与消息大小,从CommitLog中查找消息.</span></span><br><span class="line">  	MessageExt msgExt =</span><br><span class="line">   ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.lookMessageByOffset(</span><br><span class="line">       offsetPy, sizePy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-8-顺序消息"><a href="#2-5-8-顺序消息" class="headerlink" title="2.5.8 顺序消息"></a>2.5.8 顺序消息</h4><p>顺序消息实现类是org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService</p>
<p><strong><em>代码：ConsumeMessageOrderlyService#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果消息模式为集群模式，启动定时任务，默认每隔20s执行一次锁定分配给自己的消息消费队列</span></span><br><span class="line">    <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ConsumeMessageOrderlyService.<span class="keyword">this</span>.lockMQPeriodically();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">1</span>, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：ConsumeMessageOrderlyService#submitConsumeRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建消息任务,并提交消费线程池中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ProcessQueue processQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageQueue messageQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> dispathToConsume)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dispathToConsume) &#123;</span><br><span class="line">        ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(processQueue, messageQueue);</span><br><span class="line">        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码：ConsumeMessageOrderlyService$ConsumeRequest#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果消息队列为丢弃,则停止本次消费任务</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">    log.warn(<span class="string">"run, the message queue not be able to consume, because it's dropped. &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从消息队列中获取一个对象。然后消费消息时先申请独占objLock锁。顺序消息一个消息消费队列同一时刻只会被一个消费线程池处理</span></span><br><span class="line"><span class="keyword">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class="keyword">this</span>.messageQueue);</span><br><span class="line"><span class="keyword">synchronized</span> (objLock) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-9-小结"><a href="#2-5-9-小结" class="headerlink" title="2.5.9 小结"></a>2.5.9 小结</h4><p>RocketMQ消息消费方式分别为集群模式、广播模式。</p>
<p>消息队列负载由RebalanceService线程默认每隔20s进行一次消息队列负载，根据当前消费者组内消费者个数与主题队列数量按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消费队列，同一个消息消费队列同一个时间只会分配给一个消费者。</p>
<p>消息拉取由PullMessageService线程根据RebalanceService线程创建的拉取任务进行拉取，默认每次拉取32条消息，提交给消费者消费线程后继续下一次消息拉取。如果消息消费过慢产生消息堆积会触发消息消费拉取流控。 </p>
<p>并发消息消费指消费线程池中的线程可以并发对同一个消息队列的消息进行消费，消费成功后，取出消息队列中最小的消息偏移量作为消息消费进度偏移量存储在于消息消费进度存储文件中，集群模式消息消费进度存储在Broker（消息服务器），广播模式消息消费进度存储在消费者端。</p>
<p>RocketMQ不支持任意精度的定时调度消息，只支持自定义的消息延迟级别，例如1s、2s、5s等，可通过在broker配置文件中设置messageDelayLevel。</p>
<p>顺序消息一般使用集群模式，是指对消息消费者内的线程池中的线程对消息消费队列只能串行消费。并并发消息消费最本质的区别是消息消费时必须成功锁定消息消费队列，在Broker端会存储消息消费队列的锁占用情况。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/07/28/rocketMQ/" data-id="cks69tg9c0005iwuadqztfv95" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-netty" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/16/netty/" class="article-date">
  <time datetime="2021-07-16T05:13:00.000Z" itemprop="datePublished">2021-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/16/netty/">netty</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>[TOC]</p>
<h3 id="一，netty概述"><a href="#一，netty概述" class="headerlink" title="一，netty概述"></a>一，netty概述</h3><h4 id="1，netty的介绍："><a href="#1，netty的介绍：" class="headerlink" title="1，netty的介绍："></a>1，netty的介绍：</h4><ul>
<li><p>Netty是由JBOSS提供的一个Java开源框架，现为Github上的独立项目</p>
</li>
<li><p>Netty是一个异步的，基于事件驱动的网络应用框架，用以快速开发高性能，高可靠性的网络IO程序</p>
</li>
<li><p>Netty只要针对在TCP协议下，面向Client端的高并发应用，或者peer-to-peer场景下的大量数据持续传输的应用</p>
</li>
<li><p>Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景</p>
<p><img src="/2021/07/16/netty/1.png" alt="image-20210716192743873"></p>
</li>
<li><p>要透彻理解Netty，需要先学习NIO，这样我们才能阅读Netty的源码</p>
</li>
</ul>
<h4 id="2，netty的应用场景"><a href="#2，netty的应用场景" class="headerlink" title="2，netty的应用场景"></a>2，netty的应用场景</h4><ul>
<li><p><strong>互联网行业</strong></p>
<ul>
<li>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为高性能的通信框架，往往作为基础通信巨剑被这些RPC框架使用</li>
<li>典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信</li>
<li><img src="/2021/07/16/netty/2.png" alt="image-20210716193421590"></li>
</ul>
</li>
<li><p><strong>游戏行业</strong>：</p>
<ul>
<li>无论是手游服务端还是大型的网络游戏，Java语言得到了越来越广泛的应用</li>
<li>Netty作为高性能的基础通信组件，提供了TCP/UDP和HTTP协议栈，方便定制和开发私有协议栈，账号登陆服务器</li>
<li>地图服务器之间可以方便的通过Netty进行高性能的通信</li>
</ul>
</li>
<li><p><strong>大数据领域</strong></p>
<ul>
<li>经典的Hadoop的高性能通信和序列化组件（AVRO实现数据文件共享）的RPC框架，默认采用Netty进行跨界点通信</li>
<li>它的Netty Service基于Netty框架二次封装实现</li>
<li><img src="/2021/07/16/netty/3.png" alt="image-20210716193857780"></li>
</ul>
</li>
<li><p>其他开源项目使用到Netty</p>
<ul>
<li><a href="https://netty.io/wiki/related-projects.html" target="_blank" rel="noopener">相关项目</a></li>
</ul>
</li>
</ul>
<h4 id="3，I-O模型"><a href="#3，I-O模型" class="headerlink" title="3，I/O模型"></a>3，I/O模型</h4><ul>
<li><p><strong>I/O模型基本说明</strong>：</p>
<ul>
<li><p>I/O模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</p>
</li>
<li><p>Java共支持3中网络编程模型I/O模型：BIO，NIO，AIO</p>
</li>
<li><p>Java BIO：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</p>
<p><img src="/2021/07/16/netty/4.png" alt="image-20210716195356719"></p>
</li>
<li><p>Java NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理</p>
<p><img src="/2021/07/16/netty/5.png" alt="image-20210716195917692"></p>
</li>
<li><p>Java AIO（NIO2.0）：异步非阻塞，AIO引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，他的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p>
</li>
</ul>
</li>
<li><p><strong>BIO，NIO，AIO适用场景分析：</strong></p>
<ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单理解</li>
<li>NIO方式适用于<strong>连接数目多且连接比较短（轻操作）的架构</strong>，比如聊天服务器，弹幕系统，服务器间通讯等，编程比较复杂，JDK1.4开始支持</li>
<li>AIO方式使用于连接<strong>数目多且连接比较长（重操作）的架构</strong>，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持</li>
</ul>
</li>
</ul>
<h3 id="二，BIO"><a href="#二，BIO" class="headerlink" title="二，BIO"></a>二，BIO</h3><h4 id="1，BIO的基本介绍"><a href="#1，BIO的基本介绍" class="headerlink" title="1，BIO的基本介绍"></a>1，BIO的基本介绍</h4><ul>
<li><p>Java BIO就是传统的java io编程，其相关的类和接口在java.io</p>
</li>
<li><p>BIO（blocking I/O）：<strong>同步阻塞</strong>，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过<strong>线程池机制改善</strong>（实现多个客户连接服务器）</p>
</li>
<li><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解</p>
</li>
</ul>
<h4 id="2，BIO工作机制"><a href="#2，BIO工作机制" class="headerlink" title="2，BIO工作机制"></a>2，BIO工作机制</h4><ul>
<li><strong>工作原理图</strong></li>
</ul>
<p><img src="/2021/07/16/netty/6.png" alt="image-20210716200900153"></p>
<ul>
<li><strong>BIO编程简单流程</strong>：<ul>
<li>服务端启动一个ServerSocket</li>
<li>客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</li>
<li>如果有响应，客户端线程会等待请求结束后，在继续执行</li>
</ul>
</li>
</ul>
<h4 id="3，BIO应用实例"><a href="#3，BIO应用实例" class="headerlink" title="3，BIO应用实例"></a>3，BIO应用实例</h4><ul>
<li><p><strong>实例说明</strong>：</p>
<blockquote>
<p>使用BIO模型编写一个服务器端，监听6666端口，当有客户端连接时，就启动一个线程与之通讯</p>
<p>要求使用线程池机制改善，可以连接多个客户端</p>
<p>服务器端可以接收客户端发送的数据（telnet方式即可）</p>
</blockquote>
</li>
<li><p>代码展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">//2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息 id ="</span> + Thread.currentThread().getId() + <span class="string">" 名字="</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">"等待连接...."</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端"</span>);</span><br><span class="line">            <span class="comment">//就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//我们重写</span></span><br><span class="line">                    <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息 id ="</span> + Thread.currentThread().getId() + <span class="string">" 名字="</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket 获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程信息 id ="</span> + Thread.currentThread().getId() + <span class="string">" 名字="</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">"read...."</span>);</span><br><span class="line">               <span class="keyword">int</span> read =  inputStream.read(bytes);</span><br><span class="line">               <span class="keyword">if</span>(read != -<span class="number">1</span>) &#123;</span><br><span class="line">                   System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read</span><br><span class="line">                   )); <span class="comment">//输出客户端发送的数据</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭和client的连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BIO问题分析：</p>
<ul>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据Read，业务处理，数据Write</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在Read操作上，造成线程资源浪费</li>
</ul>
</li>
</ul>
<h3 id="三，NIO"><a href="#三，NIO" class="headerlink" title="三，NIO"></a>三，NIO</h3><h4 id="1，NIO的基本介绍"><a href="#1，NIO的基本介绍" class="headerlink" title="1，NIO的基本介绍"></a>1，NIO的基本介绍</h4><ul>
<li><p>JavaNIO 全称java non-blocking IO，是指JDK提供的新API，从JDK1.4开始，Java提供了一系列改进的输入/输出的新特性，被统称为NIO（即New IO），是<strong>同步非阻塞</strong>的</p>
</li>
<li><p>NIO相关类都被放在java.nio包及子包下，并且对原java.io包中的很多类进行改写</p>
</li>
<li><p>NIO有三大核心部分：<strong>Channel（通道），Buffer（缓冲区），Selector（选择器）</strong></p>
</li>
<li><p>NIO是面向<strong>缓冲区，或者面向块</strong>编程的，数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络</p>
</li>
<li><p>JavaNIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情，非阻塞写也是如此，一个线程请求希尔一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情</p>
</li>
<li><p>通俗理解：NIO是可以做到用一个线程来处理多个操作的，假设有10000个请求过来，根据实际情况，可以分配50或者100个线程来处理，不像之前的阻塞IO那样，非得分配10000个</p>
</li>
<li><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//举例说明Buffer 的使用 (简单说明)</span></span><br><span class="line">        <span class="comment">//创建一个Buffer, 大小为 5, 即可以存放5个int</span></span><br><span class="line">        IntBuffer intBuffer = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向buffer 存放数据</span></span><br><span class="line"><span class="comment">//        intBuffer.put(10);</span></span><br><span class="line"><span class="comment">//        intBuffer.put(11);</span></span><br><span class="line"><span class="comment">//        intBuffer.put(12);</span></span><br><span class="line"><span class="comment">//        intBuffer.put(13);</span></span><br><span class="line"><span class="comment">//        intBuffer.put(14);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;</span><br><span class="line">            intBuffer.put( i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何从buffer读取数据</span></span><br><span class="line">        <span class="comment">//将buffer转换，读写切换(!!!)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public final Buffer flip() &#123;</span></span><br><span class="line"><span class="comment">        limit = position; //读数据不能超过5</span></span><br><span class="line"><span class="comment">        position = 0;</span></span><br><span class="line"><span class="comment">        mark = -1;</span></span><br><span class="line"><span class="comment">        return this;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        intBuffer.flip();</span><br><span class="line">        intBuffer.position(<span class="number">1</span>);<span class="comment">//1,2</span></span><br><span class="line">        System.out.println(intBuffer.get());</span><br><span class="line">        intBuffer.limit(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">while</span> (intBuffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="2，NIO和BIO的比较"><a href="#2，NIO和BIO的比较" class="headerlink" title="2，NIO和BIO的比较"></a>2，NIO和BIO的比较</h4><ul>
<li>BIO以流的方式处理数据，而NIO以块的方式处理数据，块I/O的效率比流I/O高很多</li>
<li>BIO是阻塞的，NIO则是非阻塞</li>
<li>BIO基于字节流和字符流进行操作，而NIO基于Channel（通道）和Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</li>
</ul>
<h4 id="3，NIO三大核心原理示意图"><a href="#3，NIO三大核心原理示意图" class="headerlink" title="3，NIO三大核心原理示意图"></a>3，NIO三大核心原理示意图</h4><p><img src="/2021/07/16/netty/7.png" alt="image-20210717100349511"></p>
<ul>
<li>每个channel都会对应一个Buffer</li>
<li>Selector对应一个线程，一个线程对应多个channel（连接）</li>
<li>该图反应了有三个channel注册到该selector // 程序</li>
<li>程序切换到哪个channel是有事件决定，Event就是一个重要概念</li>
<li>Selector会根据不同的事件，在各个通道上切换</li>
<li>Buffer就是一个内存块，底层是有一个数组</li>
<li>数据的读取写入是通过Buffer，这个和BIO，BIO中要么是输入流，或者是输出流，不能双向，但是NIO的Buffer是可以读也可以写，需要flip方法切换</li>
<li>channel是双向的，可以返回底层操作系统的情况，比如Linux，底层的操作系统通道就是双向的</li>
</ul>
<h4 id="4，缓冲区（Buffer）"><a href="#4，缓冲区（Buffer）" class="headerlink" title="4，缓冲区（Buffer）"></a>4，缓冲区（Buffer）</h4><h5 id="a，基本介绍："><a href="#a，基本介绍：" class="headerlink" title="a，基本介绍："></a>a，基本介绍：</h5><ul>
<li><p>​    缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象（含数组），该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况，Channel提供从文件，网络读取数据的渠道，但是读取或写入的数据都必须经由Buffer</p>
<p><img src="/2021/07/16/netty/8.png" alt="image-20210717101202057"></p>
</li>
</ul>
<h5 id="b，Buffer类及其子类"><a href="#b，Buffer类及其子类" class="headerlink" title="b，Buffer类及其子类"></a>b，Buffer类及其子类</h5><ul>
<li><p>在NIO中，Buffer是一个顶层子类，它是一个抽象类，类的层级关系图：</p>
<p><img src="/2021/07/16/netty/9.png" alt="image-20210717101431071"></p>
</li>
<li><p>Buffer类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息</p>
<p><img src="/2021/07/16/netty/10.png" alt="image-20210717101539242"></p>
</li>
<li><p>Buffer类相关方法：</p>
<p><img src="/2021/07/16/netty/11.png" alt="image-20210717101647680"></p>
<h5 id="c，ByteBuffer"><a href="#c，ByteBuffer" class="headerlink" title="c，ByteBuffer"></a>c，ByteBuffer</h5></li>
<li><p>从前面可以看出对于Java中的基本数据类型（boolean除外），都有一个Buffer类型与之相对应，最常用的自然是ByteBuffer类（二进制数据），该类的主要方法如下：</p>
<p><img src="/2021/07/16/netty/12.png" alt="image-20210717101844528"></p>
</li>
</ul>
<h4 id="5，通道（Channel）"><a href="#5，通道（Channel）" class="headerlink" title="5，通道（Channel）"></a>5，通道（Channel）</h4><h5 id="a，基本介绍：-1"><a href="#a，基本介绍：-1" class="headerlink" title="a，基本介绍："></a>a，基本介绍：</h5><ul>
<li><p>NIO的通道类似于流，但有些区别如下：</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲</li>
</ul>
</li>
<li><p>BIO中的stream是单向的，例如FileInputStream对象只能进行读取数据的操作，而NIO中的通道（Channel）是双向的，可以读操作，也可以写操作</p>
</li>
<li><p>Channel在NIO中是一个接口<code>public interface Channel extends Closealbe{}</code></p>
</li>
<li><p>常用的Channel类有：FileChannel，DatagramChannel，ServerSocketChannel和SocketChannel【ServerSocketChannel类似ServerSocket，SocketChannel类似Socket】</p>
</li>
<li><p>FileChannel用于文件的数据读写，DatagramChannel用于UDP的数据读写，ServerSocketChannel和SocketChannel用于TCP的数据读写</p>
</li>
<li><p><img src="/2021/07/16/netty/13.png" alt="image-20210717181413047"></p>
</li>
</ul>
<h5 id="b，FileChannel"><a href="#b，FileChannel" class="headerlink" title="b，FileChannel"></a>b，FileChannel</h5><p>FileChannel主要用来对本地文件进行IO操作，常见的方法有：</p>
<ul>
<li><code>public int read(ByteBuffer dst)</code>：从通道读取数据并放到缓冲区中</li>
<li><code>public int write(ByteBUffer src)</code>：把缓冲区的数据写到通道中</li>
<li><code>public long transferFrom(ReadableByteChannel src,long position,long count)</code>：把目标通道中复制数据都当前通道</li>
<li><code>public long transferTo(long position,long count,WritableByteChannel target)</code>：把数据从当前通道复制给目标通道</li>
</ul>
<h5 id="c，应用案例1——本地文件写数据"><a href="#c，应用案例1——本地文件写数据" class="headerlink" title="c，应用案例1——本地文件写数据"></a>c，应用案例1——本地文件写数据</h5><p>实例要求：</p>
<ul>
<li><p>使用前面学习后的ByteBuffer（缓冲）和FileChannel（通道），将“hello,尚硅谷”写入到file01.txt中</p>
</li>
<li><p>文件不存在就创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String str = <span class="string">"hello,nihao"</span>;</span><br><span class="line">        <span class="comment">//创建一个输出流-&gt;channel</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\file01.txt"</span>);</span><br><span class="line">        <span class="comment">//通过 fileOutputStream 获取 对应的 FileChannel</span></span><br><span class="line">        <span class="comment">//这个 fileChannel 真实 类型是  FileChannelImpl</span></span><br><span class="line">        FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line">        <span class="comment">//创建一个缓冲区 ByteBuffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//将 str 放入 byteBuffer</span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line">        <span class="comment">//对byteBuffer 进行flip</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="comment">//将byteBuffer 数据写入到 fileChannel</span></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="d，应用案例2——本地文件读数据"><a href="#d，应用案例2——本地文件读数据" class="headerlink" title="d，应用案例2——本地文件读数据"></a>d，应用案例2——本地文件读数据</h5><p>实例要求：</p>
<ul>
<li><p>使用前面学习后的ByteBuffer（缓冲）和FileChannel（通道），将file01.txt中的数据读入到程序，并显示在控制台屏幕</p>
</li>
<li><p>假定文件已经存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"d:\\file01.txt"</span>);</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">//通过fileInputStream 获取对应的FileChannel -&gt; 实际类型  FileChannelImpl</span></span><br><span class="line">        FileChannel fileChannel = fileInputStream.getChannel();</span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) file.length());</span><br><span class="line">        <span class="comment">//将 通道的数据读入到Buffer</span></span><br><span class="line">        fileChannel.read(byteBuffer);</span><br><span class="line">        <span class="comment">//将byteBuffer 的 字节数据 转成String</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="e，应用实例3——使用一个Buffer完成文件读取，写入"><a href="#e，应用实例3——使用一个Buffer完成文件读取，写入" class="headerlink" title="e，应用实例3——使用一个Buffer完成文件读取，写入"></a>e，应用实例3——使用一个Buffer完成文件读取，写入</h5><p>实例要求：</p>
<ul>
<li><p>使用FileChannel（通道）和方法read，write，完成文件的拷贝</p>
</li>
<li><p>考本一个文件1.txt，放在项目下即可</p>
<p><img src="/2021/07/16/netty/14.png" alt="image-20210717201552136"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"1.txt"</span>);</span><br><span class="line">        FileChannel fileChannel01 = fileInputStream.getChannel();</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"2.txt"</span>);</span><br><span class="line">        FileChannel fileChannel02 = fileOutputStream.getChannel();</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//循环读取</span></span><br><span class="line">            <span class="comment">//这里有一个重要的操作，一定不要忘了</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             public final Buffer clear() &#123;</span></span><br><span class="line"><span class="comment">                position = 0;</span></span><br><span class="line"><span class="comment">                limit = capacity;</span></span><br><span class="line"><span class="comment">                mark = -1;</span></span><br><span class="line"><span class="comment">                return this;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            byteBuffer.clear(); <span class="comment">//清空buffer</span></span><br><span class="line">            <span class="keyword">int</span> read = fileChannel01.read(byteBuffer);</span><br><span class="line">            System.out.println(<span class="string">"read ="</span> + read);</span><br><span class="line">            <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123; <span class="comment">//表示读完</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将buffer 中的数据写入到 fileChannel02 -- 2.txt</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            fileChannel02.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭相关的流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="f，应用案例4——拷贝文件transferFrom方法"><a href="#f，应用案例4——拷贝文件transferFrom方法" class="headerlink" title="f，应用案例4——拷贝文件transferFrom方法"></a>f，应用案例4——拷贝文件transferFrom方法</h5><p>实例要求：</p>
<ul>
<li><p>使用FileChannel（通道）和方法transferFrom，完成文件的拷贝</p>
</li>
<li><p>拷贝一张图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建相关流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\a.jpg"</span>);</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\a2.jpg"</span>);</span><br><span class="line">        <span class="comment">//获取各个流对应的filechannel</span></span><br><span class="line">        FileChannel sourceCh = fileInputStream.getChannel();</span><br><span class="line">        FileChannel destCh = fileOutputStream.getChannel();</span><br><span class="line">        <span class="comment">//使用transferForm完成拷贝</span></span><br><span class="line">        destCh.transferFrom(sourceCh,<span class="number">0</span>,sourceCh.size());</span><br><span class="line">        <span class="comment">//关闭相关通道和流</span></span><br><span class="line">        sourceCh.close();</span><br><span class="line">        destCh.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="6，关于Buffer和Channel的注意事项："><a href="#6，关于Buffer和Channel的注意事项：" class="headerlink" title="6，关于Buffer和Channel的注意事项："></a>6，关于Buffer和Channel的注意事项：</h4><ul>
<li><p>ByteBuffer支持类型化的put和get，put放入的是什么数据类型，get就应该使用相应的数据类型出去，否则可能有<code>BufferUnderflowException</code>异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOByteBufferPutGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个Buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">        <span class="comment">//类型化方式放入数据</span></span><br><span class="line">        buffer.putInt(<span class="number">100</span>);</span><br><span class="line">        buffer.putLong(<span class="number">9</span>);</span><br><span class="line">        buffer.putChar(<span class="string">'尚'</span>);</span><br><span class="line">        buffer.putShort((<span class="keyword">short</span>) <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//取出</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(buffer.getInt());</span><br><span class="line">        System.out.println(buffer.getLong());</span><br><span class="line">        System.out.println(buffer.getChar());</span><br><span class="line">        System.out.println(buffer.getShort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以将一个普通的buffer转成只读buffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadOnlyBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">            buffer.put((<span class="keyword">byte</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">//得到一个只读的Buffer</span></span><br><span class="line">        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();</span><br><span class="line">        System.out.println(readOnlyBuffer.getClass());</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.println(readOnlyBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        readOnlyBuffer.put((<span class="keyword">byte</span>)<span class="number">100</span>); <span class="comment">//ReadOnlyBufferException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NIO还提供了MappedByteBuffer，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由NIO来完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*说明1. MappedByteBuffer 可让文件直接在内存(堆外内存)修改, 操作系统不需要拷贝一次 */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"1.txt"</span>, <span class="string">"rw"</span>);        <span class="comment">//获取对应的通道        FileChannel channel = randomAccessFile.getChannel();        /**         * 参数1: FileChannel.MapMode.READ_WRITE 使用的读写模式         * 参数2： 0 ： 可以直接修改的起始位置         * 参数3:  5: 是映射到内存的大小(不是索引位置) ,即将 1.txt 的多少个字节映射到内存         * 可以直接修改的范围就是 0-5         * 实际类型 DirectByteBuffer         */        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 5);        mappedByteBuffer.put(0, (byte) 'H');        mappedByteBuffer.put(3, (byte) '9');        mappedByteBuffer.put(5, (byte) 'Y');//IndexOutOfBoundsException        randomAccessFile.close();        System.out.println("修改成功~~");    &#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>前面我们讲的读写操作，都是通过一个Buffer完成的，NIO还<strong>支持通过多个Buffer（即Buffer数组）完成读写操作</strong>，即Scattering和Gathering</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * Scattering：将数据写入到buffer时，可以采用buffer数组，依次写入  [分散] * Gathering: 从buffer读取数据时，可以采用buffer数组，依次读 */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScatteringAndGatheringTest</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">//使用 ServerSocketChannel 和 SocketChannel 网络        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress inetSocketAddress = new InetSocketAddress(7000);        //绑定端口到socket ，并启动        serverSocketChannel.socket().bind(inetSocketAddress);        //创建buffer数组        ByteBuffer[] byteBuffers = new ByteBuffer[2];        byteBuffers[0] = ByteBuffer.allocate(5);        byteBuffers[1] = ByteBuffer.allocate(3);        //等客户端连接(telnet)        SocketChannel socketChannel = serverSocketChannel.accept();        int messageLength = 8;   //假定从客户端接收8个字节        //循环的读取        while (true) &#123;            int byteRead = 0;            while (byteRead &lt; messageLength ) &#123;                long l = socketChannel.read(byteBuffers);                byteRead += l; //累计读取的字节数                System.out.println("byteRead=" + byteRead);                //使用流打印, 看看当前的这个buffer的position 和 limit                Arrays.asList(byteBuffers).stream().map(buffer -&gt; "postion=" + buffer.position() + ", limit=" + buffer.limit()).forEach(System.out::println);            &#125;            //将所有的buffer进行flip            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());            //将数据读出显示到客户端            long byteWirte = 0;            while (byteWirte &lt; messageLength) &#123;                long l = socketChannel.write(byteBuffers); //                byteWirte += l;            &#125;            //将所有的buffer 进行clear            Arrays.asList(byteBuffers).forEach(buffer-&gt; &#123;                buffer.clear();            &#125;);            System.out.println("byteRead:=" + byteRead + " byteWrite=" + byteWirte + ", messagelength" + messageLength);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>







</li>
</ul>
<h4 id="7，选择器（Selector）"><a href="#7，选择器（Selector）" class="headerlink" title="7，选择器（Selector）"></a>7，选择器（Selector）</h4><h5 id="a，基本介绍：-2"><a href="#a，基本介绍：-2" class="headerlink" title="a，基本介绍："></a>a，基本介绍：</h5><ul>
<li><p>Java的NIO，用非阻塞的IO方式，可以用一个线程，处理多个的客户端连接，就会使用到Selector(选择器)</p>
</li>
<li><p>Selector能够检测多个注册的通道上是否有事件发生（注意：多个Channel以事件的方式可以注册到同一个Selector），如果有事发生，便获取事件然后针对每个事件进行相应的处理，这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求</p>
<p><img src="/2021/07/16/netty/7.png" alt></p>
</li>
<li><p>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</p>
</li>
<li><p>避免了多线程之间的上下文的切换导致的开销</p>
</li>
</ul>
<h5 id="b，Selector特点说明："><a href="#b，Selector特点说明：" class="headerlink" title="b，Selector特点说明："></a>b，Selector特点说明：</h5><ul>
<li>Netty的IO线程NIOEventLoop聚合Selector（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接</li>
<li>当线程从某客户端Socket通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务</li>
<li>线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道</li>
<li>由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁的I/O阻塞导致的线程挂起</li>
<li>一个I/O线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞I/O一连接一线模型，架构的性能，弹性伸缩能力和可靠性都得到了极大的提升</li>
</ul>
<h5 id="c，Selector类相关方法"><a href="#c，Selector类相关方法" class="headerlink" title="c，Selector类相关方法"></a>c，Selector类相关方法</h5><p>Selector类是一个抽象类，常用方法和说明如下；</p>
<p><img src="/2021/07/16/netty/15.png" alt="image-20210717233738946"></p>
<h5 id="d，注意事项"><a href="#d，注意事项" class="headerlink" title="d，注意事项"></a>d，注意事项</h5><ul>
<li>NIO中的ServerSocketChannel功能类似ServerSocket，SocketChannel功能类似Socket</li>
<li>selector相关方法说明：<ul>
<li>selector.select（）：阻塞</li>
<li>selector.select（1000）：阻塞1000毫秒，在1000毫秒后返回</li>
<li>selector.wakeup（）：唤醒selector</li>
<li>selector.selectNow（）：不阻塞，立马返还</li>
</ul>
</li>
</ul>
<h5 id="e，NIO非阻塞网络编程原理分析图"><a href="#e，NIO非阻塞网络编程原理分析图" class="headerlink" title="e，NIO非阻塞网络编程原理分析图"></a>e，NIO非阻塞网络编程原理分析图</h5><p>NIO非阻塞网络编程相关的（Selector，SelectionKey，ServerSocketChannel和SocketChannel）关系梳理图</p>
<p><img src="/2021/07/16/netty/16.png" alt="image-20210717234926126"></p>
<ul>
<li><p>当客户端连接时，会通过ServerSocketChannel得到SocketChannel</p>
</li>
<li><p>Selector进行监听，select方法，返回有事件发生的通道的个数</p>
</li>
<li><p>将socketChannel注册到Selector上，register（Selector sel，int ops），一个selector上可以注册多个SocketChannel</p>
</li>
<li><p>注册后返回一个SelectionKey，会和该Selector关联（集合）</p>
</li>
<li><p>进一步得到各个SelectionKey（有事件发生）</p>
</li>
<li><p>在通过SelectionKey反向获取SocketChannel，方法channel（）</p>
</li>
<li><p>可以通过得到的channel完成业务处理</p>
</li>
<li><p>编写一个NIO入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）；目的：理解NIO非阻塞网络编程机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;        <span class="comment">//创建ServerSocketChannel -&gt; ServerSocket        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        //得到一个Selecor对象        Selector selector = Selector.open();        //绑定一个端口6666, 在服务器端监听        serverSocketChannel.socket().bind(new InetSocketAddress(6666));        //设置为非阻塞        serverSocketChannel.configureBlocking(false);        //把 serverSocketChannel 注册到  selector 关心 事件为 OP_ACCEPT        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        System.out.println("注册后的selectionkey 数量=" + selector.keys().size()); // 1        //循环等待客户端连接        while (true) &#123;            //这里我们等待1秒，如果没有事件发生, 返回            if(selector.select(1000) == 0) &#123; //没有事件发生                System.out.println("服务器等待了1秒，无连接");                continue;            &#125;            //如果返回的&gt;0, 就获取到相关的 selectionKey集合            //1.如果返回的&gt;0， 表示已经获取到关注的事件            //2. selector.selectedKeys() 返回关注事件的集合            //   通过 selectionKeys 反向获取通道            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();            System.out.println("selectionKeys 数量 = " + selectionKeys.size());            //遍历 Set&lt;SelectionKey&gt;, 使用迭代器遍历            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();            while (keyIterator.hasNext()) &#123;                //获取到SelectionKey                SelectionKey key = keyIterator.next();                //根据key 对应的通道发生的事件做相应处理                if(key.isAcceptable()) &#123; //如果是 OP_ACCEPT, 有新的客户端连接                    //该该客户端生成一个 SocketChannel                    SocketChannel socketChannel = serverSocketChannel.accept();                    System.out.println("客户端连接成功 生成了一个 socketChannel " + socketChannel.hashCode());                    //将  SocketChannel 设置为非阻塞                    socketChannel.configureBlocking(false);                    //将socketChannel 注册到selector, 关注事件为 OP_READ， 同时给socketChannel                    //关联一个Buffer                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024));                    System.out.println("客户端连接后 ，注册的selectionkey 数量=" + selector.keys().size()); //2,3,4..                &#125;                if(key.isReadable()) &#123;  //发生 OP_READ                    //通过key 反向获取到对应channel                    SocketChannel channel = (SocketChannel)key.channel();                    //获取到该channel关联的buffer                    ByteBuffer buffer = (ByteBuffer)key.attachment();                    channel.read(buffer);                    System.out.println("form 客户端 " + new String(buffer.array()));                &#125;                //手动从集合中移动当前的selectionKey, 防止重复操作                keyIterator.remove();            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;        <span class="comment">//得到一个网络通道        SocketChannel socketChannel = SocketChannel.open();        //设置非阻塞        socketChannel.configureBlocking(false);        //提供服务器端的ip 和 端口        InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1", 6666);        //连接服务器        if (!socketChannel.connect(inetSocketAddress)) &#123;            while (!socketChannel.finishConnect()) &#123;                System.out.println("因为连接需要时间，客户端不会阻塞，可以做其它工作..");            &#125;        &#125;        //...如果连接成功，就发送数据        String str = "hello, 尚硅谷~";        //Wraps a byte array into a buffer        ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());        //发送数据，将 buffer 数据写入 channel        socketChannel.write(buffer);        System.in.read();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="f，SelectionKey"><a href="#f，SelectionKey" class="headerlink" title="f，SelectionKey"></a>f，SelectionKey</h5><ul>
<li><p><strong>SelectionKey，表示Selector和网络通道的注册关系</strong>，共四种：</p>
<ul>
<li><code>int OP_ACCEPT</code>：有新的网络连接可以accept，值为16</li>
<li><code>int OP_COUNNECT</code>：代表连接已经建立你，值为8</li>
<li><code>int OP_READ</code>：代表读操作，值为1</li>
<li><code>int OP_WRITE</code>：代表写操作，值为4</li>
</ul>
</li>
<li><p>SelectionKey的相关方法：</p>
<p><img src="/2021/07/16/netty/17.png" alt="image-20210718000147479"></p>
</li>
</ul>
<h5 id="g，ServerSocketChannel"><a href="#g，ServerSocketChannel" class="headerlink" title="g，ServerSocketChannel"></a>g，ServerSocketChannel</h5><ul>
<li><p>ServerSockeyChannel在服务器端监听新的客户端Socket连接</p>
</li>
<li><p>相关方法如下：</p>
<p><img src="/2021/07/16/netty/18.png" alt="image-20210718000254480"></p>
</li>
</ul>
<h5 id="h，SockeyChannel"><a href="#h，SockeyChannel" class="headerlink" title="h，SockeyChannel"></a>h，SockeyChannel</h5><ul>
<li><p>SocketChannel，网络IO通道，具体负责进行读写操作，NIO把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区</p>
</li>
<li><p>相关方法：</p>
<p><img src="/2021/07/16/netty/19.png" alt="image-20210718000413676"></p>
</li>
</ul>
<h4 id="8，零拷贝"><a href="#8，零拷贝" class="headerlink" title="8，零拷贝"></a>8，零拷贝</h4><h5 id="a，基本介绍：-3"><a href="#a，基本介绍：-3" class="headerlink" title="a，基本介绍："></a>a，基本介绍：</h5><ul>
<li>零拷贝是网络编程的关键，很多性能优化都离不开</li>
<li>在Java程序中，常用的零拷贝有mmap（内存映射）和sendFile</li>
</ul>
<h5 id="b，传统IO的数据读写"><a href="#b，传统IO的数据读写" class="headerlink" title="b，传统IO的数据读写"></a>b，传统IO的数据读写</h5><p><img src="/2021/07/16/netty/20.png" alt="image-20210718132951690"></p>
<h5 id="c，传统IO模型"><a href="#c，传统IO模型" class="headerlink" title="c，传统IO模型"></a>c，传统IO模型</h5><p><img src="/2021/07/16/netty/21.png" alt="image-20210718133032199"></p>
<p>DMA：direct memory access：直接内存拷贝（不使用CPU）</p>
<h5 id="d，mmap优化"><a href="#d，mmap优化" class="headerlink" title="d，mmap优化"></a>d，mmap优化</h5><ul>
<li><p>mmap通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据，这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数，</p>
<p><img src="/2021/07/16/netty/22.png" alt="image-20210718133243549"></p>
</li>
</ul>
<h5 id="e，sendFile优化"><a href="#e，sendFile优化" class="headerlink" title="e，sendFile优化"></a>e，sendFile优化</h5><ul>
<li><p>Linux2.1版本提供了sendFile函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换</p>
<p><img src="/2021/07/16/netty/23.png" alt="image-20210718133437403"></p>
</li>
<li><p>提示：零拷贝从操作系统角度，就是没有CPU拷贝</p>
</li>
<li><p>Linux在2.4版本中，做了一些修改，避免了从内核缓冲区拷贝到Socket buffer的操作，直接拷贝到协议栈，从而再一次减少了数据考本，</p>
<p><img src="/2021/07/16/netty/24.png" alt="image-20210718133614371"></p>
</li>
<li><p>这里其实有一次CPU拷贝 kemel buffer –&gt; socket buffer，但是，拷贝的信息很少，比如length，offset，消耗低，可以忽略</p>
</li>
</ul>
<h5 id="f，零拷贝的再次理解"><a href="#f，零拷贝的再次理解" class="headerlink" title="f，零拷贝的再次理解"></a>f，零拷贝的再次理解</h5><ul>
<li>我们说零拷贝，是从操作系统的角度来说的，因为内核缓冲区之间，没有数据是重复的（只有kemel buffer有一份数据）</li>
<li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的CPU缓存伪共享以及无CPU校验的计算</li>
</ul>
<h5 id="g，mmap和sendFile的区别"><a href="#g，mmap和sendFile的区别" class="headerlink" title="g，mmap和sendFile的区别"></a>g，mmap和sendFile的区别</h5><ul>
<li>mmap适合小数据量读写，sendFile适合大文件传输</li>
<li>mmap需要4次上下文切换，3次数据拷贝；sendFile需要3次上下文切换，最少2次数据拷贝</li>
<li>sendFile可以利用DMA方式，减少CPU拷贝，mmap则不能（必须从内核考本到Socket缓冲区）</li>
</ul>
<h5 id="h，NIO零拷贝案例"><a href="#h，NIO零拷贝案例" class="headerlink" title="h，NIO零拷贝案例"></a>h，NIO零拷贝案例</h5><ul>
<li><p>使用传统的IO方法传递一个大文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java IO 的服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">7001</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> readCount = dataInputStream.read(byteArray, <span class="number">0</span>, byteArray.length);</span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> == readCount) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">7001</span>);</span><br><span class="line">        String fileName = <span class="string">"protoc-3.6.1-win32.zip"</span>;</span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">        DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">long</span> readCount;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> ((readCount = inputStream.read(buffer)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            total += readCount;</span><br><span class="line">            dataOutputStream.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"发送总字节数： "</span> + total + <span class="string">", 耗时： "</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>使用NIO零拷贝方式传递（transferTO）一个大文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器public class NewIOServer &#123;    public static void main(String[] args) throws Exception &#123;        InetSocketAddress address = new InetSocketAddress(7001);        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        ServerSocket serverSocket = serverSocketChannel.socket();        serverSocket.bind(address);        //创建buffer        ByteBuffer byteBuffer = ByteBuffer.allocate(4096);        while (true) &#123;            SocketChannel socketChannel = serverSocketChannel.accept();            int readcount = 0;            while (-1 != readcount) &#123;                try &#123;                    readcount = socketChannel.read(byteBuffer);                &#125;catch (Exception ex) &#123;                   // ex.printStackTrace();                    break;                &#125;                //                byteBuffer.rewind(); //倒带 position = 0 mark 作废            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        SocketChannel socketChannel = SocketChannel.open();        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">7001</span>));        String filename = <span class="string">"protoc-3.6.1-win32.zip"</span>;        <span class="comment">//得到一个文件channel        FileChannel fileChannel = new FileInputStream(filename).getChannel();        //准备发送        long startTime = System.currentTimeMillis();        //在linux下一个transferTo 方法就可以完成传输        //在windows 下 一次调用 transferTo 只能发送8m , 就需要分段传输文件, 而且要主要        //传输时的位置 =》 课后思考...        //transferTo 底层使用到零拷贝        long transferCount = fileChannel.transferTo(0, fileChannel.size(), socketChannel);        System.out.println("发送的总的字节数 =" + transferCount + " 耗时:" + (System.currentTimeMillis() - startTime));        //关闭        fileChannel.close();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="9，AIO"><a href="#9，AIO" class="headerlink" title="9，AIO"></a>9，AIO</h4><h5 id="a，基本介绍：-4"><a href="#a，基本介绍：-4" class="headerlink" title="a，基本介绍："></a>a，基本介绍：</h5><ul>
<li>JDK7引入了Asynchronous I/O，即AIO。在进行I/O编程中，常用的两种模式：Reactor和Practor。Java的NIO就是Reactor，当有事件触发时，服务器端得到通知，进行相应的处理</li>
<li>AIO即NIO2.0，叫异步不阻塞的IO，AIO引入异步通道的概念，采用了Proacotr模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li>
<li>目前AIO还没有广泛应用，Netty也是基于NIO，而不是AIO</li>
</ul>
<h4 id="10，BIO，NIO，AIO对比表"><a href="#10，BIO，NIO，AIO对比表" class="headerlink" title="10，BIO，NIO，AIO对比表"></a>10，BIO，NIO，AIO对比表</h4><p><img src="/2021/07/16/netty/25.png" alt="image-20210718135117934"></p>
<h3 id="四，netty高性能架构"><a href="#四，netty高性能架构" class="headerlink" title="四，netty高性能架构"></a>四，netty高性能架构</h3><h4 id="1，原生NIO存在的问题"><a href="#1，原生NIO存在的问题" class="headerlink" title="1，原生NIO存在的问题"></a>1，原生NIO存在的问题</h4><ul>
<li>NIO的类库和API繁杂，使用麻烦；需要熟练掌握Selector，ServerSocketChannel，SocketChannel，ByteBuffer等</li>
<li>需要具备其他的额外技能：要熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程好网络编程非常熟悉，才能编写出高质量的NIO程序</li>
<li>开发工作量和难度都非常大：例如客户端面临断链重连，网络闪断，半包读写，失败缓存，网络拥塞和异常流的处理等等</li>
<li>JDK NIO的Bug：例如臭名昭著的Epoll Bug，它会导致Selector空轮询，最终导致CPU100%，知道JDK1.7版本该问题仍旧存在，没有被根本解决</li>
</ul>
<h5 id="2，Netty官网说明："><a href="#2，Netty官网说明：" class="headerlink" title="2，Netty官网说明："></a>2，Netty官网说明：</h5><p><a href="https://netty.io" target="_blank" rel="noopener">netty官网</a></p>
<p><img src="/2021/07/16/netty/26.png" alt="image-20210719173737768"></p>
<h4 id="3，Netty的优点"><a href="#3，Netty的优点" class="headerlink" title="3，Netty的优点"></a>3，Netty的优点</h4><p>Netty对JDK自带的NIO的API进行了封装，解决了上述问题</p>
<ul>
<li><strong>设计优雅</strong>：适用于各种传输类型的统一API阻塞和非阻塞Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池</li>
<li><strong>使用方便</strong>：详细记录的Javadoc，用户指南和示例；没有其他依赖项，JDK5（Netty3.x）或JDK6（Netty4.x）就足够了</li>
<li><strong>高性能，吞吐量更高</strong>；延迟更低；减少资源消耗；最小化不必要的内存复制</li>
<li><strong>安全</strong>：完整的SSL/TLS和StartTLS支持</li>
<li><strong>社区活跃</strong>，不断更新：社区活跃，版本迭代周期短，发现的Bug可以被及时修复，同时，更多的新功能会被加入</li>
</ul>
<h4 id="4，Netty版本说明："><a href="#4，Netty版本说明：" class="headerlink" title="4，Netty版本说明："></a>4，Netty版本说明：</h4><ul>
<li>netty的版本为netty3.x，netty4.x，netty5.x</li>
<li>因为netty5出现重大bug，已经被官网废弃了，目前推荐使用的是netty4.x的稳定版本</li>
</ul>
<h4 id="5，线程模型基本介绍"><a href="#5，线程模型基本介绍" class="headerlink" title="5，线程模型基本介绍"></a>5，线程模型基本介绍</h4><h5 id="a，线程模型类型："><a href="#a，线程模型类型：" class="headerlink" title="a，线程模型类型："></a>a，线程模型类型：</h5><ul>
<li>目前存在的线程模型有；<ul>
<li>传统阻塞I/O服务模型</li>
<li>Reactor模式</li>
</ul>
</li>
<li>根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现；<ul>
<li>单Reactor单线程；</li>
<li>单Reactor多线程；</li>
<li>主从Reactor多线程</li>
</ul>
</li>
<li>Netty线程模式（Netty主要基于主从Reactor多线程模型做了一定的改进，其中主从Reactor多线程模型有多个Reactor）</li>
</ul>
<h5 id="b，传统阻塞I-O服务模型"><a href="#b，传统阻塞I-O服务模型" class="headerlink" title="b，传统阻塞I/O服务模型"></a>b，传统阻塞I/O服务模型</h5><ul>
<li><p><strong>工作原理图</strong>：</p>
<ul>
<li><p>黄色的框表示对象，蓝色的框表示线程</p>
</li>
<li><p>白色的框表示方法（API）</p>
<p><img src="/2021/07/16/netty/27.png" alt="image-20210719175259396"></p>
</li>
</ul>
</li>
<li><p><strong>模型特点</strong></p>
<ul>
<li>采用阻塞I/O模式获取输入的数据</li>
<li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li>
</ul>
</li>
<li><p><strong>问题分析</strong>：</p>
<ul>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read操作，造成线程资源浪费</li>
</ul>
</li>
</ul>
<h5 id="c，Reactor模式介绍；"><a href="#c，Reactor模式介绍；" class="headerlink" title="c，Reactor模式介绍；"></a>c，Reactor模式介绍；</h5><ul>
<li><p>针对传统阻塞I/O服务模型的2个缺点，解决方案：</p>
<ul>
<li><p>基于I/O复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理Reactor对应的叫法：反应器模式，分发者模式（Dispatcher），通知者模式（notifier）</p>
</li>
<li><p>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接业务</p>
<p><img src="/2021/07/16/netty/28.png" alt="image-20210719180122081"></p>
</li>
</ul>
</li>
</ul>
<p>​    </p>
<ul>
<li><p>I/O复用结合线程池，就是Reactor模式基本设计思想</p>
<p><img src="/2021/07/16/netty/29.png" alt="image-20210719180315916"></p>
<ul>
<li>Reactor模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li>
<li>服务器端程序处理传入的多个请求，并将它们同步分派到相应的处理线程，因此Reactor模式也叫Dispatcher模式</li>
<li>Reactor模式使用IO复用监听时间，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li>
</ul>
</li>
</ul>
<h5 id="d，Reactor模式中核心组成"><a href="#d，Reactor模式中核心组成" class="headerlink" title="d，Reactor模式中核心组成"></a>d，Reactor模式中核心组成</h5><ul>
<li>Reactor：Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应，它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人</li>
<li>Handlers：处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员，Reactor通过调度适当的处理程序来响应IO事件，处理程序执行非阻塞操作</li>
</ul>
<h4 id="6，单Reactor单线程"><a href="#6，单Reactor单线程" class="headerlink" title="6，单Reactor单线程"></a>6，单Reactor单线程</h4><ul>
<li><p><strong>工作原理</strong></p>
<p><img src="/2021/07/16/netty/30.png" alt="image-20210719180919120"></p>
<ul>
<li>Select是前面I/O复用模型介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求</li>
<li>Reactor对象通过Select监控客户端请求事件，收到事件后通过Dispatch进行分发</li>
<li>如果是建立连接请求事件，则有Acceptor通过Accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</li>
<li>Handler会完成Read ——》 业务处理 ——》Send的完整业务流程</li>
</ul>
<p>结合实例：服务器端用一个线程通过多路复用搞定所有的IO操作（包括连接，读，写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的NIO案例就属于这种模型</p>
</li>
<li><p><strong>方案优缺点分析</strong>：</p>
<ul>
<li>优点：<ul>
<li>模型简单，没有多线程，进程通信，竞争的问题，全部都在一个线程中完成</li>
</ul>
</li>
<li>缺点：<ul>
<li>性能问题，只有一个线程，无法完全发挥多核CPU的性能，Handler在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
</ul>
</li>
<li>使用场景：<ul>
<li>客户端的数量有限，业务处理非常快速，比如Redis在业务处理的时间复杂度O（1）的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7，单Reactor多线程"><a href="#7，单Reactor多线程" class="headerlink" title="7，单Reactor多线程"></a>7，单Reactor多线程</h4><ul>
<li><p>工作原理图</p>
<p><img src="/2021/07/16/netty/31.png" alt="image-20210719182209529"></p>
<ul>
<li>Reactor对象通过select监控客户端请求事件，收到事件后，通过dispatch进行分发</li>
<li>如果建立连接请求，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由reactor分发调用连接对应的handler来处理</li>
<li>handler只负责响应事件，不做具体的业务处理，通过read读取数据后，会分发给后面的worker线程池的某个线程处理业务</li>
<li>worker线程池分配独立线程完成真正的业务，并将结果返回给handler</li>
<li>handler收到响应后，通过send将结果返回给client</li>
</ul>
</li>
<li><p>方案优缺点：</p>
<ul>
<li>优点：<ul>
<li>可以充分利用多核CPU的处理能力</li>
</ul>
</li>
<li>缺点：<ul>
<li>多线程数据共享和访问比较复杂，reactor处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8，主从Reactor多线程"><a href="#8，主从Reactor多线程" class="headerlink" title="8，主从Reactor多线程"></a>8，主从Reactor多线程</h4><ul>
<li><p>工作原理图：</p>
<blockquote>
<p>针对单Reactor多线程模型中，Reactor在单线程中运行，高并发场景下容易成为性能瓶颈，可以让Reactor在多线程中运行</p>
</blockquote>
<p><img src="/2021/07/16/netty/32.png" alt="image-20210719193731624"></p>
<p><img src="/2021/07/16/netty/33.png" alt="image-20210719201808800"></p>
<ul>
<li>Reactor主线程MainReactor对象通过select监听line接事件，收到事件后，通过Acceptor处理连接事件</li>
<li>当Acceptor处理连接事件后，MainReactor将连接分配给SubReactor</li>
<li>subreactor将连接加入到连接队列进行监听，并创建handler进行各种事件处理</li>
<li>当有新事件发生时，subreactor就会调用对应的handler处理</li>
<li>handler通过read读取数据，分发给后面的worker线程处理</li>
<li>worker线程池分配独立的worker线程进行业务处理，并返回结果</li>
<li>handler收到响应的结果后，再通过send将结果返回给client</li>
<li>Reactor主线程可以对应多个Reactor子线程，即MainReactor可以关联多个SubReactor</li>
</ul>
</li>
<li><p>方案优缺点：</p>
<ul>
<li>优点：<ul>
<li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理</li>
<li>父线程与子线程的数据交互简单，Reactor主线程只需要把新连接传给子线程，子线程无需返回数据</li>
</ul>
</li>
<li>缺点：<ul>
<li>编程复杂度较高</li>
</ul>
</li>
</ul>
<p>结合实例：这种模型在许多项目中广泛使用，包括Nginx主从Reactor多进程模型，Memcached主从多线程，Netty主从多线程模型的支持</p>
</li>
</ul>
<h4 id="9，Reactor模型小结："><a href="#9，Reactor模型小结：" class="headerlink" title="9，Reactor模型小结："></a>9，Reactor模型小结：</h4><ul>
<li>reactor模式具有如下的优点：<ul>
<li>响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的</li>
<li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li>
<li>扩展性好，可以方便的通过增加Reactor实例个数来充分利用CPU资源</li>
<li>复用性好，Reactor模型本身与具体时间处理逻辑无关，具有很高的复用性</li>
</ul>
</li>
</ul>
<h4 id="10，Netty模型"><a href="#10，Netty模型" class="headerlink" title="10，Netty模型"></a>10，Netty模型</h4><h5 id="a，工作原理示意图——简单版"><a href="#a，工作原理示意图——简单版" class="headerlink" title="a，工作原理示意图——简单版"></a>a，工作原理示意图——简单版</h5><blockquote>
<p>Netty主要基于主从Reactor多线程模型做了一定的改进，其中主从Reactor多线程模型有多个Reactor</p>
</blockquote>
<p><img src="/2021/07/16/netty/34.png" alt="image-20210719202708542"></p>
<ul>
<li>BossGroup线程维护Selector，只关注Accept</li>
<li>当接收到Accept事件，获取到对应的SocketChannel，封装成NIOSocketChannel并注册到Worker线程（事件循环），并进行维护</li>
<li>当Worker线程监听到selector中通道发生自己感兴趣的事件后，就进行处理（由handler），注意handler已经加入到通道</li>
</ul>
<h5 id="b，工作原理示意图——进阶版"><a href="#b，工作原理示意图——进阶版" class="headerlink" title="b，工作原理示意图——进阶版"></a>b，工作原理示意图——进阶版</h5><p><img src="/2021/07/16/netty/35.png" alt="image-20210719203003988"></p>
<h5 id="c，工作原理示意图——详细版"><a href="#c，工作原理示意图——详细版" class="headerlink" title="c，工作原理示意图——详细版"></a>c，工作原理示意图——详细版</h5><p><img src="/2021/07/16/netty/36.png" alt="image-20210719203247068"></p>
<ul>
<li>Netty抽象出两组线程池BossGroup专门负责接收客户端的连接，WorkerGroup专门负责网络的读写</li>
<li>BossGroup和WorkerGroup类型都是NioEventLoopGroup</li>
<li>NioEventLoopGroup相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是NioEventLoop</li>
<li>NioEventLoop表示一个不断循环的执行处理任务的线程，每个NioEventLoop都有一个selector，用于监听绑定在其上的socket的网络通讯</li>
<li>NioEventLoopGroup可以有多个线程，即可以含有多个NioEvenetLoop</li>
<li>每个Boss NioEventLoop循环执行的步骤有3步：<ul>
<li>轮询accept事件</li>
<li>处理accept事件，与client建立连接，生成NioSocketChannel，并将其注册到某个worker NioEventLoop上的selector</li>
<li>处理任务队列的任务，即runAllTasks</li>
</ul>
</li>
<li>每个worker NioEventLoop循环执行的步骤<ul>
<li>轮询read，write事件</li>
<li>处理I/O事件，即read，write事件，在对应NioSocketChannel处理</li>
<li>处理任务队列的任务，即runAllTasks</li>
</ul>
</li>
<li>每个worker NioEventLoop处理业务时，会使用pipeline（管道），pipeline中包含了channel，即通过pipeline可以获取到对应通道，管道中维护了很多的处理器</li>
</ul>
<h5 id="d，Netty快速入门实例——TCP服务"><a href="#d，Netty快速入门实例——TCP服务" class="headerlink" title="d，Netty快速入门实例——TCP服务"></a>d，Netty快速入门实例——TCP服务</h5><ul>
<li>Netty服务器在6668端口监听，客户端能发送消息给服务器“hello，服务器~”</li>
<li>服务器可以回复消息给客户端“hello，客户端~”</li>
<li>目的：对Netty线程模型有一个初步认识，便于理解Netty模型理论</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">//创建BossGroup 和 WorkerGroup        //说明        //1. 创建两个线程组 bossGroup 和 workerGroup        //2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成        //3. 两个都是无限循环        //4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数        //   默认实际 cpu核数 * 2        EventLoopGroup bossGroup = new NioEventLoopGroup(1);        EventLoopGroup workerGroup = new NioEventLoopGroup(); //8        try &#123;            //创建服务器端的启动对象，配置参数            ServerBootstrap bootstrap = new ServerBootstrap();            //使用链式编程来进行设置            bootstrap.group(bossGroup, workerGroup) //设置两个线程组                    .channel(NioServerSocketChannel.class) //使用NioSocketChannel 作为服务器的通道实现                    .option(ChannelOption.SO_BACKLOG, 128) // 设置线程队列得到连接个数                    .childOption(ChannelOption.SO_KEEPALIVE, true) //设置保持活动连接状态//                    .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;//创建一个通道初始化对象(匿名对象)                        //给pipeline 设置处理器                        @Override                        protected void initChannel(SocketChannel ch) throws Exception &#123;                            System.out.println("客户socketchannel hashcode=" + ch.hashCode()); //可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue                            ch.pipeline().addLast(new NettyServerHandler());                        &#125;                    &#125;); // 给我们的workerGroup 的 EventLoop 对应的管道设置处理器            System.out.println(".....服务器 is ready...");            //绑定一个端口并且同步, 生成了一个 ChannelFuture 对象            //启动服务器(并绑定端口)            ChannelFuture cf = bootstrap.bind(6668).sync();            //给cf 注册监听器，监控我们关心的事件            cf.addListener(new ChannelFutureListener() &#123;                @Override                public void operationComplete(ChannelFuture future) throws Exception &#123;                    if (cf.isSuccess()) &#123;                        System.out.println("监听端口 6668 成功");                    &#125; else &#123;                        System.out.println("监听端口 6668 失败");                    &#125;                &#125;            &#125;);            //对关闭通道进行监听            cf.channel().closeFuture().sync();        &#125;finally &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*说明1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)2. 这时我们自定义一个Handler , 才能称为一个handler */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="comment">//读取数据实际(这里我们可以读取客户端发送的消息)    /*    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址    2. Object msg: 就是客户端发送的数据 默认Object     */    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;/*        //比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该channel 对应的        //NIOEventLoop 的 taskQueue中,        //解决方案1 用户程序自定义的普通任务        ctx.channel().eventLoop().execute(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    Thread.sleep(5 * 1000);                    ctx.writeAndFlush(Unpooled.copiedBuffer("hello, 客户端~(&gt;^ω^&lt;)喵2", CharsetUtil.UTF_8));                    System.out.println("channel code=" + ctx.channel().hashCode());                &#125; catch (Exception ex) &#123;                    System.out.println("发生异常" + ex.getMessage());                &#125;            &#125;        &#125;);        ctx.channel().eventLoop().execute(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    Thread.sleep(5 * 1000);                    ctx.writeAndFlush(Unpooled.copiedBuffer("hello, 客户端~(&gt;^ω^&lt;)喵3", CharsetUtil.UTF_8));                    System.out.println("channel code=" + ctx.channel().hashCode());                &#125; catch (Exception ex) &#123;                    System.out.println("发生异常" + ex.getMessage());                &#125;            &#125;        &#125;);        //解决方案2 : 用户自定义定时任务 -》 该任务是提交到 scheduleTaskQueue中        ctx.channel().eventLoop().schedule(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    Thread.sleep(5 * 1000);                    ctx.writeAndFlush(Unpooled.copiedBuffer("hello, 客户端~(&gt;^ω^&lt;)喵4", CharsetUtil.UTF_8));                    System.out.println("channel code=" + ctx.channel().hashCode());                &#125; catch (Exception ex) &#123;                    System.out.println("发生异常" + ex.getMessage());                &#125;            &#125;        &#125;, 5, TimeUnit.SECONDS);        System.out.println("go on ...");*/        System.out.println("服务器读取线程 " + Thread.currentThread().getName() + " channle =" + ctx.channel());        System.out.println("server ctx =" + ctx);        System.out.println("看看channel 和 pipeline的关系");        Channel channel = ctx.channel();        ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站        //将 msg 转成一个 ByteBuf        //ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.        ByteBuf buf = (ByteBuf) msg;        System.out.println("客户端发送消息是:" + buf.toString(CharsetUtil.UTF_8));        System.out.println("客户端地址:" + channel.remoteAddress());    &#125;    //数据读取完毕    @Override    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;        //writeAndFlush 是 write + flush        //将数据写入到缓存，并刷新        //一般讲，我们对这个发送的数据进行编码        ctx.writeAndFlush(Unpooled.copiedBuffer("hello, 客户端~(&gt;^ω^&lt;)喵1", CharsetUtil.UTF_8));    &#125;    //处理异常, 一般是需要关闭通道    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        ctx.close();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">//客户端需要一个事件循环组        EventLoopGroup group = new NioEventLoopGroup();        try &#123;            //创建客户端启动对象            //注意客户端使用的不是 ServerBootstrap 而是 Bootstrap            Bootstrap bootstrap = new Bootstrap();            //设置相关参数            bootstrap.group(group) //设置线程组                    .channel(NioSocketChannel.class) // 设置客户端通道的实现类(反射)                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                        @Override                        protected void initChannel(SocketChannel ch) throws Exception &#123;                            ch.pipeline().addLast(new NettyClientHandler()); //加入自己的处理器                        &#125;                    &#125;);            System.out.println("客户端 ok..");            //启动客户端去连接服务器端            //关于 ChannelFuture 要分析，涉及到netty的异步模型            ChannelFuture channelFuture = bootstrap.connect("127.0.0.1", 6668).sync();            //给关闭通道进行监听            channelFuture.channel().closeFuture().sync();        &#125;finally &#123;            group.shutdownGracefully();        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="comment">//当通道就绪就会触发该方法    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;        System.out.println("client " + ctx);        ctx.writeAndFlush(Unpooled.copiedBuffer("hello, server: (&gt;^ω^&lt;)喵", CharsetUtil.UTF_8));    &#125;    //当通道有读取事件时，会触发    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;        ByteBuf buf = (ByteBuf) msg;        System.out.println("服务器回复的消息:" + buf.toString(CharsetUtil.UTF_8));        System.out.println("服务器的地址： "+ ctx.channel().remoteAddress());    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>





<h5 id="e，任务队列中的Task有3种典型使用场景："><a href="#e，任务队列中的Task有3种典型使用场景：" class="headerlink" title="e，任务队列中的Task有3种典型使用场景："></a>e，任务队列中的Task有3种典型使用场景：</h5><ul>
<li>用户程序自定义的普通任务【程序示例在上面】</li>
<li>用户自定义定时任务【程序示例在上面】</li>
<li>非当前Reactor线程调用Channel的各种方法</li>
</ul>
<h5 id="f，方案在说明："><a href="#f，方案在说明：" class="headerlink" title="f，方案在说明："></a>f，方案在说明：</h5><ul>
<li>Netty抽象出两组线程池，BossGroup专门负责接收客户端连接，WorkerGroup专门负责网络读写操作</li>
<li>NioEventLoop表示一个不断循环执行处理任务的线程，每个NioEventLoop都有一个selector，用于监听绑定在其上的socket网络通道</li>
<li>NioEventLoop内部采用串行化设计，从消息的读取 ——》解码 ——》 处理 ——》 编码 ——》 发送，始终由IO线程NioEventLoop负责<ul>
<li>NioEventLoopGroup下包含多个NioEventLoop</li>
<li>每个NioEventLoop中包含有一个Selector，一个taskQueue</li>
<li>每个NioEventLoop的Selector上可以注册监听多个NioChannel</li>
<li>每个NioChannel只会绑定在唯一的NioEventLoop上</li>
<li>每个NioChannel都绑定有一个自己的ChannelPipeline</li>
</ul>
</li>
</ul>
<h4 id="11，Netty的异步模型"><a href="#11，Netty的异步模型" class="headerlink" title="11，Netty的异步模型"></a>11，Netty的异步模型</h4><h5 id="a，基本介绍：-5"><a href="#a，基本介绍：-5" class="headerlink" title="a，基本介绍："></a>a，基本介绍：</h5><ul>
<li>异步的概念喝同步相对，当一个异步过程调用发出后，调用者不能立刻得到结果，实际处理这个调用的组件在完成后，通过状态，通知和回调来通知调用者</li>
<li>Netty中的I/O操作是异步的，包括Bind，Write，Connect等操作会简单的返回一个ChannelFuture</li>
<li>调用者并不能立刻获得结果，而是通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果</li>
<li>Netty的异步模型使建立在future和callback的之上的，callback就是回调，重点说Future，它的核心思想是：假设一个方法fun，计算过程可能非常好使，等待fun返回显然不合适，那么可以在调用fun的时候，立马返回一个Future，后续可以通过Future去监控方法fun的处理过程（即：Future-Listener机制）</li>
</ul>
<h5 id="b，Future说明："><a href="#b，Future说明：" class="headerlink" title="b，Future说明："></a>b，Future说明：</h5><ul>
<li><p>表示异步的执行结果，可以通过它提供的方法来检测执行是否完成，比如检索计算等等</p>
</li>
<li><p>ChannelFuture是一个接口：<code>public interface ChannelFuture extends Future&lt;Void&gt;</code>我们可以添加监听器，当监听的事件发生时，就会通知到监听器</p>
</li>
<li><p><strong>工作原理示意图</strong>：</p>
<p><img src="/2021/07/16/netty/37.png" alt="image-20210720104108906"></p>
</li>
</ul>
<p><img src="/2021/07/16/netty/38.png" alt="image-20210720104132862"></p>
<p>说明：    </p>
<ul>
<li>在使用Netty进行编程时，拦截操作和转换出入站数据只需要你提供callback或利用future即可，这使得链式操作简单，高效，并有利于编写可重用，通用的代码</li>
<li>Netty框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来，解脱出来</li>
</ul>
<h5 id="c，Future—Listener机制"><a href="#c，Future—Listener机制" class="headerlink" title="c，Future—Listener机制"></a>c，Future—Listener机制</h5><ul>
<li><p>当Future对象刚刚创建时，处于非完成状态，调用者可以通过返回的ChannelFuture来获取操作执行的状态，注册监听函数来执行完成后的操作</p>
</li>
<li><p>常见有如下操作：</p>
<ul>
<li>通过isDone方法来判断当前操作是否完成</li>
<li>通过该isSuccess方法来判断已完成的当前操作是否成功</li>
<li>通过getCause方法来获取已完成的当前操作失败的原因</li>
<li>通过isCancelled方法来判断已完成的当前操作是否被取消</li>
<li>通过addListener方法来注册监听器，当操作已完成（isDone方法返回完成），将会通知指定的监听器，如果Future对象已完成，则通知指定的监听器</li>
</ul>
</li>
<li><p>举例实例：绑定端口是同步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span></span><br><span class="line"><span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line"><span class="comment">//给cf 注册监听器，监控我们关心的事件</span></span><br><span class="line"></span><br><span class="line">cf.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cf.isSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"监听端口 6668 成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"监听端口 6668 失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h5 id="d，快速入门实例——HTTP服务"><a href="#d，快速入门实例——HTTP服务" class="headerlink" title="d，快速入门实例——HTTP服务"></a>d，快速入门实例——HTTP服务</h5><ul>
<li>Netty服务器在6668端口监听，浏览器发出请求“<a href="http://localhost:6668/”" target="_blank" rel="noopener">http://localhost:6668/”</a></li>
<li>服务器可以回复消息给客户端“Hello~我是服务器”，并对特定请求资源继续拿给你过滤</li>
<li>目的：Netty可以做Http服务开发，并理解Handler实例和客户端及其请求的关系</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();        <span class="keyword">try</span> &#123;            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>).<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">TestServerInitializer</span>())</span>;            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">6668</span>).sync();                        channelFuture.channel().closeFuture().sync();        &#125;<span class="keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*说明1. SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter2. HttpObject 客户端和服务器端相互通讯的数据被封装成 HttpObject */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;    <span class="comment">//channelRead0 读取客户端数据    @Override    protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception &#123;        System.out.println("对应的channel=" + ctx.channel() + " pipeline=" + ctx        .pipeline() + " 通过pipeline获取channel" + ctx.pipeline().channel());        System.out.println("当前ctx的handler=" + ctx.handler());        //判断 msg 是不是 httprequest请求        if(msg instanceof HttpRequest) &#123;            System.out.println("ctx 类型="+ctx.getClass());            System.out.println("pipeline hashcode" + ctx.pipeline().hashCode() + " TestHttpServerHandler hash=" + this.hashCode());            System.out.println("msg 类型=" + msg.getClass());            System.out.println("客户端地址" + ctx.channel().remoteAddress());            //获取到            HttpRequest httpRequest = (HttpRequest) msg;            //获取uri, 过滤指定的资源            URI uri = new URI(httpRequest.uri());            if("/favicon.ico".equals(uri.getPath())) &#123;                System.out.println("请求了 favicon.ico, 不做响应");                return;            &#125;            //回复信息给浏览器 [http协议]            ByteBuf content = Unpooled.copiedBuffer("hello, 我是服务器", CharsetUtil.UTF_8);            //构造一个http的相应，即 httpresponse            FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);            response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/plain");            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());            //将构建好 response返回            ctx.writeAndFlush(response);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">//向管道加入处理器        //得到管道        ChannelPipeline pipeline = ch.pipeline();        //加入一个netty 提供的httpServerCodec codec =&gt;[coder - decoder]        //HttpServerCodec 说明        //1. HttpServerCodec 是netty 提供的处理http的 编-解码器        pipeline.addLast("MyHttpServerCodec",new HttpServerCodec());        //2. 增加一个自定义的handler        pipeline.addLast("MyTestHttpServerHandler", new TestHttpServerHandler());        System.out.println("ok~~~~");    &#125;&#125;</span></span><br></pre></td></tr></table></figure>







<h3 id="五，Netty核心模块组件"><a href="#五，Netty核心模块组件" class="headerlink" title="五，Netty核心模块组件"></a>五，Netty核心模块组件</h3><h4 id="1，Bootstrap，ServerBootstrap"><a href="#1，Bootstrap，ServerBootstrap" class="headerlink" title="1，Bootstrap，ServerBootstrap"></a>1，Bootstrap，ServerBootstrap</h4><ul>
<li>Bootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类</li>
<li>常见的方法有：<ul>
<li><code>public ServerBootstrap group(EventLoopGroup parentGroup,EventLoopGroup childGroup)</code>：该方法用于服务器端，用来设置两个EventLoop</li>
<li><code>public B group(EventLoopGroup group)</code>：该方法用于客户端，用来设置一个EventLoop</li>
<li><code>public B channel(Class&lt;? extends C&gt;channelClass)</code>：该方法用来设置一个服务器端的通道实现</li>
<li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option ,T value)</code>：用来给ServerChannel添加配置</li>
<li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption,T value)</code>：用来给接收到的通道添加配置</li>
<li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>：该方法用来设置业务处理类（自定义的handler）</li>
<li><code>public ChannelFuture bind(int inetPort)</code>：该方法用于服务器端，用来设置占用的端口号</li>
<li><code>public ChannelFuture connect(String inetHost,int inetPort)</code>：该方法用于客户端，用来连接服务器端</li>
</ul>
</li>
</ul>
<h4 id="2，Future，ChannelFuture"><a href="#2，Future，ChannelFuture" class="headerlink" title="2，Future，ChannelFuture"></a>2，Future，ChannelFuture</h4><ul>
<li>Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理，但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</li>
<li>常见的方法有：<ul>
<li><code>Channel channel()</code>：返回当前正在进行IO操作的通道</li>
<li><code>ChannelFuture sync()</code>：阻塞当前主线程任务，等待异步操作执行完毕</li>
</ul>
</li>
</ul>
<h4 id="3，Channel"><a href="#3，Channel" class="headerlink" title="3，Channel"></a>3，Channel</h4><ul>
<li>Netty网络通信的组件，能够用于执行网络的I/O操作</li>
<li>通过Channel可获得当前网络连接的通道的状态</li>
<li>通过Channel可获得网络连接的配置参数（例如接收缓冲区大小）</li>
<li>Channel提供异步的网络I/O操作（如建立连接，读写，绑定绑定端口），异步调用意味着任何I/O调用都将立即返回，并且不保证在调用结束时所请求的I/O操作已完成</li>
<li>调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上，可以I/O操作成功，失败或取消时回调通知调用方</li>
<li>支持关联I/O操作与对应的处理程序</li>
<li>不同协议，不同的阻塞类型的连接都有不同的Channel类型与之对应，常用的Channel类型：<ul>
<li><code>NioSocketChannel</code>：异步的客户端TCP Socket连接</li>
<li><code>NioServerSocketChannel</code>：异步的服务器端TCPSocket连接</li>
<li><code>NioDatagramChannel</code>：异步的UDP连接</li>
<li><code>NioSctpChannel</code>：异步的客户端Sctp连接</li>
<li><code>NioSctpServerChannel</code>：异步的Sctp服务器端连接，这些通道涵盖了UDP和TCP网络IO以及文件IO</li>
</ul>
</li>
</ul>
<h4 id="4，Selector"><a href="#4，Selector" class="headerlink" title="4，Selector"></a>4，Selector</h4><ul>
<li>Netty基于Selector对象实现I/O多路复用，通过Selector一个线程可以监听多个连接Channel事件</li>
<li>当向一个Selector中注册Channel后，Selector内部的机制就可以自动不断地查询（Select）这些注册的Channel是否有已就绪的I/O事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高线地管理多个Channel</li>
</ul>
<h4 id="5，ChannelHandler"><a href="#5，ChannelHandler" class="headerlink" title="5，ChannelHandler"></a>5，ChannelHandler</h4><ul>
<li><p>ChannelHandler是一个接口，处理I/O事件或拦截I/O操作，并将其转发到其ChannelPipeline（业务处理链）中的下一个处理程序</p>
</li>
<li><p>ChannelHandler本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</p>
</li>
<li><p>ChannelHandler及其实现类UML类图：</p>
<p><img src="/2021/07/16/netty/39.png" alt="image-20210720202335505"></p>
</li>
</ul>
<ul>
<li><p>我们经常需要自定义一个Handler类去继承ChannelInboundHandlerAdapter，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelInboundHandlerAdapter</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ctx.fireChannelUnregistered();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通道就绪事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ctx.fireChannelInactive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通道读取数据事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx,Object msg)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数据读取完毕事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(CHnanelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ctx.fireChannelReadComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx,Object evt)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ctx.fireUserEventTriggered(evt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ctx.channelWritabilityChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通道发生异常事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h4 id="6，Pipeline和ChannelPipeline"><a href="#6，Pipeline和ChannelPipeline" class="headerlink" title="6，Pipeline和ChannelPipeline"></a>6，Pipeline和ChannelPipeline</h4><ul>
<li><p>ChannelPipeline是一个重点：</p>
<ul>
<li><p>ChannelPipeline是一个Handler的集合，它负责处理和拦截inbound或者outbound的事件和操作，相当于一个贯穿Netty的链。（也可以这样理解：ChannelPipeline是保存ChannelHandler的List，用于处理或拦截Channel的入站时间和出站事件）</p>
</li>
<li><p>ChannelPipeline实现了一个高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及Channel中各个的ChannelHandler如何相互交互</p>
</li>
<li><p>在Netty中每个Channel都有且仅有一个ChannelPipeline与之对应，他们的组成关系如下：</p>
<p><img src="/2021/07/16/netty/40.png" alt="image-20210720203831363"></p>
<ul>
<li>一个Channel包含了一个ChannelPipeline，而ChannelPipeline中又维护了一个由ChannelHandlerContext组成的双向链表，并且每个ChannelHnadlerContext中又关联着一个ChannelHandler</li>
<li>入站事件和出站事件在一个双向链表中，入站事件会从链表head往后传递到最后一个入站的handler，出站事件会从链表tail往前传递到最前一个出站的handler，两种类型的handler互不干扰</li>
</ul>
</li>
</ul>
</li>
<li><p>常用方法：</p>
<ul>
<li><code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>：把一个业务处理类（handler）添加到链中的第一个位置</li>
<li><code>ChannelPipeline addLast(ChannelHandler... handlers)</code>：把一个业务处理类（handler）添加到链中的最后一个位置</li>
</ul>
</li>
</ul>
<h4 id="7，ChannelHandlerContext"><a href="#7，ChannelHandlerContext" class="headerlink" title="7，ChannelHandlerContext"></a>7，ChannelHandlerContext</h4><ul>
<li>保存Channel相关的所有上下文信息，同时关联一个ChannelHandler对象</li>
<li>即ChannelHandlerContext中包含一个具体的事件处理器ChannelHandler，同时ChannelHandlerContext中也绑定了对应的pipeline和Channel的信息，方便对ChannnelHandler进行调用</li>
<li>常用方法：<ul>
<li><code>ChannelFuture close()</code>：关闭通道</li>
<li><code>ChannelOutboundInvoker flush()</code>：刷新</li>
<li><code>ChannelFuture writeAndFlush(Object msg)</code>：将数据写到ChannelPipeline中当前</li>
<li><code>ChannelHandler</code>的下一个<code>ChannelHandler</code>开始处理（出站）</li>
</ul>
</li>
</ul>
<h4 id="8，ChannelOption"><a href="#8，ChannelOption" class="headerlink" title="8，ChannelOption"></a>8，ChannelOption</h4><ul>
<li>Netty在创建Channel实例后，一般都需要设置ChannelOption参数</li>
<li>ChannelOption参数如下：<ul>
<li><code>ChannelOption.SO_BACKLOG</code><ul>
<li>对应TCP/IP协议listen函数中的backlog参数，用来初始化服务器可连接队列大小。服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backing参数指定了队列的大小</li>
</ul>
</li>
<li><code>ChannelOption.SO_KEEPALIVE</code><ul>
<li>一直保持连接活动状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9，EventLoopGroup和其实现类NioEventLoopGroup"><a href="#9，EventLoopGroup和其实现类NioEventLoopGroup" class="headerlink" title="9，EventLoopGroup和其实现类NioEventLoopGroup"></a>9，EventLoopGroup和其实现类NioEventLoopGroup</h4><ul>
<li><p>EventLoopGroup是一组EventLoop的抽闲，Netty为了更好的利用多核CPU资源，一般会有多个EvenetLooop同时工作，每个EventLoop维护着一个Selector实例</p>
</li>
<li><p>EventLoopGroup提供next接口，可以从组里面按照一定规则获取其中一个EventLoop来处理任务，在Netty服务器端编程中，我们一般都需要提供两个EventLoopGroup，例如：<code>BpssEventLoopGroup</code>和<code>WorkerEventLoopGroup</code></p>
</li>
<li><p>通常一个服务端口即一个<code>ServerSocketChannel</code>对应一个Selector和一个EventLoop线程。BossEventLoop负责接收客户端的连接并将<code>SocketChannel</code>交给<code>WorkerEventLoopGroup</code>来进行IO处理，如下图所示：</p>
<p><img src="/2021/07/16/netty/41.png" alt="image-20210720221900537"></p>
</li>
<li><p>常用方法：</p>
<ul>
<li><code>public NioEventLoopGroup()</code>：构造方法</li>
<li><code>public Future&lt;?&gt; shutdownGracefully()</code>：断开连接，关闭线程</li>
</ul>
</li>
</ul>
<h4 id="10，Unpooled类"><a href="#10，Unpooled类" class="headerlink" title="10，Unpooled类"></a>10，Unpooled类</h4><ul>
<li><p>Netty提供一个专门用来操作缓冲区（即Netty的数据容器）的工具类</p>
</li>
<li><p>常用方法如下所示：</p>
<ul>
<li><code>public static ByteBuf copiedBuffer(CharSequence string,Charset charset)</code>：通过给定的数据和字符编码返回一个ByteBuf对象（类似于NIO中的ByteBuffer但有区别）</li>
</ul>
</li>
<li><p>举例说明：Unpooled获取Netty的数据容器ByteBuf的基本使用</p>
<p><img src="/2021/07/16/netty/42.png" alt="image-20210720222229496"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyByteBuf01</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//创建一个ByteBuf        //说明        //1. 创建 对象，该对象包含一个数组arr , 是一个byte[10]        //2. 在netty 的buffer中，不需要使用flip 进行反转        //   底层维护了 readerindex 和 writerIndex        //3. 通过 readerindex 和  writerIndex 和  capacity， 将buffer分成三个区域        // 0---readerindex 已经读取的区域        // readerindex---writerIndex ， 可读的区域        // writerIndex -- capacity, 可写的区域        ByteBuf buffer = Unpooled.buffer(10);        for(int i = 0; i &lt; 10; i++) &#123;            buffer.writeByte(i);        &#125;        System.out.println("capacity=" + buffer.capacity());//10        //输出//        for(int i = 0; i&lt;buffer.capacity(); i++) &#123;//            System.out.println(buffer.getByte(i));//        &#125;        for(int i = 0; i &lt; buffer.capacity(); i++) &#123;            System.out.println(buffer.readByte());        &#125;        System.out.println("执行完毕");    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyByteBuf02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ByteBuf</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">"hello,world!"</span>, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用相关的方法</span></span><br><span class="line">        <span class="keyword">if</span>(byteBuf.hasArray()) &#123; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] content = byteBuf.array();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将 content 转成字符串</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(content, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"byteBuf="</span> + byteBuf);</span><br><span class="line"></span><br><span class="line">            System.out.println(byteBuf.arrayOffset()); <span class="comment">// 0</span></span><br><span class="line">            System.out.println(byteBuf.readerIndex()); <span class="comment">// 0</span></span><br><span class="line">            System.out.println(byteBuf.writerIndex()); <span class="comment">// 12</span></span><br><span class="line">            System.out.println(byteBuf.capacity()); <span class="comment">// 36</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.out.println(byteBuf.readByte()); //</span></span><br><span class="line">            System.out.println(byteBuf.getByte(<span class="number">0</span>)); <span class="comment">// 104</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = byteBuf.readableBytes(); <span class="comment">//可读的字节数  12</span></span><br><span class="line">            System.out.println(<span class="string">"len="</span> + len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用for取出各个字节</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>) byteBuf.getByte(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按照某个范围读取</span></span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">0</span>, <span class="number">4</span>, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">4</span>, <span class="number">6</span>, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="11，Netty应用实例——群聊系统"><a href="#11，Netty应用实例——群聊系统" class="headerlink" title="11，Netty应用实例——群聊系统"></a>11，Netty应用实例——群聊系统</h4><ul>
<li><p>实例要求：</p>
<ul>
<li>编写一个Netty群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过channel可以无阻塞发送消息给其他所有用户，同时可以接受其他用户发送的消息（有服务器转发得到）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port; <span class="comment">//监听端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写run方法，处理客户端的请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 128)</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//获取到pipeline</span></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//向pipeline加入解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">//向pipeline加入编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            <span class="comment">//加入自己的业务处理handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatServerHandler());</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"netty 服务器启动"</span>);</span><br><span class="line">            ChannelFuture channelFuture = b.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> GroupChatServer(<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static List&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个hashmap 管理</span></span><br><span class="line">    <span class="comment">//public static Map&lt;String, Channel&gt; channels = new HashMap&lt;String,Channel&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个channle 组，管理所有的channel</span></span><br><span class="line">    <span class="comment">//GlobalEventExecutor.INSTANCE) 是全局的事件执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup  channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//handlerAdded 表示连接建立，一旦连接，第一个被执行</span></span><br><span class="line">    <span class="comment">//将当前channel 加入到  channelGroup</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//将该客户加入聊天的信息推送给其它在线的客户端</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        该方法会将 channelGroup 中所有的channel 遍历，并发送 消息，</span></span><br><span class="line"><span class="comment">        我们不需要自己遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() + <span class="string">" 加入聊天"</span> + sdf.format(<span class="keyword">new</span> java.util.Date()) + <span class="string">" \n"</span>);</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//断开连接, 将xx客户离开信息推送给当前在线的客户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() + <span class="string">" 离开了\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"channelGroup size"</span> + channelGroup.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示channel 处于活动状态, 提示 xx上线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">" 上线了~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示channel 处于不活动状态, 提示 xx离线了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">" 离线了~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到当前channel</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//这时我们遍历channelGroup, 根据不同的情况，回送不同的消息</span></span><br><span class="line"></span><br><span class="line">        channelGroup.forEach(ch -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(channel != ch) &#123; <span class="comment">//不是当前的channel,转发消息</span></span><br><span class="line">                ch.writeAndFlush(<span class="string">"[客户]"</span> + channel.remoteAddress() + <span class="string">" 发送了消息"</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//回显自己发送的消息给自己</span></span><br><span class="line">                ch.writeAndFlush(<span class="string">"[自己]发送了消息"</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//得到pipeline</span></span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        <span class="comment">//加入相关handler</span></span><br><span class="line">                        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                        <span class="comment">//加入自定义的handler</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">        <span class="comment">//得到channel</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">"-------"</span> + channel.localAddress()+ <span class="string">"--------"</span>);</span><br><span class="line">            <span class="comment">//客户端需要输入信息，创建一个扫描器</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="comment">//通过channel 发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">"127.0.0.1"</span>, <span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="12，Netty心跳检测机制案例"><a href="#12，Netty心跳检测机制案例" class="headerlink" title="12，Netty心跳检测机制案例"></a>12，Netty心跳检测机制案例</h4><ul>
<li>实例要求：<ul>
<li>编写一个Netty心跳检测机制案例，当服务器超过3秒没有读时，就提示读空闲</li>
<li>当服务器超过5秒没有写操作时，就提示写空闲</li>
<li>实现当服务器超过7秒没有读或者写操作时，就提示读写空闲</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            serverBootstrap.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    <span class="comment">//加入一个netty 提供 IdleStateHandler</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    说明</span></span><br><span class="line"><span class="comment">                    1. IdleStateHandler 是netty 提供的处理空闲状态的处理器</span></span><br><span class="line"><span class="comment">                    2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                    3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                    4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    5. 文档说明</span></span><br><span class="line"><span class="comment">                    triggers an &#123;@link IdleStateEvent&#125; when a &#123;@link Channel&#125; has not performed</span></span><br><span class="line"><span class="comment"> * read, write, or both operation for a while.</span></span><br><span class="line"><span class="comment"> *                  6. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个handler去处理</span></span><br><span class="line"><span class="comment"> *                  通过调用(触发)下一个handler 的 userEventTiggered , 在该方法中去处理 IdleStateEvent(读空闲，写空闲，读写空闲)</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">7000</span>,<span class="number">7000</span>,<span class="number">10</span>, TimeUnit.SECONDS));</span><br><span class="line">                    <span class="comment">//加入一个对空闲检测进一步处理的handler(自定义)</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将  evt 向下转型 IdleStateEvent</span></span><br><span class="line">            IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state()) &#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                  eventType = <span class="string">"读空闲"</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">"写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">"读写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">"--超时时间--"</span> + eventType);</span><br><span class="line">            System.out.println(<span class="string">"服务器做相应处理.."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果发生空闲，我们关闭通道</span></span><br><span class="line">           <span class="comment">// ctx.channel().close();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将  evt 向下转型 IdleStateEvent</span></span><br><span class="line">            IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state()) &#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                  eventType = <span class="string">"读空闲"</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">"写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">"读写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">"--超时时间--"</span> + eventType);</span><br><span class="line">            System.out.println(<span class="string">"服务器做相应处理.."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果发生空闲，我们关闭通道</span></span><br><span class="line">           <span class="comment">// ctx.channel().close();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(System.nanoTime()); <span class="comment">//纳秒  10亿分之1</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(System.nanoTime());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13，Netty通过WebSocket编程实现服务器和客户端长连接"><a href="#13，Netty通过WebSocket编程实现服务器和客户端长连接" class="headerlink" title="13，Netty通过WebSocket编程实现服务器和客户端长连接"></a>13，Netty通过WebSocket编程实现服务器和客户端长连接</h4><ul>
<li>实例要求：<ul>
<li>Http协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接</li>
<li>要求：实现基于WebSocket的长连接的全双工的交互</li>
<li>改变Http协议多次请去的约束，实现了长连接了，服务器可以发送消息给浏览器</li>
<li>客户端浏览器和服务器端相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            serverBootstrap.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//因为基于http协议，使用http的编码和解码器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                    <span class="comment">//是以块方式写，添加ChunkedWriteHandler处理器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    说明</span></span><br><span class="line"><span class="comment">                    1. http数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span></span><br><span class="line"><span class="comment">                    2. 这就就是为什么，当浏览器发送大量数据时，就会发出多次http请求</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    说明</span></span><br><span class="line"><span class="comment">                    1. 对应websocket ，它的数据是以 帧(frame) 形式传递</span></span><br><span class="line"><span class="comment">                    2. 可以看到WebSocketFrame 下面有六个子类</span></span><br><span class="line"><span class="comment">                    3. 浏览器请求时 ws://localhost:7000/hello 表示请求的uri</span></span><br><span class="line"><span class="comment">                    4. WebSocketServerProtocolHandler 核心功能是将 http协议升级为 ws协议 , 保持长连接</span></span><br><span class="line"><span class="comment">                    5. 是通过一个 状态码 101</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">"/hello2"</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//自定义的handler ，处理业务逻辑</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> MyTextWebSocketFrameHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器收到消息 "</span> + msg.text());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">"服务器时间"</span> + LocalDateTime.now() + <span class="string">" "</span> + msg.text()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当web客户端连接后， 触发方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span></span><br><span class="line">        System.out.println(<span class="string">"handlerAdded 被调用"</span> + ctx.channel().id().asLongText());</span><br><span class="line">        System.out.println(<span class="string">"handlerAdded 被调用"</span> + ctx.channel().id().asShortText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"handlerRemoved 被调用"</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异常发生 "</span> + cause.getMessage());</span><br><span class="line">        ctx.close(); <span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> socket;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//判断当前浏览器是否支持websocket</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="built_in">window</span>.WebSocket) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//go on</span></span></span><br><span class="line"><span class="actionscript">        socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:7000/hello2"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//相当于channelReado, ev 收到服务器端回送的消息</span></span></span><br><span class="line"><span class="actionscript">        socket.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(ev)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> rt = <span class="built_in">document</span>.getElementById(<span class="string">"responseText"</span>);</span></span><br><span class="line"><span class="actionscript">            rt.value = rt.value + <span class="string">"\n"</span> + ev.data;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">//相当于连接开启(感知到连接开启)</span></span></span><br><span class="line"><span class="actionscript">        socket.onopen = <span class="function"><span class="keyword">function</span> <span class="params">(ev)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> rt = <span class="built_in">document</span>.getElementById(<span class="string">"responseText"</span>);</span></span><br><span class="line"><span class="actionscript">            rt.value = <span class="string">"连接开启了.."</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">//相当于连接关闭(感知到连接关闭)</span></span></span><br><span class="line"><span class="actionscript">        socket.onclose = <span class="function"><span class="keyword">function</span> <span class="params">(ev)</span> </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> rt = <span class="built_in">document</span>.getElementById(<span class="string">"responseText"</span>);</span></span><br><span class="line"><span class="actionscript">            rt.value = rt.value + <span class="string">"\n"</span> + <span class="string">"连接关闭了.."</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"当前浏览器不支持websocket"</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//发送消息到服务器</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(message)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(!<span class="built_in">window</span>.socket) &#123; <span class="comment">//先判断socket是否创建好</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if(socket.readyState == WebSocket.OPEN) &#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">//通过socket 发送消息</span></span></span><br><span class="line">            socket.send(message)</span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"连接没有开启"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">"return false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">style</span>=<span class="string">"height: 300px; width: 300px"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"发生消息"</span> <span class="attr">onclick</span>=<span class="string">"send(this.form.message.value)"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"responseText"</span> <span class="attr">style</span>=<span class="string">"height: 300px; width: 300px"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"清空内容"</span> <span class="attr">onclick</span>=<span class="string">"document.getElementById('responseText').value=''"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="六，Google-Protobuf"><a href="#六，Google-Protobuf" class="headerlink" title="六，Google Protobuf"></a>六，Google Protobuf</h3><h4 id="1，编码和解码的基本介绍"><a href="#1，编码和解码的基本介绍" class="headerlink" title="1，编码和解码的基本介绍"></a>1，编码和解码的基本介绍</h4><ul>
<li><p>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码</p>
<p><img src="/2021/07/16/netty/43.png" alt="image-20210722001031250"></p>
<ul>
<li>codec（编解码器）的组成部分有两个：decoder(解码器)和encoder（编码器）。encoder负责把业务数据转换成字节码数据，decoder负责把字节码数据转换成业务数据</li>
</ul>
</li>
</ul>
<h4 id="2，Netty本身的编码和解码的机制和问题分析"><a href="#2，Netty本身的编码和解码的机制和问题分析" class="headerlink" title="2，Netty本身的编码和解码的机制和问题分析"></a>2，Netty本身的编码和解码的机制和问题分析</h4><ul>
<li>Netty自身提供了一些codec（编解码器）</li>
<li>Netty提供的编码器<ul>
<li><code>StringEncoder</code>：对字符串数据进行编码</li>
<li><code>ObjectEncoder</code>：对Java对象进行编码</li>
</ul>
</li>
<li>Netty提供的解码器：<ul>
<li><code>StringDecoder</code>：对字符串数据进行解码</li>
<li><code>ObjectDecoder</code>：对Java对象进行解码</li>
</ul>
</li>
<li>Netty本身自带的ObjectDecoder和ObjectEncoder可以用来实现POJO对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术，而Java序列化技术本身效率就不高，存在如下问题：<ul>
<li>无法跨语言</li>
<li>序列化后的体积太大，是二进制编码的5倍多</li>
<li>序列化性能太低</li>
</ul>
</li>
<li>——》引出新的解决方案【Google Protobuf】</li>
</ul>
<h4 id="3，Protobuf基本介绍"><a href="#3，Protobuf基本介绍" class="headerlink" title="3，Protobuf基本介绍"></a>3，Protobuf基本介绍</h4><ul>
<li><p>Protobuf是Google发布的开源项目，全称是Google Protocol Buffers，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或RPC【远程过程调用   remote procedure call】数据交换格式</p>
<p>目前很多公司是 http+json   tcp+protobuf</p>
</li>
<li><p><a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">参考文档</a></p>
</li>
<li><p>Protobuf是以message的方式来管理数据的</p>
</li>
<li><p>支持跨平台，跨语言</p>
</li>
<li><p>高性能，高可靠性</p>
</li>
<li><p>使用protobuf编译器能自动生成代码，Protobuf是将类的定义使用.proto文件进行描述。说明，在IDEA中编写.proto文件时，会自动提示是否下载.proto编写插件，可以让语法高亮</p>
</li>
<li><p>通过protoc.exe编译器根据.proto自动生成Java文件</p>
</li>
<li><p>protobuf使用示意图</p>
<p><img src="/2021/07/16/netty/44.png" alt="image-20210722002850826"></p>
</li>
</ul>
<h4 id="4，Protobuf快速入门实例："><a href="#4，Protobuf快速入门实例：" class="headerlink" title="4，Protobuf快速入门实例："></a>4，Protobuf快速入门实例：</h4><ul>
<li><p>编写程序，使用Protobuf完成如下功能</p>
<ul>
<li>客户端可以发送一个Student PoJo对象到服务器（通过Protobuf编码）</li>
<li>服务端能接受Student PoJo对象，并显示信息（通过Protobuf解码）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>; <span class="comment">//版本</span></span><br><span class="line">option java_outer_classname = <span class="string">"StudentPOJO"</span>;<span class="comment">//生成的外部类名，同时也是文件名</span></span><br><span class="line"><span class="comment">//protobuf 使用message 管理数据</span></span><br><span class="line">message Student &#123; <span class="comment">//会在 StudentPOJO 外部类生成一个内部类 Student， 他是真正发送的POJO对象</span></span><br><span class="line">    int32 id = <span class="number">1</span>; <span class="comment">// Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span></span><br><span class="line">    string name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentPOJO</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">StudentPOJO</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAllExtensions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      com.google.protobuf.ExtensionRegistryLite registry)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAllExtensions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      com.google.protobuf.ExtensionRegistry registry)</span> </span>&#123;</span><br><span class="line">    registerAllExtensions(</span><br><span class="line">        (com.google.protobuf.ExtensionRegistryLite) registry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentOrBuilder</span> <span class="keyword">extends</span></span></span><br><span class="line">      // @@protoc_insertion_point(interface_extends:Student)</span><br><span class="line">      com.google.protobuf.MessageOrBuilder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     * Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;int32 id = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    com.google.protobuf.ByteString</span><br><span class="line">        getNameBytes();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">   *protobuf 使用message 管理数据</span></span><br><span class="line"><span class="comment">   * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Protobuf type &#123;<span class="doctag">@code</span> Student&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">      <span class="title">com</span>.<span class="title">google</span>.<span class="title">protobuf</span>.<span class="title">GeneratedMessageV3</span> <span class="keyword">implements</span></span></span><br><span class="line">      // @@protoc_insertion_point(message_implements:Student)</span><br><span class="line">      StudentOrBuilder &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// Use Student.newBuilder() to construct.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(com.google.protobuf.GeneratedMessageV3.Builder&lt;?&gt; builder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      id_ = <span class="number">0</span>;</span><br><span class="line">      name_ = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> com.google.protobuf.UnknownFieldSet</span><br><span class="line">    getUnknownFields() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.unknownFields;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>();</span><br><span class="line">      <span class="keyword">if</span> (extensionRegistry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> mutable_bitField0_ = <span class="number">0</span>;</span><br><span class="line">      com.google.protobuf.UnknownFieldSet.Builder unknownFields =</span><br><span class="line">          com.google.protobuf.UnknownFieldSet.newBuilder();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">          <span class="keyword">int</span> tag = input.readTag();</span><br><span class="line">          <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              done = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>: &#123;</span><br><span class="line"></span><br><span class="line">              id_ = input.readInt32();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">18</span>: &#123;</span><br><span class="line">              String s = input.readStringRequireUtf8();</span><br><span class="line"></span><br><span class="line">              name_ = s;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">              <span class="keyword">if</span> (!parseUnknownFieldProto3(</span><br><span class="line">                  input, unknownFields, extensionRegistry, tag)) &#123;</span><br><span class="line">                done = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (com.google.protobuf.InvalidProtocolBufferException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.setUnfinishedMessage(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> com.google.protobuf.InvalidProtocolBufferException(</span><br><span class="line">            e).setUnfinishedMessage(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.unknownFields = unknownFields.build();</span><br><span class="line">        makeExtensionsImmutable();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">        getDescriptor() &#123;</span><br><span class="line">      <span class="keyword">return</span> StudentPOJO.internal_static_Student_descriptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> FieldAccessorTable</span><br><span class="line">        internalGetFieldAccessorTable() &#123;</span><br><span class="line">      <span class="keyword">return</span> StudentPOJO.internal_static_Student_fieldAccessorTable</span><br><span class="line">          .ensureFieldAccessorsInitialized(</span><br><span class="line">              Student<span class="class">.<span class="keyword">class</span>, <span class="title">Builder</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ID_FIELD_NUMBER = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id_;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     * Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;int32 id = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NAME_FIELD_NUMBER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object name_;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Object ref = name_;</span><br><span class="line">      <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) ref;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        com.google.protobuf.ByteString bs = </span><br><span class="line">            (com.google.protobuf.ByteString) ref;</span><br><span class="line">        String s = bs.toStringUtf8();</span><br><span class="line">        name_ = s;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> com.google.protobuf.ByteString</span><br><span class="line">        getNameBytes() &#123;</span><br><span class="line">      Object ref = name_;</span><br><span class="line">      <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        com.google.protobuf.ByteString b = </span><br><span class="line">            com.google.protobuf.ByteString.copyFromUtf8(</span><br><span class="line">                (String) ref);</span><br><span class="line">        name_ = b;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (com.google.protobuf.ByteString) ref;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> memoizedIsInitialized = -<span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span> isInitialized = memoizedIsInitialized;</span><br><span class="line">      <span class="keyword">if</span> (isInitialized == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (isInitialized == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      memoizedIsInitialized = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(com.google.protobuf.CodedOutputStream output)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (id_ != <span class="number">0</span>) &#123;</span><br><span class="line">        output.writeInt32(<span class="number">1</span>, id_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!getNameBytes().isEmpty()) &#123;</span><br><span class="line">        com.google.protobuf.GeneratedMessageV3.writeString(output, <span class="number">2</span>, name_);</span><br><span class="line">      &#125;</span><br><span class="line">      unknownFields.writeTo(output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSerializedSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> size = memoizedSize;</span><br><span class="line">      <span class="keyword">if</span> (size != -<span class="number">1</span>) <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (id_ != <span class="number">0</span>) &#123;</span><br><span class="line">        size += com.google.protobuf.CodedOutputStream</span><br><span class="line">          .computeInt32Size(<span class="number">1</span>, id_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!getNameBytes().isEmpty()) &#123;</span><br><span class="line">        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(<span class="number">2</span>, name_);</span><br><span class="line">      &#125;</span><br><span class="line">      size += unknownFields.getSerializedSize();</span><br><span class="line">      memoizedSize = size;</span><br><span class="line">      <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object obj)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (obj == <span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Student)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj);</span><br><span class="line">      &#125;</span><br><span class="line">      Student other = (Student) obj;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">      result = result &amp;&amp; (getId()</span><br><span class="line">          == other.getId());</span><br><span class="line">      result = result &amp;&amp; getName()</span><br><span class="line">          .equals(other.getName());</span><br><span class="line">      result = result &amp;&amp; unknownFields.equals(other.unknownFields);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (memoizedHashCode != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memoizedHashCode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> hash = <span class="number">41</span>;</span><br><span class="line">      hash = (<span class="number">19</span> * hash) + getDescriptor().hashCode();</span><br><span class="line">      hash = (<span class="number">37</span> * hash) + ID_FIELD_NUMBER;</span><br><span class="line">      hash = (<span class="number">53</span> * hash) + getId();</span><br><span class="line">      hash = (<span class="number">37</span> * hash) + NAME_FIELD_NUMBER;</span><br><span class="line">      hash = (<span class="number">53</span> * hash) + getName().hashCode();</span><br><span class="line">      hash = (<span class="number">29</span> * hash) + unknownFields.hashCode();</span><br><span class="line">      memoizedHashCode = hash;</span><br><span class="line">      <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.nio.ByteBuffer data)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.nio.ByteBuffer data,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ByteString data)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ByteString data,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">byte</span>[] data,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(java.io.InputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.io.InputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseDelimitedFrom</span><span class="params">(java.io.InputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseDelimitedWithIOException(PARSER, input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseDelimitedFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.io.InputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.CodedInputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">newBuilderForType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> newBuilder(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">newBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE.toBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">newBuilder</span><span class="params">(Student prototype)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">toBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span> == DEFAULT_INSTANCE</span><br><span class="line">          ? <span class="keyword">new</span> Builder() : <span class="keyword">new</span> Builder().mergeFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Builder <span class="title">newBuilderForType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BuilderParent parent)</span> </span>&#123;</span><br><span class="line">      Builder builder = <span class="keyword">new</span> Builder(parent);</span><br><span class="line">      <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *protobuf 使用message 管理数据</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Protobuf type &#123;<span class="doctag">@code</span> Student&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">com</span>.<span class="title">google</span>.<span class="title">protobuf</span>.<span class="title">GeneratedMessageV3</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line">        // @@protoc_insertion_point(builder_implements:Student)</span><br><span class="line">        StudentOrBuilder &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">          getDescriptor() &#123;</span><br><span class="line">        <span class="keyword">return</span> StudentPOJO.internal_static_Student_descriptor;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> FieldAccessorTable</span><br><span class="line">          internalGetFieldAccessorTable() &#123;</span><br><span class="line">        <span class="keyword">return</span> StudentPOJO.internal_static_Student_fieldAccessorTable</span><br><span class="line">            .ensureFieldAccessorsInitialized(</span><br><span class="line">                Student<span class="class">.<span class="keyword">class</span>, <span class="title">Builder</span>.<span class="title">class</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Construct using StudentPOJO.Student.newBuilder()</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        maybeForceBuilderInitialization();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          BuilderParent parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        maybeForceBuilderInitialization();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeForceBuilderInitialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (com.google.protobuf.GeneratedMessageV3</span><br><span class="line">                .alwaysUseFieldBuilders) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.clear();</span><br><span class="line">        id_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        name_ = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">          getDescriptorForType() &#123;</span><br><span class="line">        <span class="keyword">return</span> StudentPOJO.internal_static_Student_descriptor;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Student <span class="title">getDefaultInstanceForType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Student.getDefaultInstance();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Student <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student result = buildPartial();</span><br><span class="line">        <span class="keyword">if</span> (!result.isInitialized()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> newUninitializedMessageException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Student <span class="title">buildPartial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student result = <span class="keyword">new</span> Student(<span class="keyword">this</span>);</span><br><span class="line">        result.id_ = id_;</span><br><span class="line">        result.name_ = name_;</span><br><span class="line">        onBuilt();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.clone();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field,</span></span></span><br><span class="line"><span class="function"><span class="params">          Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.setField(field, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.clearField(field);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearOneof</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.OneofDescriptor oneof)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.clearOneof(oneof);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setRepeatedField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.setRepeatedField(field, index, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">addRepeatedField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field,</span></span></span><br><span class="line"><span class="function"><span class="params">          Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.addRepeatedField(field, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeFrom</span><span class="params">(com.google.protobuf.Message other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">          <span class="keyword">return</span> mergeFrom((Student)other);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">super</span>.mergeFrom(other);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeFrom</span><span class="params">(Student other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other == Student.getDefaultInstance()) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (other.getId() != <span class="number">0</span>) &#123;</span><br><span class="line">          setId(other.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!other.getName().isEmpty()) &#123;</span><br><span class="line">          name_ = other.name_;</span><br><span class="line">          onChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.mergeUnknownFields(other.unknownFields);</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        Student parsedMessage = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (com.google.protobuf.InvalidProtocolBufferException e) &#123;</span><br><span class="line">          parsedMessage = (Student) e.getUnfinishedMessage();</span><br><span class="line">          <span class="keyword">throw</span> e.unwrapIOException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (parsedMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mergeFrom(parsedMessage);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> id_ ;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       * Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;int32 id = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       * Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;int32 id = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setId</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        id_ = value;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       * Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;int32 id = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        id_ = <span class="number">0</span>;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> Object name_ = <span class="string">""</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object ref = name_;</span><br><span class="line">        <span class="keyword">if</span> (!(ref <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">          com.google.protobuf.ByteString bs =</span><br><span class="line">              (com.google.protobuf.ByteString) ref;</span><br><span class="line">          String s = bs.toStringUtf8();</span><br><span class="line">          name_ = s;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (String) ref;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> com.google.protobuf.ByteString</span><br><span class="line">          getNameBytes() &#123;</span><br><span class="line">        Object ref = name_;</span><br><span class="line">        <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          com.google.protobuf.ByteString b = </span><br><span class="line">              com.google.protobuf.ByteString.copyFromUtf8(</span><br><span class="line">                  (String) ref);</span><br><span class="line">          name_ = b;</span><br><span class="line">          <span class="keyword">return</span> b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (com.google.protobuf.ByteString) ref;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">        name_ = value;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        name_ = getDefaultInstance().getName();</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setNameBytes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.ByteString value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125;</span><br><span class="line">  checkByteStringIsUtf8(value);</span><br><span class="line">        </span><br><span class="line">        name_ = value;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Builder <span class="title">setUnknownFields</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> com.google.protobuf.UnknownFieldSet unknownFields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.setUnknownFieldsProto3(unknownFields);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Builder <span class="title">mergeUnknownFields</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> com.google.protobuf.UnknownFieldSet unknownFields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.mergeUnknownFields(unknownFields);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// @@protoc_insertion_point(builder_scope:Student)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @@protoc_insertion_point(class_scope:Student)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Student DEFAULT_INSTANCE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      DEFAULT_INSTANCE = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">getDefaultInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Parser&lt;Student&gt;</span><br><span class="line">        PARSER = <span class="keyword">new</span> com.google.protobuf.AbstractParser&lt;Student&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Student <span class="title">parsePartialFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(input, extensionRegistry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.google.protobuf.<span class="function">Parser&lt;Student&gt; <span class="title">parser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> com.google.protobuf.<span class="function">Parser&lt;Student&gt; <span class="title">getParserForType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getDefaultInstanceForType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">    internal_static_Student_descriptor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> </span><br><span class="line">    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable</span><br><span class="line">      internal_static_Student_fieldAccessorTable;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.google.protobuf.Descriptors.FileDescriptor</span><br><span class="line">      getDescriptor() &#123;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span>  com.google.protobuf.Descriptors.FileDescriptor</span><br><span class="line">      descriptor;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    String[] descriptorData = &#123;</span><br><span class="line">      <span class="string">"\n\rStudent.proto\"#\n\007Student\022\n\n\002id\030\001 \001(\005\022\014"</span> +</span><br><span class="line">      <span class="string">"\n\004name\030\002 \001(\tB\rB\013StudentPOJOb\006proto3"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =</span><br><span class="line">        <span class="keyword">new</span> com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() &#123;</span><br><span class="line">          <span class="keyword">public</span> com.google.protobuf.<span class="function">ExtensionRegistry <span class="title">assignDescriptors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">              com.google.protobuf.Descriptors.FileDescriptor root)</span> </span>&#123;</span><br><span class="line">            descriptor = root;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    com.google.protobuf.Descriptors.FileDescriptor</span><br><span class="line">      .internalBuildGeneratedFileFrom(descriptorData,</span><br><span class="line">        <span class="keyword">new</span> com.google.protobuf.Descriptors.FileDescriptor[] &#123;</span><br><span class="line">        &#125;, assigner);</span><br><span class="line">    internal_static_Student_descriptor =</span><br><span class="line">      getDescriptor().getMessageTypes().get(<span class="number">0</span>);</span><br><span class="line">    internal_static_Student_fieldAccessorTable = <span class="keyword">new</span></span><br><span class="line">      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(</span><br><span class="line">        internal_static_Student_descriptor,</span><br><span class="line">        <span class="keyword">new</span> String[] &#123; <span class="string">"Id"</span>, <span class="string">"Name"</span>, &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @@protoc_insertion_point(outer_class_scope)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建BossGroup 和 WorkerGroup</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span></span><br><span class="line">        <span class="comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span></span><br><span class="line">        <span class="comment">//3. 两个都是无限循环</span></span><br><span class="line">        <span class="comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span></span><br><span class="line">        <span class="comment">//   默认实际 cpu核数 * 2</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>) //使用<span class="title">NioSocketChannel</span> 作为服务器的通道实现</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 128) // 设置线程队列得到连接个数</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>) //设置保持活动连接状态</span></span><br><span class="line"><span class="class">//                    .<span class="title">handler</span>(<span class="title">null</span>) // 该 <span class="title">handler</span>对应 <span class="title">bossGroup</span> , <span class="title">childHandler</span> 对应 <span class="title">workerGroup</span></span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;<span class="comment">//创建一个通道初始化对象(匿名对象)</span></span><br><span class="line">                        <span class="comment">//给pipeline 设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline加入ProtoBufDecoder</span></span><br><span class="line">                            <span class="comment">//指定对哪种对象进行解码</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ProtobufDecoder(StudentPOJO.Student.getDefaultInstance()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">".....服务器 is ready..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span></span><br><span class="line">            <span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给cf 注册监听器，监控我们关心的事件</span></span><br><span class="line"></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cf.isSuccess()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"监听端口 6668 成功"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"监听端口 6668 失败"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span></span><br><span class="line"><span class="comment">2. 这时我们自定义一个Handler , 才能称为一个handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">StudentPOJO</span>.<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">    2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, StudentPOJO.Student msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取从客户端发送的StudentPojo.Student</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"客户端发送的数据 id="</span> + msg.getId() + <span class="string">" 名字="</span> + msg.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    //读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line"><span class="comment">//    /*</span></span><br><span class="line"><span class="comment">//    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">//    2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">//     */</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //读取从客户端发送的StudentPojo.Student</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        StudentPOJO.Student student = (StudentPOJO.Student) msg;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println("客户端发送的数据 id=" + student.getId() + " 名字=" + student.getName());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello, 客户端~(&gt;^ω^&lt;)喵1"</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常, 一般是需要关闭通道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>) // 设置客户端通道的实现类(反射)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline中加入 ProtoBufEncoder</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyClientHandler()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"客户端 ok.."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道就绪就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发生一个Student 对象到服务器</span></span><br><span class="line"></span><br><span class="line">        StudentPOJO.Student student = StudentPOJO.Student.newBuilder().setId(<span class="number">4</span>).setName(<span class="string">"智多星 吴用"</span>).build();</span><br><span class="line">        <span class="comment">//Teacher , Member ,Message</span></span><br><span class="line">        ctx.writeAndFlush(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道有读取事件时，会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"服务器回复的消息:"</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"服务器的地址： "</span>+ ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h4 id="5，Protobuf快速入门实例2️⃣"><a href="#5，Protobuf快速入门实例2️⃣" class="headerlink" title="5，Protobuf快速入门实例2️⃣"></a>5，Protobuf快速入门实例2️⃣</h4><ul>
<li><p>编写程序，使用Protobuf完成如下功能：</p>
<ul>
<li>客户端可以随机发送Student POJO/Worker POJO对象到服务器（通过Protobuf编码）</li>
<li>服务器能接受Student POJO/Worker POJO对象（需要判断是哪种类型），并显示信息（通过Protobuf解码）</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">option</span> optimize_for = SPEED; <span class="comment">// 加快解析</span></span><br><span class="line"><span class="keyword">option</span> java_package=<span class="string">"com.atguigu.netty.codec2"</span>;   <span class="comment">//指定生成到哪个包下</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname=<span class="string">"MyDataInfo"</span>; <span class="comment">// 外部类名, 文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//protobuf 可以使用message 管理其他的message</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个枚举类型</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DataType</span> </span>&#123;</span><br><span class="line">        StudentType = <span class="number">0</span>; <span class="comment">//在proto3 要求enum的编号从0开始</span></span><br><span class="line">        WorkerType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用data_type 来标识传的是哪一个枚举类型</span></span><br><span class="line">    DataType data_type = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示每次枚举类型最多只能出现其中的一个, 节省空间</span></span><br><span class="line">    <span class="keyword">oneof</span> dataBody &#123;</span><br><span class="line">        Student student = <span class="number">2</span>;</span><br><span class="line">        Worker worker = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int32</span> id = <span class="number">1</span>;<span class="comment">//Student类的属性</span></span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int32</span> age=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br><span class="line">1947</span><br><span class="line">1948</span><br><span class="line">1949</span><br><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br><span class="line">1990</span><br><span class="line">1991</span><br><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br><span class="line">2033</span><br><span class="line">2034</span><br><span class="line">2035</span><br><span class="line">2036</span><br><span class="line">2037</span><br><span class="line">2038</span><br><span class="line">2039</span><br><span class="line">2040</span><br><span class="line">2041</span><br><span class="line">2042</span><br><span class="line">2043</span><br><span class="line">2044</span><br><span class="line">2045</span><br><span class="line">2046</span><br><span class="line">2047</span><br><span class="line">2048</span><br><span class="line">2049</span><br><span class="line">2050</span><br><span class="line">2051</span><br><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br><span class="line">2056</span><br><span class="line">2057</span><br><span class="line">2058</span><br><span class="line">2059</span><br><span class="line">2060</span><br><span class="line">2061</span><br><span class="line">2062</span><br><span class="line">2063</span><br><span class="line">2064</span><br><span class="line">2065</span><br><span class="line">2066</span><br><span class="line">2067</span><br><span class="line">2068</span><br><span class="line">2069</span><br><span class="line">2070</span><br><span class="line">2071</span><br><span class="line">2072</span><br><span class="line">2073</span><br><span class="line">2074</span><br><span class="line">2075</span><br><span class="line">2076</span><br><span class="line">2077</span><br><span class="line">2078</span><br><span class="line">2079</span><br><span class="line">2080</span><br><span class="line">2081</span><br><span class="line">2082</span><br><span class="line">2083</span><br><span class="line">2084</span><br><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br><span class="line">2088</span><br><span class="line">2089</span><br><span class="line">2090</span><br><span class="line">2091</span><br><span class="line">2092</span><br><span class="line">2093</span><br><span class="line">2094</span><br><span class="line">2095</span><br><span class="line">2096</span><br><span class="line">2097</span><br><span class="line">2098</span><br><span class="line">2099</span><br><span class="line">2100</span><br><span class="line">2101</span><br><span class="line">2102</span><br><span class="line">2103</span><br><span class="line">2104</span><br><span class="line">2105</span><br><span class="line">2106</span><br><span class="line">2107</span><br><span class="line">2108</span><br><span class="line">2109</span><br><span class="line">2110</span><br><span class="line">2111</span><br><span class="line">2112</span><br><span class="line">2113</span><br><span class="line">2114</span><br><span class="line">2115</span><br><span class="line">2116</span><br><span class="line">2117</span><br><span class="line">2118</span><br><span class="line">2119</span><br><span class="line">2120</span><br><span class="line">2121</span><br><span class="line">2122</span><br><span class="line">2123</span><br><span class="line">2124</span><br><span class="line">2125</span><br><span class="line">2126</span><br><span class="line">2127</span><br><span class="line">2128</span><br><span class="line">2129</span><br><span class="line">2130</span><br><span class="line">2131</span><br><span class="line">2132</span><br><span class="line">2133</span><br><span class="line">2134</span><br><span class="line">2135</span><br><span class="line">2136</span><br><span class="line">2137</span><br><span class="line">2138</span><br><span class="line">2139</span><br><span class="line">2140</span><br><span class="line">2141</span><br><span class="line">2142</span><br><span class="line">2143</span><br><span class="line">2144</span><br><span class="line">2145</span><br><span class="line">2146</span><br><span class="line">2147</span><br><span class="line">2148</span><br><span class="line">2149</span><br><span class="line">2150</span><br><span class="line">2151</span><br><span class="line">2152</span><br><span class="line">2153</span><br><span class="line">2154</span><br><span class="line">2155</span><br><span class="line">2156</span><br><span class="line">2157</span><br><span class="line">2158</span><br><span class="line">2159</span><br><span class="line">2160</span><br><span class="line">2161</span><br><span class="line">2162</span><br><span class="line">2163</span><br><span class="line">2164</span><br><span class="line">2165</span><br><span class="line">2166</span><br><span class="line">2167</span><br><span class="line">2168</span><br><span class="line">2169</span><br><span class="line">2170</span><br><span class="line">2171</span><br><span class="line">2172</span><br><span class="line">2173</span><br><span class="line">2174</span><br><span class="line">2175</span><br><span class="line">2176</span><br><span class="line">2177</span><br><span class="line">2178</span><br><span class="line">2179</span><br><span class="line">2180</span><br><span class="line">2181</span><br><span class="line">2182</span><br><span class="line">2183</span><br><span class="line">2184</span><br><span class="line">2185</span><br><span class="line">2186</span><br><span class="line">2187</span><br><span class="line">2188</span><br><span class="line">2189</span><br><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br><span class="line">2204</span><br><span class="line">2205</span><br><span class="line">2206</span><br><span class="line">2207</span><br><span class="line">2208</span><br><span class="line">2209</span><br><span class="line">2210</span><br><span class="line">2211</span><br><span class="line">2212</span><br><span class="line">2213</span><br><span class="line">2214</span><br><span class="line">2215</span><br><span class="line">2216</span><br><span class="line">2217</span><br><span class="line">2218</span><br><span class="line">2219</span><br><span class="line">2220</span><br><span class="line">2221</span><br><span class="line">2222</span><br><span class="line">2223</span><br><span class="line">2224</span><br><span class="line">2225</span><br><span class="line">2226</span><br><span class="line">2227</span><br><span class="line">2228</span><br><span class="line">2229</span><br><span class="line">2230</span><br><span class="line">2231</span><br><span class="line">2232</span><br><span class="line">2233</span><br><span class="line">2234</span><br><span class="line">2235</span><br><span class="line">2236</span><br><span class="line">2237</span><br><span class="line">2238</span><br><span class="line">2239</span><br><span class="line">2240</span><br><span class="line">2241</span><br><span class="line">2242</span><br><span class="line">2243</span><br><span class="line">2244</span><br><span class="line">2245</span><br><span class="line">2246</span><br><span class="line">2247</span><br><span class="line">2248</span><br><span class="line">2249</span><br><span class="line">2250</span><br><span class="line">2251</span><br><span class="line">2252</span><br><span class="line">2253</span><br><span class="line">2254</span><br><span class="line">2255</span><br><span class="line">2256</span><br><span class="line">2257</span><br><span class="line">2258</span><br><span class="line">2259</span><br><span class="line">2260</span><br><span class="line">2261</span><br><span class="line">2262</span><br><span class="line">2263</span><br><span class="line">2264</span><br><span class="line">2265</span><br><span class="line">2266</span><br><span class="line">2267</span><br><span class="line">2268</span><br><span class="line">2269</span><br><span class="line">2270</span><br><span class="line">2271</span><br><span class="line">2272</span><br><span class="line">2273</span><br><span class="line">2274</span><br><span class="line">2275</span><br><span class="line">2276</span><br><span class="line">2277</span><br><span class="line">2278</span><br><span class="line">2279</span><br><span class="line">2280</span><br><span class="line">2281</span><br><span class="line">2282</span><br><span class="line">2283</span><br><span class="line">2284</span><br><span class="line">2285</span><br><span class="line">2286</span><br><span class="line">2287</span><br><span class="line">2288</span><br><span class="line">2289</span><br><span class="line">2290</span><br><span class="line">2291</span><br><span class="line">2292</span><br><span class="line">2293</span><br><span class="line">2294</span><br><span class="line">2295</span><br><span class="line">2296</span><br><span class="line">2297</span><br><span class="line">2298</span><br><span class="line">2299</span><br><span class="line">2300</span><br><span class="line">2301</span><br><span class="line">2302</span><br><span class="line">2303</span><br><span class="line">2304</span><br><span class="line">2305</span><br><span class="line">2306</span><br><span class="line">2307</span><br><span class="line">2308</span><br><span class="line">2309</span><br><span class="line">2310</span><br><span class="line">2311</span><br><span class="line">2312</span><br><span class="line">2313</span><br><span class="line">2314</span><br><span class="line">2315</span><br><span class="line">2316</span><br><span class="line">2317</span><br><span class="line">2318</span><br><span class="line">2319</span><br><span class="line">2320</span><br><span class="line">2321</span><br><span class="line">2322</span><br><span class="line">2323</span><br><span class="line">2324</span><br><span class="line">2325</span><br><span class="line">2326</span><br><span class="line">2327</span><br><span class="line">2328</span><br><span class="line">2329</span><br><span class="line">2330</span><br><span class="line">2331</span><br><span class="line">2332</span><br><span class="line">2333</span><br><span class="line">2334</span><br><span class="line">2335</span><br><span class="line">2336</span><br><span class="line">2337</span><br><span class="line">2338</span><br><span class="line">2339</span><br><span class="line">2340</span><br><span class="line">2341</span><br><span class="line">2342</span><br><span class="line">2343</span><br><span class="line">2344</span><br><span class="line">2345</span><br><span class="line">2346</span><br><span class="line">2347</span><br><span class="line">2348</span><br><span class="line">2349</span><br><span class="line">2350</span><br><span class="line">2351</span><br><span class="line">2352</span><br><span class="line">2353</span><br><span class="line">2354</span><br><span class="line">2355</span><br><span class="line">2356</span><br><span class="line">2357</span><br><span class="line">2358</span><br><span class="line">2359</span><br><span class="line">2360</span><br><span class="line">2361</span><br><span class="line">2362</span><br><span class="line">2363</span><br><span class="line">2364</span><br><span class="line">2365</span><br><span class="line">2366</span><br><span class="line">2367</span><br><span class="line">2368</span><br><span class="line">2369</span><br><span class="line">2370</span><br><span class="line">2371</span><br><span class="line">2372</span><br><span class="line">2373</span><br><span class="line">2374</span><br><span class="line">2375</span><br><span class="line">2376</span><br><span class="line">2377</span><br><span class="line">2378</span><br><span class="line">2379</span><br><span class="line">2380</span><br><span class="line">2381</span><br><span class="line">2382</span><br><span class="line">2383</span><br><span class="line">2384</span><br><span class="line">2385</span><br><span class="line">2386</span><br><span class="line">2387</span><br><span class="line">2388</span><br><span class="line">2389</span><br><span class="line">2390</span><br><span class="line">2391</span><br><span class="line">2392</span><br><span class="line">2393</span><br><span class="line">2394</span><br><span class="line">2395</span><br><span class="line">2396</span><br><span class="line">2397</span><br><span class="line">2398</span><br><span class="line">2399</span><br><span class="line">2400</span><br><span class="line">2401</span><br><span class="line">2402</span><br><span class="line">2403</span><br><span class="line">2404</span><br><span class="line">2405</span><br><span class="line">2406</span><br><span class="line">2407</span><br><span class="line">2408</span><br><span class="line">2409</span><br><span class="line">2410</span><br><span class="line">2411</span><br><span class="line">2412</span><br><span class="line">2413</span><br><span class="line">2414</span><br><span class="line">2415</span><br><span class="line">2416</span><br><span class="line">2417</span><br><span class="line">2418</span><br><span class="line">2419</span><br><span class="line">2420</span><br><span class="line">2421</span><br><span class="line">2422</span><br><span class="line">2423</span><br><span class="line">2424</span><br><span class="line">2425</span><br><span class="line">2426</span><br><span class="line">2427</span><br><span class="line">2428</span><br><span class="line">2429</span><br><span class="line">2430</span><br><span class="line">2431</span><br><span class="line">2432</span><br><span class="line">2433</span><br><span class="line">2434</span><br><span class="line">2435</span><br><span class="line">2436</span><br><span class="line">2437</span><br><span class="line">2438</span><br><span class="line">2439</span><br><span class="line">2440</span><br><span class="line">2441</span><br><span class="line">2442</span><br><span class="line">2443</span><br><span class="line">2444</span><br><span class="line">2445</span><br><span class="line">2446</span><br><span class="line">2447</span><br><span class="line">2448</span><br><span class="line">2449</span><br><span class="line">2450</span><br><span class="line">2451</span><br><span class="line">2452</span><br><span class="line">2453</span><br><span class="line">2454</span><br><span class="line">2455</span><br><span class="line">2456</span><br><span class="line">2457</span><br><span class="line">2458</span><br><span class="line">2459</span><br><span class="line">2460</span><br><span class="line">2461</span><br><span class="line">2462</span><br><span class="line">2463</span><br><span class="line">2464</span><br><span class="line">2465</span><br><span class="line">2466</span><br><span class="line">2467</span><br><span class="line">2468</span><br><span class="line">2469</span><br><span class="line">2470</span><br><span class="line">2471</span><br><span class="line">2472</span><br><span class="line">2473</span><br><span class="line">2474</span><br><span class="line">2475</span><br><span class="line">2476</span><br><span class="line">2477</span><br><span class="line">2478</span><br><span class="line">2479</span><br><span class="line">2480</span><br><span class="line">2481</span><br><span class="line">2482</span><br><span class="line">2483</span><br><span class="line">2484</span><br><span class="line">2485</span><br><span class="line">2486</span><br><span class="line">2487</span><br><span class="line">2488</span><br><span class="line">2489</span><br><span class="line">2490</span><br><span class="line">2491</span><br><span class="line">2492</span><br><span class="line">2493</span><br><span class="line">2494</span><br><span class="line">2495</span><br><span class="line">2496</span><br><span class="line">2497</span><br><span class="line">2498</span><br><span class="line">2499</span><br><span class="line">2500</span><br><span class="line">2501</span><br><span class="line">2502</span><br><span class="line">2503</span><br><span class="line">2504</span><br><span class="line">2505</span><br><span class="line">2506</span><br><span class="line">2507</span><br><span class="line">2508</span><br><span class="line">2509</span><br><span class="line">2510</span><br><span class="line">2511</span><br><span class="line">2512</span><br><span class="line">2513</span><br><span class="line">2514</span><br><span class="line">2515</span><br><span class="line">2516</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataInfo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MyDataInfo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAllExtensions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      com.google.protobuf.ExtensionRegistryLite registry)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAllExtensions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      com.google.protobuf.ExtensionRegistry registry)</span> </span>&#123;</span><br><span class="line">    registerAllExtensions(</span><br><span class="line">        (com.google.protobuf.ExtensionRegistryLite) registry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMessageOrBuilder</span> <span class="keyword">extends</span></span></span><br><span class="line">      // @@protoc_insertion_point(interface_extends:MyMessage)</span><br><span class="line">      com.google.protobuf.MessageOrBuilder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *用data_type 来标识传的是哪一个枚举类型</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.MyMessage.DataType data_type = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDataTypeValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *用data_type 来标识传的是哪一个枚举类型</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.MyMessage.DataType data_type = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MyMessage.<span class="function">DataType <span class="title">getDataType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasStudent</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Student <span class="title">getStudent</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">StudentOrBuilder <span class="title">getStudentOrBuilder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasWorker</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Worker <span class="title">getWorker</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">WorkerOrBuilder <span class="title">getWorkerOrBuilder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyMessage.<span class="function">DataBodyCase <span class="title">getDataBodyCase</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">   *protobuf 可以使用message 管理其他的message</span></span><br><span class="line"><span class="comment">   * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Protobuf type &#123;<span class="doctag">@code</span> MyMessage&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessage</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">      <span class="title">com</span>.<span class="title">google</span>.<span class="title">protobuf</span>.<span class="title">GeneratedMessageV3</span> <span class="keyword">implements</span></span></span><br><span class="line">      // @@protoc_insertion_point(message_implements:MyMessage)</span><br><span class="line">      MyMessageOrBuilder &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// Use MyMessage.newBuilder() to construct.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyMessage</span><span class="params">(com.google.protobuf.GeneratedMessageV3.Builder&lt;?&gt; builder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      dataType_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> com.google.protobuf.UnknownFieldSet</span><br><span class="line">    getUnknownFields() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.unknownFields;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>();</span><br><span class="line">      <span class="keyword">if</span> (extensionRegistry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> mutable_bitField0_ = <span class="number">0</span>;</span><br><span class="line">      com.google.protobuf.UnknownFieldSet.Builder unknownFields =</span><br><span class="line">          com.google.protobuf.UnknownFieldSet.newBuilder();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">          <span class="keyword">int</span> tag = input.readTag();</span><br><span class="line">          <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              done = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>: &#123;</span><br><span class="line">              <span class="keyword">int</span> rawValue = input.readEnum();</span><br><span class="line"></span><br><span class="line">              dataType_ = rawValue;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">18</span>: &#123;</span><br><span class="line">              Student.Builder subBuilder = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span>) &#123;</span><br><span class="line">                subBuilder = ((Student) dataBody_).toBuilder();</span><br><span class="line">              &#125;</span><br><span class="line">              dataBody_ =</span><br><span class="line">                  input.readMessage(Student.parser(), extensionRegistry);</span><br><span class="line">              <span class="keyword">if</span> (subBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                subBuilder.mergeFrom((Student) dataBody_);</span><br><span class="line">                dataBody_ = subBuilder.buildPartial();</span><br><span class="line">              &#125;</span><br><span class="line">              dataBodyCase_ = <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">26</span>: &#123;</span><br><span class="line">              Worker.Builder subBuilder = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span>) &#123;</span><br><span class="line">                subBuilder = ((Worker) dataBody_).toBuilder();</span><br><span class="line">              &#125;</span><br><span class="line">              dataBody_ =</span><br><span class="line">                  input.readMessage(Worker.parser(), extensionRegistry);</span><br><span class="line">              <span class="keyword">if</span> (subBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                subBuilder.mergeFrom((Worker) dataBody_);</span><br><span class="line">                dataBody_ = subBuilder.buildPartial();</span><br><span class="line">              &#125;</span><br><span class="line">              dataBodyCase_ = <span class="number">3</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">              <span class="keyword">if</span> (!parseUnknownFieldProto3(</span><br><span class="line">                  input, unknownFields, extensionRegistry, tag)) &#123;</span><br><span class="line">                done = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (com.google.protobuf.InvalidProtocolBufferException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.setUnfinishedMessage(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> com.google.protobuf.InvalidProtocolBufferException(</span><br><span class="line">            e).setUnfinishedMessage(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.unknownFields = unknownFields.build();</span><br><span class="line">        makeExtensionsImmutable();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">        getDescriptor() &#123;</span><br><span class="line">      <span class="keyword">return</span> MyDataInfo.internal_static_MyMessage_descriptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> FieldAccessorTable</span><br><span class="line">        internalGetFieldAccessorTable() &#123;</span><br><span class="line">      <span class="keyword">return</span> MyDataInfo.internal_static_MyMessage_fieldAccessorTable</span><br><span class="line">          .ensureFieldAccessorsInitialized(</span><br><span class="line">              MyMessage<span class="class">.<span class="keyword">class</span>, <span class="title">Builder</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *定义一个枚举类型</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Protobuf enum &#123;<span class="doctag">@code</span> MyMessage.DataType&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> DataType</span><br><span class="line">        implements com.google.protobuf.ProtocolMessageEnum &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       *在proto3 要求enum的编号从0开始</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;StudentType = 0;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      StudentType(<span class="number">0</span>),</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;WorkerType = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      WorkerType(<span class="number">1</span>),</span><br><span class="line">      UNRECOGNIZED(-<span class="number">1</span>),</span><br><span class="line">      ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       *在proto3 要求enum的编号从0开始</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;StudentType = 0;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> StudentType_VALUE = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;WorkerType = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WorkerType_VALUE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == UNRECOGNIZED) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">              <span class="string">"Can't get the number of an unknown enum value."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #forNumber(int)&#125; instead.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Deprecated</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataType <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> forNumber(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataType <span class="title">forNumber</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (value) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> StudentType;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> WorkerType;</span><br><span class="line">          <span class="keyword">default</span>: <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> com.google.protobuf.Internal.EnumLiteMap&lt;DataType&gt;</span><br><span class="line">          internalGetValueMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> internalValueMap;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Internal.EnumLiteMap&lt;</span><br><span class="line">          DataType&gt; internalValueMap =</span><br><span class="line">            <span class="keyword">new</span> com.google.protobuf.Internal.EnumLiteMap&lt;DataType&gt;() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> DataType <span class="title">findValueByNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DataType.forNumber(number);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.EnumValueDescriptor</span><br><span class="line">          getValueDescriptor() &#123;</span><br><span class="line">        <span class="keyword">return</span> getDescriptor().getValues().get(ordinal());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.EnumDescriptor</span><br><span class="line">          getDescriptorForType() &#123;</span><br><span class="line">        <span class="keyword">return</span> getDescriptor();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.EnumDescriptor</span><br><span class="line">          getDescriptor() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyMessage.getDescriptor().getEnumTypes().get(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DataType[] VALUES = values();</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataType <span class="title">valueOf</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.EnumValueDescriptor desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (desc.getType() != getDescriptor()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"EnumValueDescriptor is not for this type."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (desc.getIndex() == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> UNRECOGNIZED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> VALUES[desc.getIndex()];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">DataType</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// @@protoc_insertion_point(enum_scope:MyMessage.DataType)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dataBodyCase_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object dataBody_;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> DataBodyCase</span><br><span class="line">        implements com.google.protobuf.Internal.EnumLite &#123;</span><br><span class="line">      STUDENT(<span class="number">2</span>),</span><br><span class="line">      WORKER(<span class="number">3</span>),</span><br><span class="line">      DATABODY_NOT_SET(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">DataBodyCase</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #forNumber(int)&#125; instead.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Deprecated</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataBodyCase <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> forNumber(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataBodyCase <span class="title">forNumber</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (value) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> STUDENT;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> WORKER;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> DATABODY_NOT_SET;</span><br><span class="line">          <span class="keyword">default</span>: <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DataBodyCase</span><br><span class="line">    getDataBodyCase() &#123;</span><br><span class="line">      <span class="keyword">return</span> DataBodyCase.forNumber(</span><br><span class="line">          dataBodyCase_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA_TYPE_FIELD_NUMBER = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dataType_;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *用data_type 来标识传的是哪一个枚举类型</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.MyMessage.DataType data_type = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDataTypeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dataType_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *用data_type 来标识传的是哪一个枚举类型</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.MyMessage.DataType data_type = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataType <span class="title">getDataType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">      DataType result = DataType.valueOf(dataType_);</span><br><span class="line">      <span class="keyword">return</span> result == <span class="keyword">null</span> ? DataType.UNRECOGNIZED : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STUDENT_FIELD_NUMBER = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dataBodyCase_ == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> (Student) dataBody_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Student.getDefaultInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentOrBuilder <span class="title">getStudentOrBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> (Student) dataBody_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Student.getDefaultInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_FIELD_NUMBER = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dataBodyCase_ == <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">getWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> (Worker) dataBody_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Worker.getDefaultInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WorkerOrBuilder <span class="title">getWorkerOrBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> (Worker) dataBody_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Worker.getDefaultInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> memoizedIsInitialized = -<span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span> isInitialized = memoizedIsInitialized;</span><br><span class="line">      <span class="keyword">if</span> (isInitialized == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (isInitialized == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      memoizedIsInitialized = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(com.google.protobuf.CodedOutputStream output)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (dataType_ != DataType.StudentType.getNumber()) &#123;</span><br><span class="line">        output.writeEnum(<span class="number">1</span>, dataType_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span>) &#123;</span><br><span class="line">        output.writeMessage(<span class="number">2</span>, (Student) dataBody_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span>) &#123;</span><br><span class="line">        output.writeMessage(<span class="number">3</span>, (Worker) dataBody_);</span><br><span class="line">      &#125;</span><br><span class="line">      unknownFields.writeTo(output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSerializedSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> size = memoizedSize;</span><br><span class="line">      <span class="keyword">if</span> (size != -<span class="number">1</span>) <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (dataType_ != DataType.StudentType.getNumber()) &#123;</span><br><span class="line">        size += com.google.protobuf.CodedOutputStream</span><br><span class="line">          .computeEnumSize(<span class="number">1</span>, dataType_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span>) &#123;</span><br><span class="line">        size += com.google.protobuf.CodedOutputStream</span><br><span class="line">          .computeMessageSize(<span class="number">2</span>, (Student) dataBody_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span>) &#123;</span><br><span class="line">        size += com.google.protobuf.CodedOutputStream</span><br><span class="line">          .computeMessageSize(<span class="number">3</span>, (Worker) dataBody_);</span><br><span class="line">      &#125;</span><br><span class="line">      size += unknownFields.getSerializedSize();</span><br><span class="line">      memoizedSize = size;</span><br><span class="line">      <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object obj)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (obj == <span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> MyMessage)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj);</span><br><span class="line">      &#125;</span><br><span class="line">      MyMessage other = (MyMessage) obj;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">      result = result &amp;&amp; dataType_ == other.dataType_;</span><br><span class="line">      result = result &amp;&amp; getDataBodyCase().equals(</span><br><span class="line">          other.getDataBodyCase());</span><br><span class="line">      <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">switch</span> (dataBodyCase_) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          result = result &amp;&amp; getStudent()</span><br><span class="line">              .equals(other.getStudent());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">          result = result &amp;&amp; getWorker()</span><br><span class="line">              .equals(other.getWorker());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">      result = result &amp;&amp; unknownFields.equals(other.unknownFields);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (memoizedHashCode != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memoizedHashCode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> hash = <span class="number">41</span>;</span><br><span class="line">      hash = (<span class="number">19</span> * hash) + getDescriptor().hashCode();</span><br><span class="line">      hash = (<span class="number">37</span> * hash) + DATA_TYPE_FIELD_NUMBER;</span><br><span class="line">      hash = (<span class="number">53</span> * hash) + dataType_;</span><br><span class="line">      <span class="keyword">switch</span> (dataBodyCase_) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          hash = (<span class="number">37</span> * hash) + STUDENT_FIELD_NUMBER;</span><br><span class="line">          hash = (<span class="number">53</span> * hash) + getStudent().hashCode();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">          hash = (<span class="number">37</span> * hash) + WORKER_FIELD_NUMBER;</span><br><span class="line">          hash = (<span class="number">53</span> * hash) + getWorker().hashCode();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">      hash = (<span class="number">29</span> * hash) + unknownFields.hashCode();</span><br><span class="line">      memoizedHashCode = hash;</span><br><span class="line">      <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.nio.ByteBuffer data)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.nio.ByteBuffer data,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ByteString data)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ByteString data,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">parseFrom</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">byte</span>[] data,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">parseFrom</span><span class="params">(java.io.InputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.io.InputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">parseDelimitedFrom</span><span class="params">(java.io.InputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseDelimitedWithIOException(PARSER, input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">parseDelimitedFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.io.InputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.CodedInputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">newBuilderForType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> newBuilder(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">newBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE.toBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">newBuilder</span><span class="params">(MyMessage prototype)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">toBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span> == DEFAULT_INSTANCE</span><br><span class="line">          ? <span class="keyword">new</span> Builder() : <span class="keyword">new</span> Builder().mergeFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Builder <span class="title">newBuilderForType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BuilderParent parent)</span> </span>&#123;</span><br><span class="line">      Builder builder = <span class="keyword">new</span> Builder(parent);</span><br><span class="line">      <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *protobuf 可以使用message 管理其他的message</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Protobuf type &#123;<span class="doctag">@code</span> MyMessage&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">com</span>.<span class="title">google</span>.<span class="title">protobuf</span>.<span class="title">GeneratedMessageV3</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line">        // @@protoc_insertion_point(builder_implements:MyMessage)</span><br><span class="line">        MyMessageOrBuilder &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">          getDescriptor() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyDataInfo.internal_static_MyMessage_descriptor;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> FieldAccessorTable</span><br><span class="line">          internalGetFieldAccessorTable() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyDataInfo.internal_static_MyMessage_fieldAccessorTable</span><br><span class="line">            .ensureFieldAccessorsInitialized(</span><br><span class="line">                MyMessage<span class="class">.<span class="keyword">class</span>, <span class="title">Builder</span>.<span class="title">class</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Construct using com.atguigu.netty.codec2.MyDataInfo.MyMessage.newBuilder()</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        maybeForceBuilderInitialization();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          BuilderParent parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        maybeForceBuilderInitialization();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeForceBuilderInitialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (com.google.protobuf.GeneratedMessageV3</span><br><span class="line">                .alwaysUseFieldBuilders) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.clear();</span><br><span class="line">        dataType_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        dataBodyCase_ = <span class="number">0</span>;</span><br><span class="line">        dataBody_ = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">          getDescriptorForType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyDataInfo.internal_static_MyMessage_descriptor;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> MyMessage <span class="title">getDefaultInstanceForType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MyMessage.getDefaultInstance();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> MyMessage <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyMessage result = buildPartial();</span><br><span class="line">        <span class="keyword">if</span> (!result.isInitialized()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> newUninitializedMessageException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> MyMessage <span class="title">buildPartial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyMessage result = <span class="keyword">new</span> MyMessage(<span class="keyword">this</span>);</span><br><span class="line">        result.dataType_ = dataType_;</span><br><span class="line">        <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (studentBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.dataBody_ = dataBody_;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.dataBody_ = studentBuilder_.build();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (workerBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.dataBody_ = dataBody_;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.dataBody_ = workerBuilder_.build();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.dataBodyCase_ = dataBodyCase_;</span><br><span class="line">        onBuilt();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.clone();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field,</span></span></span><br><span class="line"><span class="function"><span class="params">          Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.setField(field, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.clearField(field);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearOneof</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.OneofDescriptor oneof)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.clearOneof(oneof);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setRepeatedField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.setRepeatedField(field, index, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">addRepeatedField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field,</span></span></span><br><span class="line"><span class="function"><span class="params">          Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.addRepeatedField(field, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeFrom</span><span class="params">(com.google.protobuf.Message other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> MyMessage) &#123;</span><br><span class="line">          <span class="keyword">return</span> mergeFrom((MyMessage)other);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">super</span>.mergeFrom(other);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeFrom</span><span class="params">(MyMessage other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other == MyMessage.getDefaultInstance()) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (other.dataType_ != <span class="number">0</span>) &#123;</span><br><span class="line">          setDataTypeValue(other.getDataTypeValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (other.getDataBodyCase()) &#123;</span><br><span class="line">          <span class="keyword">case</span> STUDENT: &#123;</span><br><span class="line">            mergeStudent(other.getStudent());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> WORKER: &#123;</span><br><span class="line">            mergeWorker(other.getWorker());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> DATABODY_NOT_SET: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.mergeUnknownFields(other.unknownFields);</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        MyMessage parsedMessage = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (com.google.protobuf.InvalidProtocolBufferException e) &#123;</span><br><span class="line">          parsedMessage = (MyMessage) e.getUnfinishedMessage();</span><br><span class="line">          <span class="keyword">throw</span> e.unwrapIOException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (parsedMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mergeFrom(parsedMessage);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> dataBodyCase_ = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">private</span> Object dataBody_;</span><br><span class="line">      <span class="keyword">public</span> DataBodyCase</span><br><span class="line">          getDataBodyCase() &#123;</span><br><span class="line">        <span class="keyword">return</span> DataBodyCase.forNumber(</span><br><span class="line">            dataBodyCase_);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearDataBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataBodyCase_ = <span class="number">0</span>;</span><br><span class="line">        dataBody_ = <span class="keyword">null</span>;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> dataType_ = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       *用data_type 来标识传的是哪一个枚举类型</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.MyMessage.DataType data_type = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDataTypeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataType_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       *用data_type 来标识传的是哪一个枚举类型</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.MyMessage.DataType data_type = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setDataTypeValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        dataType_ = value;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       *用data_type 来标识传的是哪一个枚举类型</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.MyMessage.DataType data_type = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> DataType <span class="title">getDataType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">        DataType result = DataType.valueOf(dataType_);</span><br><span class="line">        <span class="keyword">return</span> result == <span class="keyword">null</span> ? DataType.UNRECOGNIZED : result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       *用data_type 来标识传的是哪一个枚举类型</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.MyMessage.DataType data_type = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setDataType</span><span class="params">(DataType value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dataType_ = value.getNumber();</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       *用data_type 来标识传的是哪一个枚举类型</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.MyMessage.DataType data_type = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearDataType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        dataType_ = <span class="number">0</span>;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> com.google.protobuf.SingleFieldBuilderV3&lt;</span><br><span class="line">          Student, Student.Builder, StudentOrBuilder&gt; studentBuilder_;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataBodyCase_ == <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (studentBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Student) dataBody_;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Student.getDefaultInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> studentBuilder_.getMessage();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Student.getDefaultInstance();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setStudent</span><span class="params">(Student value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (studentBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">          &#125;</span><br><span class="line">          dataBody_ = value;</span><br><span class="line">          onChanged();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          studentBuilder_.setMessage(value);</span><br><span class="line">        &#125;</span><br><span class="line">        dataBodyCase_ = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setStudent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          Student.Builder builderForValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (studentBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          dataBody_ = builderForValue.build();</span><br><span class="line">          onChanged();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          studentBuilder_.setMessage(builderForValue.build());</span><br><span class="line">        &#125;</span><br><span class="line">        dataBodyCase_ = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeStudent</span><span class="params">(Student value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (studentBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span> &amp;&amp;</span><br><span class="line">              dataBody_ != Student.getDefaultInstance()) &#123;</span><br><span class="line">            dataBody_ = Student.newBuilder((Student) dataBody_)</span><br><span class="line">                .mergeFrom(value).buildPartial();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dataBody_ = value;</span><br><span class="line">          &#125;</span><br><span class="line">          onChanged();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span>) &#123;</span><br><span class="line">            studentBuilder_.mergeFrom(value);</span><br><span class="line">          &#125;</span><br><span class="line">          studentBuilder_.setMessage(value);</span><br><span class="line">        &#125;</span><br><span class="line">        dataBodyCase_ = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (studentBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span>) &#123;</span><br><span class="line">            dataBodyCase_ = <span class="number">0</span>;</span><br><span class="line">            dataBody_ = <span class="keyword">null</span>;</span><br><span class="line">            onChanged();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span>) &#123;</span><br><span class="line">            dataBodyCase_ = <span class="number">0</span>;</span><br><span class="line">            dataBody_ = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          studentBuilder_.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> Student.<span class="function">Builder <span class="title">getStudentBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getStudentFieldBuilder().getBuilder();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> StudentOrBuilder <span class="title">getStudentOrBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((dataBodyCase_ == <span class="number">2</span>) &amp;&amp; (studentBuilder_ != <span class="keyword">null</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> studentBuilder_.getMessageOrBuilder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Student) dataBody_;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Student.getDefaultInstance();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Student student = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> com.google.protobuf.SingleFieldBuilderV3&lt;</span><br><span class="line">          Student, Student.Builder, StudentOrBuilder&gt;</span><br><span class="line">          getStudentFieldBuilder() &#123;</span><br><span class="line">        <span class="keyword">if</span> (studentBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!(dataBodyCase_ == <span class="number">2</span>)) &#123;</span><br><span class="line">            dataBody_ = Student.getDefaultInstance();</span><br><span class="line">          &#125;</span><br><span class="line">          studentBuilder_ = <span class="keyword">new</span> com.google.protobuf.SingleFieldBuilderV3&lt;</span><br><span class="line">              Student, Student.Builder, StudentOrBuilder&gt;(</span><br><span class="line">                  (Student) dataBody_,</span><br><span class="line">                  getParentForChildren(),</span><br><span class="line">                  isClean());</span><br><span class="line">          dataBody_ = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dataBodyCase_ = <span class="number">2</span>;</span><br><span class="line">        onChanged();;</span><br><span class="line">        <span class="keyword">return</span> studentBuilder_;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> com.google.protobuf.SingleFieldBuilderV3&lt;</span><br><span class="line">          Worker, Worker.Builder, WorkerOrBuilder&gt; workerBuilder_;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataBodyCase_ == <span class="number">3</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Worker <span class="title">getWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Worker) dataBody_;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Worker.getDefaultInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> workerBuilder_.getMessage();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Worker.getDefaultInstance();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setWorker</span><span class="params">(Worker value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">          &#125;</span><br><span class="line">          dataBody_ = value;</span><br><span class="line">          onChanged();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          workerBuilder_.setMessage(value);</span><br><span class="line">        &#125;</span><br><span class="line">        dataBodyCase_ = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setWorker</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          Worker.Builder builderForValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          dataBody_ = builderForValue.build();</span><br><span class="line">          onChanged();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          workerBuilder_.setMessage(builderForValue.build());</span><br><span class="line">        &#125;</span><br><span class="line">        dataBodyCase_ = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeWorker</span><span class="params">(Worker value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span> &amp;&amp;</span><br><span class="line">              dataBody_ != Worker.getDefaultInstance()) &#123;</span><br><span class="line">            dataBody_ = Worker.newBuilder((Worker) dataBody_)</span><br><span class="line">                .mergeFrom(value).buildPartial();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dataBody_ = value;</span><br><span class="line">          &#125;</span><br><span class="line">          onChanged();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span>) &#123;</span><br><span class="line">            workerBuilder_.mergeFrom(value);</span><br><span class="line">          &#125;</span><br><span class="line">          workerBuilder_.setMessage(value);</span><br><span class="line">        &#125;</span><br><span class="line">        dataBodyCase_ = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span>) &#123;</span><br><span class="line">            dataBodyCase_ = <span class="number">0</span>;</span><br><span class="line">            dataBody_ = <span class="keyword">null</span>;</span><br><span class="line">            onChanged();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span>) &#123;</span><br><span class="line">            dataBodyCase_ = <span class="number">0</span>;</span><br><span class="line">            dataBody_ = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          workerBuilder_.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> Worker.<span class="function">Builder <span class="title">getWorkerBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getWorkerFieldBuilder().getBuilder();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> WorkerOrBuilder <span class="title">getWorkerOrBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((dataBodyCase_ == <span class="number">3</span>) &amp;&amp; (workerBuilder_ != <span class="keyword">null</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> workerBuilder_.getMessageOrBuilder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (dataBodyCase_ == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Worker) dataBody_;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Worker.getDefaultInstance();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;.Worker worker = 3;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> com.google.protobuf.SingleFieldBuilderV3&lt;</span><br><span class="line">          Worker, Worker.Builder, WorkerOrBuilder&gt;</span><br><span class="line">          getWorkerFieldBuilder() &#123;</span><br><span class="line">        <span class="keyword">if</span> (workerBuilder_ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!(dataBodyCase_ == <span class="number">3</span>)) &#123;</span><br><span class="line">            dataBody_ = Worker.getDefaultInstance();</span><br><span class="line">          &#125;</span><br><span class="line">          workerBuilder_ = <span class="keyword">new</span> com.google.protobuf.SingleFieldBuilderV3&lt;</span><br><span class="line">              Worker, Worker.Builder, WorkerOrBuilder&gt;(</span><br><span class="line">                  (Worker) dataBody_,</span><br><span class="line">                  getParentForChildren(),</span><br><span class="line">                  isClean());</span><br><span class="line">          dataBody_ = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dataBodyCase_ = <span class="number">3</span>;</span><br><span class="line">        onChanged();;</span><br><span class="line">        <span class="keyword">return</span> workerBuilder_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Builder <span class="title">setUnknownFields</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> com.google.protobuf.UnknownFieldSet unknownFields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.setUnknownFieldsProto3(unknownFields);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Builder <span class="title">mergeUnknownFields</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> com.google.protobuf.UnknownFieldSet unknownFields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.mergeUnknownFields(unknownFields);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// @@protoc_insertion_point(builder_scope:MyMessage)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @@protoc_insertion_point(class_scope:MyMessage)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MyMessage DEFAULT_INSTANCE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      DEFAULT_INSTANCE = <span class="keyword">new</span> MyMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessage <span class="title">getDefaultInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Parser&lt;MyMessage&gt;</span><br><span class="line">        PARSER = <span class="keyword">new</span> com.google.protobuf.AbstractParser&lt;MyMessage&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> MyMessage <span class="title">parsePartialFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyMessage(input, extensionRegistry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.google.protobuf.<span class="function">Parser&lt;MyMessage&gt; <span class="title">parser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> com.google.protobuf.<span class="function">Parser&lt;MyMessage&gt; <span class="title">getParserForType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyMessage <span class="title">getDefaultInstanceForType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentOrBuilder</span> <span class="keyword">extends</span></span></span><br><span class="line">      // @@protoc_insertion_point(interface_extends:Student)</span><br><span class="line">      com.google.protobuf.MessageOrBuilder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *Student类的属性</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;int32 id = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    com.google.protobuf.ByteString</span><br><span class="line">        getNameBytes();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Protobuf type &#123;<span class="doctag">@code</span> Student&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">      <span class="title">com</span>.<span class="title">google</span>.<span class="title">protobuf</span>.<span class="title">GeneratedMessageV3</span> <span class="keyword">implements</span></span></span><br><span class="line">      // @@protoc_insertion_point(message_implements:Student)</span><br><span class="line">      StudentOrBuilder &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// Use Student.newBuilder() to construct.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(com.google.protobuf.GeneratedMessageV3.Builder&lt;?&gt; builder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      id_ = <span class="number">0</span>;</span><br><span class="line">      name_ = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> com.google.protobuf.UnknownFieldSet</span><br><span class="line">    getUnknownFields() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.unknownFields;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>();</span><br><span class="line">      <span class="keyword">if</span> (extensionRegistry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> mutable_bitField0_ = <span class="number">0</span>;</span><br><span class="line">      com.google.protobuf.UnknownFieldSet.Builder unknownFields =</span><br><span class="line">          com.google.protobuf.UnknownFieldSet.newBuilder();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">          <span class="keyword">int</span> tag = input.readTag();</span><br><span class="line">          <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              done = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>: &#123;</span><br><span class="line"></span><br><span class="line">              id_ = input.readInt32();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">18</span>: &#123;</span><br><span class="line">              String s = input.readStringRequireUtf8();</span><br><span class="line"></span><br><span class="line">              name_ = s;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">              <span class="keyword">if</span> (!parseUnknownFieldProto3(</span><br><span class="line">                  input, unknownFields, extensionRegistry, tag)) &#123;</span><br><span class="line">                done = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (com.google.protobuf.InvalidProtocolBufferException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.setUnfinishedMessage(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> com.google.protobuf.InvalidProtocolBufferException(</span><br><span class="line">            e).setUnfinishedMessage(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.unknownFields = unknownFields.build();</span><br><span class="line">        makeExtensionsImmutable();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">        getDescriptor() &#123;</span><br><span class="line">      <span class="keyword">return</span> MyDataInfo.internal_static_Student_descriptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> FieldAccessorTable</span><br><span class="line">        internalGetFieldAccessorTable() &#123;</span><br><span class="line">      <span class="keyword">return</span> MyDataInfo.internal_static_Student_fieldAccessorTable</span><br><span class="line">          .ensureFieldAccessorsInitialized(</span><br><span class="line">              Student<span class="class">.<span class="keyword">class</span>, <span class="title">Builder</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ID_FIELD_NUMBER = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id_;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *Student类的属性</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;int32 id = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NAME_FIELD_NUMBER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object name_;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Object ref = name_;</span><br><span class="line">      <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) ref;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        com.google.protobuf.ByteString bs = </span><br><span class="line">            (com.google.protobuf.ByteString) ref;</span><br><span class="line">        String s = bs.toStringUtf8();</span><br><span class="line">        name_ = s;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> com.google.protobuf.ByteString</span><br><span class="line">        getNameBytes() &#123;</span><br><span class="line">      Object ref = name_;</span><br><span class="line">      <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        com.google.protobuf.ByteString b = </span><br><span class="line">            com.google.protobuf.ByteString.copyFromUtf8(</span><br><span class="line">                (String) ref);</span><br><span class="line">        name_ = b;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (com.google.protobuf.ByteString) ref;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> memoizedIsInitialized = -<span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span> isInitialized = memoizedIsInitialized;</span><br><span class="line">      <span class="keyword">if</span> (isInitialized == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (isInitialized == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      memoizedIsInitialized = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(com.google.protobuf.CodedOutputStream output)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (id_ != <span class="number">0</span>) &#123;</span><br><span class="line">        output.writeInt32(<span class="number">1</span>, id_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!getNameBytes().isEmpty()) &#123;</span><br><span class="line">        com.google.protobuf.GeneratedMessageV3.writeString(output, <span class="number">2</span>, name_);</span><br><span class="line">      &#125;</span><br><span class="line">      unknownFields.writeTo(output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSerializedSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> size = memoizedSize;</span><br><span class="line">      <span class="keyword">if</span> (size != -<span class="number">1</span>) <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (id_ != <span class="number">0</span>) &#123;</span><br><span class="line">        size += com.google.protobuf.CodedOutputStream</span><br><span class="line">          .computeInt32Size(<span class="number">1</span>, id_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!getNameBytes().isEmpty()) &#123;</span><br><span class="line">        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(<span class="number">2</span>, name_);</span><br><span class="line">      &#125;</span><br><span class="line">      size += unknownFields.getSerializedSize();</span><br><span class="line">      memoizedSize = size;</span><br><span class="line">      <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object obj)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (obj == <span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Student)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj);</span><br><span class="line">      &#125;</span><br><span class="line">      Student other = (Student) obj;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">      result = result &amp;&amp; (getId()</span><br><span class="line">          == other.getId());</span><br><span class="line">      result = result &amp;&amp; getName()</span><br><span class="line">          .equals(other.getName());</span><br><span class="line">      result = result &amp;&amp; unknownFields.equals(other.unknownFields);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (memoizedHashCode != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memoizedHashCode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> hash = <span class="number">41</span>;</span><br><span class="line">      hash = (<span class="number">19</span> * hash) + getDescriptor().hashCode();</span><br><span class="line">      hash = (<span class="number">37</span> * hash) + ID_FIELD_NUMBER;</span><br><span class="line">      hash = (<span class="number">53</span> * hash) + getId();</span><br><span class="line">      hash = (<span class="number">37</span> * hash) + NAME_FIELD_NUMBER;</span><br><span class="line">      hash = (<span class="number">53</span> * hash) + getName().hashCode();</span><br><span class="line">      hash = (<span class="number">29</span> * hash) + unknownFields.hashCode();</span><br><span class="line">      memoizedHashCode = hash;</span><br><span class="line">      <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.nio.ByteBuffer data)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.nio.ByteBuffer data,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ByteString data)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ByteString data,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">byte</span>[] data,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(java.io.InputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.io.InputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseDelimitedFrom</span><span class="params">(java.io.InputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseDelimitedWithIOException(PARSER, input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseDelimitedFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.io.InputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.CodedInputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">newBuilderForType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> newBuilder(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">newBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE.toBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">newBuilder</span><span class="params">(Student prototype)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">toBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span> == DEFAULT_INSTANCE</span><br><span class="line">          ? <span class="keyword">new</span> Builder() : <span class="keyword">new</span> Builder().mergeFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Builder <span class="title">newBuilderForType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BuilderParent parent)</span> </span>&#123;</span><br><span class="line">      Builder builder = <span class="keyword">new</span> Builder(parent);</span><br><span class="line">      <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Protobuf type &#123;<span class="doctag">@code</span> Student&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">com</span>.<span class="title">google</span>.<span class="title">protobuf</span>.<span class="title">GeneratedMessageV3</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line">        // @@protoc_insertion_point(builder_implements:Student)</span><br><span class="line">        StudentOrBuilder &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">          getDescriptor() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyDataInfo.internal_static_Student_descriptor;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> FieldAccessorTable</span><br><span class="line">          internalGetFieldAccessorTable() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyDataInfo.internal_static_Student_fieldAccessorTable</span><br><span class="line">            .ensureFieldAccessorsInitialized(</span><br><span class="line">                Student<span class="class">.<span class="keyword">class</span>, <span class="title">Builder</span>.<span class="title">class</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Construct using com.atguigu.netty.codec2.MyDataInfo.Student.newBuilder()</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        maybeForceBuilderInitialization();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          BuilderParent parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        maybeForceBuilderInitialization();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeForceBuilderInitialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (com.google.protobuf.GeneratedMessageV3</span><br><span class="line">                .alwaysUseFieldBuilders) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.clear();</span><br><span class="line">        id_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        name_ = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">          getDescriptorForType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyDataInfo.internal_static_Student_descriptor;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Student <span class="title">getDefaultInstanceForType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Student.getDefaultInstance();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Student <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student result = buildPartial();</span><br><span class="line">        <span class="keyword">if</span> (!result.isInitialized()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> newUninitializedMessageException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Student <span class="title">buildPartial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student result = <span class="keyword">new</span> Student(<span class="keyword">this</span>);</span><br><span class="line">        result.id_ = id_;</span><br><span class="line">        result.name_ = name_;</span><br><span class="line">        onBuilt();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.clone();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field,</span></span></span><br><span class="line"><span class="function"><span class="params">          Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.setField(field, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.clearField(field);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearOneof</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.OneofDescriptor oneof)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.clearOneof(oneof);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setRepeatedField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.setRepeatedField(field, index, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">addRepeatedField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field,</span></span></span><br><span class="line"><span class="function"><span class="params">          Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.addRepeatedField(field, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeFrom</span><span class="params">(com.google.protobuf.Message other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">          <span class="keyword">return</span> mergeFrom((Student)other);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">super</span>.mergeFrom(other);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeFrom</span><span class="params">(Student other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other == Student.getDefaultInstance()) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (other.getId() != <span class="number">0</span>) &#123;</span><br><span class="line">          setId(other.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!other.getName().isEmpty()) &#123;</span><br><span class="line">          name_ = other.name_;</span><br><span class="line">          onChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.mergeUnknownFields(other.unknownFields);</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        Student parsedMessage = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (com.google.protobuf.InvalidProtocolBufferException e) &#123;</span><br><span class="line">          parsedMessage = (Student) e.getUnfinishedMessage();</span><br><span class="line">          <span class="keyword">throw</span> e.unwrapIOException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (parsedMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mergeFrom(parsedMessage);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> id_ ;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       *Student类的属性</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;int32 id = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       *Student类的属性</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;int32 id = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setId</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        id_ = value;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       *Student类的属性</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;int32 id = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        id_ = <span class="number">0</span>;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> Object name_ = <span class="string">""</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object ref = name_;</span><br><span class="line">        <span class="keyword">if</span> (!(ref <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">          com.google.protobuf.ByteString bs =</span><br><span class="line">              (com.google.protobuf.ByteString) ref;</span><br><span class="line">          String s = bs.toStringUtf8();</span><br><span class="line">          name_ = s;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (String) ref;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> com.google.protobuf.ByteString</span><br><span class="line">          getNameBytes() &#123;</span><br><span class="line">        Object ref = name_;</span><br><span class="line">        <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          com.google.protobuf.ByteString b = </span><br><span class="line">              com.google.protobuf.ByteString.copyFromUtf8(</span><br><span class="line">                  (String) ref);</span><br><span class="line">          name_ = b;</span><br><span class="line">          <span class="keyword">return</span> b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (com.google.protobuf.ByteString) ref;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">        name_ = value;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        name_ = getDefaultInstance().getName();</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">       * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setNameBytes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.ByteString value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125;</span><br><span class="line">  checkByteStringIsUtf8(value);</span><br><span class="line">        </span><br><span class="line">        name_ = value;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Builder <span class="title">setUnknownFields</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> com.google.protobuf.UnknownFieldSet unknownFields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.setUnknownFieldsProto3(unknownFields);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Builder <span class="title">mergeUnknownFields</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> com.google.protobuf.UnknownFieldSet unknownFields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.mergeUnknownFields(unknownFields);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// @@protoc_insertion_point(builder_scope:Student)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @@protoc_insertion_point(class_scope:Student)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Student DEFAULT_INSTANCE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      DEFAULT_INSTANCE = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">getDefaultInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Parser&lt;Student&gt;</span><br><span class="line">        PARSER = <span class="keyword">new</span> com.google.protobuf.AbstractParser&lt;Student&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Student <span class="title">parsePartialFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(input, extensionRegistry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.google.protobuf.<span class="function">Parser&lt;Student&gt; <span class="title">parser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> com.google.protobuf.<span class="function">Parser&lt;Student&gt; <span class="title">getParserForType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getDefaultInstanceForType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerOrBuilder</span> <span class="keyword">extends</span></span></span><br><span class="line">      // @@protoc_insertion_point(interface_extends:Worker)</span><br><span class="line">      com.google.protobuf.MessageOrBuilder &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;string name = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;string name = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    com.google.protobuf.ByteString</span><br><span class="line">        getNameBytes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;int32 age = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Protobuf type &#123;<span class="doctag">@code</span> Worker&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">      <span class="title">com</span>.<span class="title">google</span>.<span class="title">protobuf</span>.<span class="title">GeneratedMessageV3</span> <span class="keyword">implements</span></span></span><br><span class="line">      // @@protoc_insertion_point(message_implements:Worker)</span><br><span class="line">      WorkerOrBuilder &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// Use Worker.newBuilder() to construct.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Worker</span><span class="params">(com.google.protobuf.GeneratedMessageV3.Builder&lt;?&gt; builder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      name_ = <span class="string">""</span>;</span><br><span class="line">      age_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> com.google.protobuf.UnknownFieldSet</span><br><span class="line">    getUnknownFields() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.unknownFields;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Worker</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>();</span><br><span class="line">      <span class="keyword">if</span> (extensionRegistry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> mutable_bitField0_ = <span class="number">0</span>;</span><br><span class="line">      com.google.protobuf.UnknownFieldSet.Builder unknownFields =</span><br><span class="line">          com.google.protobuf.UnknownFieldSet.newBuilder();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">          <span class="keyword">int</span> tag = input.readTag();</span><br><span class="line">          <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              done = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>: &#123;</span><br><span class="line">              String s = input.readStringRequireUtf8();</span><br><span class="line"></span><br><span class="line">              name_ = s;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">16</span>: &#123;</span><br><span class="line"></span><br><span class="line">              age_ = input.readInt32();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">              <span class="keyword">if</span> (!parseUnknownFieldProto3(</span><br><span class="line">                  input, unknownFields, extensionRegistry, tag)) &#123;</span><br><span class="line">                done = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (com.google.protobuf.InvalidProtocolBufferException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.setUnfinishedMessage(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> com.google.protobuf.InvalidProtocolBufferException(</span><br><span class="line">            e).setUnfinishedMessage(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.unknownFields = unknownFields.build();</span><br><span class="line">        makeExtensionsImmutable();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">        getDescriptor() &#123;</span><br><span class="line">      <span class="keyword">return</span> MyDataInfo.internal_static_Worker_descriptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> FieldAccessorTable</span><br><span class="line">        internalGetFieldAccessorTable() &#123;</span><br><span class="line">      <span class="keyword">return</span> MyDataInfo.internal_static_Worker_fieldAccessorTable</span><br><span class="line">          .ensureFieldAccessorsInitialized(</span><br><span class="line">              Worker<span class="class">.<span class="keyword">class</span>, <span class="title">Builder</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NAME_FIELD_NUMBER = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object name_;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;string name = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Object ref = name_;</span><br><span class="line">      <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) ref;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        com.google.protobuf.ByteString bs = </span><br><span class="line">            (com.google.protobuf.ByteString) ref;</span><br><span class="line">        String s = bs.toStringUtf8();</span><br><span class="line">        name_ = s;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;string name = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> com.google.protobuf.ByteString</span><br><span class="line">        getNameBytes() &#123;</span><br><span class="line">      Object ref = name_;</span><br><span class="line">      <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        com.google.protobuf.ByteString b = </span><br><span class="line">            com.google.protobuf.ByteString.copyFromUtf8(</span><br><span class="line">                (String) ref);</span><br><span class="line">        name_ = b;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (com.google.protobuf.ByteString) ref;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AGE_FIELD_NUMBER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age_;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;int32 age = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> memoizedIsInitialized = -<span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span> isInitialized = memoizedIsInitialized;</span><br><span class="line">      <span class="keyword">if</span> (isInitialized == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (isInitialized == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      memoizedIsInitialized = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(com.google.protobuf.CodedOutputStream output)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!getNameBytes().isEmpty()) &#123;</span><br><span class="line">        com.google.protobuf.GeneratedMessageV3.writeString(output, <span class="number">1</span>, name_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (age_ != <span class="number">0</span>) &#123;</span><br><span class="line">        output.writeInt32(<span class="number">2</span>, age_);</span><br><span class="line">      &#125;</span><br><span class="line">      unknownFields.writeTo(output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSerializedSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> size = memoizedSize;</span><br><span class="line">      <span class="keyword">if</span> (size != -<span class="number">1</span>) <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!getNameBytes().isEmpty()) &#123;</span><br><span class="line">        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(<span class="number">1</span>, name_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (age_ != <span class="number">0</span>) &#123;</span><br><span class="line">        size += com.google.protobuf.CodedOutputStream</span><br><span class="line">          .computeInt32Size(<span class="number">2</span>, age_);</span><br><span class="line">      &#125;</span><br><span class="line">      size += unknownFields.getSerializedSize();</span><br><span class="line">      memoizedSize = size;</span><br><span class="line">      <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object obj)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (obj == <span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Worker)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj);</span><br><span class="line">      &#125;</span><br><span class="line">      Worker other = (Worker) obj;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">      result = result &amp;&amp; getName()</span><br><span class="line">          .equals(other.getName());</span><br><span class="line">      result = result &amp;&amp; (getAge()</span><br><span class="line">          == other.getAge());</span><br><span class="line">      result = result &amp;&amp; unknownFields.equals(other.unknownFields);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (memoizedHashCode != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memoizedHashCode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> hash = <span class="number">41</span>;</span><br><span class="line">      hash = (<span class="number">19</span> * hash) + getDescriptor().hashCode();</span><br><span class="line">      hash = (<span class="number">37</span> * hash) + NAME_FIELD_NUMBER;</span><br><span class="line">      hash = (<span class="number">53</span> * hash) + getName().hashCode();</span><br><span class="line">      hash = (<span class="number">37</span> * hash) + AGE_FIELD_NUMBER;</span><br><span class="line">      hash = (<span class="number">53</span> * hash) + getAge();</span><br><span class="line">      hash = (<span class="number">29</span> * hash) + unknownFields.hashCode();</span><br><span class="line">      memoizedHashCode = hash;</span><br><span class="line">      <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.nio.ByteBuffer data)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.nio.ByteBuffer data,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ByteString data)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ByteString data,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">parseFrom</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">byte</span>[] data,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER.parseFrom(data, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">parseFrom</span><span class="params">(java.io.InputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.io.InputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">parseDelimitedFrom</span><span class="params">(java.io.InputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseDelimitedWithIOException(PARSER, input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">parseDelimitedFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        java.io.InputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.CodedInputStream input)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">parseFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">        com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> com.google.protobuf.GeneratedMessageV3</span><br><span class="line">          .parseWithIOException(PARSER, input, extensionRegistry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">newBuilderForType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> newBuilder(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">newBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE.toBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">newBuilder</span><span class="params">(Worker prototype)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">toBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span> == DEFAULT_INSTANCE</span><br><span class="line">          ? <span class="keyword">new</span> Builder() : <span class="keyword">new</span> Builder().mergeFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Builder <span class="title">newBuilderForType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BuilderParent parent)</span> </span>&#123;</span><br><span class="line">      Builder builder = <span class="keyword">new</span> Builder(parent);</span><br><span class="line">      <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Protobuf type &#123;<span class="doctag">@code</span> Worker&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">com</span>.<span class="title">google</span>.<span class="title">protobuf</span>.<span class="title">GeneratedMessageV3</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line">        // @@protoc_insertion_point(builder_implements:Worker)</span><br><span class="line">        WorkerOrBuilder &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">          getDescriptor() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyDataInfo.internal_static_Worker_descriptor;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> FieldAccessorTable</span><br><span class="line">          internalGetFieldAccessorTable() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyDataInfo.internal_static_Worker_fieldAccessorTable</span><br><span class="line">            .ensureFieldAccessorsInitialized(</span><br><span class="line">                Worker<span class="class">.<span class="keyword">class</span>, <span class="title">Builder</span>.<span class="title">class</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Construct using com.atguigu.netty.codec2.MyDataInfo.Worker.newBuilder()</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        maybeForceBuilderInitialization();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          BuilderParent parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        maybeForceBuilderInitialization();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeForceBuilderInitialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (com.google.protobuf.GeneratedMessageV3</span><br><span class="line">                .alwaysUseFieldBuilders) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.clear();</span><br><span class="line">        name_ = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        age_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">          getDescriptorForType() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyDataInfo.internal_static_Worker_descriptor;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Worker <span class="title">getDefaultInstanceForType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Worker.getDefaultInstance();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Worker <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Worker result = buildPartial();</span><br><span class="line">        <span class="keyword">if</span> (!result.isInitialized()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> newUninitializedMessageException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Worker <span class="title">buildPartial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Worker result = <span class="keyword">new</span> Worker(<span class="keyword">this</span>);</span><br><span class="line">        result.name_ = name_;</span><br><span class="line">        result.age_ = age_;</span><br><span class="line">        onBuilt();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.clone();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field,</span></span></span><br><span class="line"><span class="function"><span class="params">          Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.setField(field, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.clearField(field);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearOneof</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.OneofDescriptor oneof)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.clearOneof(oneof);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setRepeatedField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.setRepeatedField(field, index, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">addRepeatedField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.Descriptors.FieldDescriptor field,</span></span></span><br><span class="line"><span class="function"><span class="params">          Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Builder) <span class="keyword">super</span>.addRepeatedField(field, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeFrom</span><span class="params">(com.google.protobuf.Message other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> Worker) &#123;</span><br><span class="line">          <span class="keyword">return</span> mergeFrom((Worker)other);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">super</span>.mergeFrom(other);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeFrom</span><span class="params">(Worker other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other == Worker.getDefaultInstance()) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (!other.getName().isEmpty()) &#123;</span><br><span class="line">          name_ = other.name_;</span><br><span class="line">          onChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (other.getAge() != <span class="number">0</span>) &#123;</span><br><span class="line">          setAge(other.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.mergeUnknownFields(other.unknownFields);</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">mergeFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        Worker parsedMessage = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (com.google.protobuf.InvalidProtocolBufferException e) &#123;</span><br><span class="line">          parsedMessage = (Worker) e.getUnfinishedMessage();</span><br><span class="line">          <span class="keyword">throw</span> e.unwrapIOException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (parsedMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mergeFrom(parsedMessage);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> Object name_ = <span class="string">""</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object ref = name_;</span><br><span class="line">        <span class="keyword">if</span> (!(ref <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">          com.google.protobuf.ByteString bs =</span><br><span class="line">              (com.google.protobuf.ByteString) ref;</span><br><span class="line">          String s = bs.toStringUtf8();</span><br><span class="line">          name_ = s;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (String) ref;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> com.google.protobuf.ByteString</span><br><span class="line">          getNameBytes() &#123;</span><br><span class="line">        Object ref = name_;</span><br><span class="line">        <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          com.google.protobuf.ByteString b = </span><br><span class="line">              com.google.protobuf.ByteString.copyFromUtf8(</span><br><span class="line">                  (String) ref);</span><br><span class="line">          name_ = b;</span><br><span class="line">          <span class="keyword">return</span> b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (com.google.protobuf.ByteString) ref;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">        name_ = value;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        name_ = getDefaultInstance().getName();</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;string name = 1;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setNameBytes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.ByteString value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125;</span><br><span class="line">  checkByteStringIsUtf8(value);</span><br><span class="line">        </span><br><span class="line">        name_ = value;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> age_ ;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;int32 age = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age_;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;int32 age = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        age_ = value;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &lt;code&gt;int32 age = 2;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">clearAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        age_ = <span class="number">0</span>;</span><br><span class="line">        onChanged();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Builder <span class="title">setUnknownFields</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> com.google.protobuf.UnknownFieldSet unknownFields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.setUnknownFieldsProto3(unknownFields);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Builder <span class="title">mergeUnknownFields</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> com.google.protobuf.UnknownFieldSet unknownFields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.mergeUnknownFields(unknownFields);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// @@protoc_insertion_point(builder_scope:Worker)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @@protoc_insertion_point(class_scope:Worker)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Worker DEFAULT_INSTANCE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      DEFAULT_INSTANCE = <span class="keyword">new</span> Worker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title">getDefaultInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Parser&lt;Worker&gt;</span><br><span class="line">        PARSER = <span class="keyword">new</span> com.google.protobuf.AbstractParser&lt;Worker&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Worker <span class="title">parsePartialFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.CodedInputStream input,</span></span></span><br><span class="line"><span class="function"><span class="params">          com.google.protobuf.ExtensionRegistryLite extensionRegistry)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> com.google.protobuf.InvalidProtocolBufferException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Worker(input, extensionRegistry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.google.protobuf.<span class="function">Parser&lt;Worker&gt; <span class="title">parser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> com.google.protobuf.<span class="function">Parser&lt;Worker&gt; <span class="title">getParserForType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> PARSER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">getDefaultInstanceForType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DEFAULT_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">    internal_static_MyMessage_descriptor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> </span><br><span class="line">    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable</span><br><span class="line">      internal_static_MyMessage_fieldAccessorTable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">    internal_static_Student_descriptor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> </span><br><span class="line">    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable</span><br><span class="line">      internal_static_Student_fieldAccessorTable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.google.protobuf.Descriptors.Descriptor</span><br><span class="line">    internal_static_Worker_descriptor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> </span><br><span class="line">    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable</span><br><span class="line">      internal_static_Worker_fieldAccessorTable;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.google.protobuf.Descriptors.FileDescriptor</span><br><span class="line">      getDescriptor() &#123;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span>  com.google.protobuf.Descriptors.FileDescriptor</span><br><span class="line">      descriptor;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    String[] descriptorData = &#123;</span><br><span class="line">      <span class="string">"\n\rStudent.proto\"\244\001\n\tMyMessage\022&amp;\n\tdata_ty"</span> +</span><br><span class="line">      <span class="string">"pe\030\001 \001(\0162\023.MyMessage.DataType\022\033\n\007student"</span> +</span><br><span class="line">      <span class="string">"\030\002 \001(\0132\010.StudentH\000\022\031\n\006worker\030\003 \001(\0132\007.Wor"</span> +</span><br><span class="line">      <span class="string">"kerH\000\"+\n\010DataType\022\017\n\013StudentType\020\000\022\016\n\nWo"</span> +</span><br><span class="line">      <span class="string">"rkerType\020\001B\n\n\010dataBody\"#\n\007Student\022\n\n\002id\030"</span> +</span><br><span class="line">      <span class="string">"\001 \001(\005\022\014\n\004name\030\002 \001(\t\"#\n\006Worker\022\014\n\004name\030\001 "</span> +</span><br><span class="line">      <span class="string">"\001(\t\022\013\n\003age\030\002 \001(\005B(\n\030com.atguigu.netty.co"</span> +</span><br><span class="line">      <span class="string">"dec2B\nMyDataInfoH\001b\006proto3"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =</span><br><span class="line">        <span class="keyword">new</span> com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() &#123;</span><br><span class="line">          <span class="keyword">public</span> com.google.protobuf.<span class="function">ExtensionRegistry <span class="title">assignDescriptors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">              com.google.protobuf.Descriptors.FileDescriptor root)</span> </span>&#123;</span><br><span class="line">            descriptor = root;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    com.google.protobuf.Descriptors.FileDescriptor</span><br><span class="line">      .internalBuildGeneratedFileFrom(descriptorData,</span><br><span class="line">        <span class="keyword">new</span> com.google.protobuf.Descriptors.FileDescriptor[] &#123;</span><br><span class="line">        &#125;, assigner);</span><br><span class="line">    internal_static_MyMessage_descriptor =</span><br><span class="line">      getDescriptor().getMessageTypes().get(<span class="number">0</span>);</span><br><span class="line">    internal_static_MyMessage_fieldAccessorTable = <span class="keyword">new</span></span><br><span class="line">      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(</span><br><span class="line">        internal_static_MyMessage_descriptor,</span><br><span class="line">        <span class="keyword">new</span> String[] &#123; <span class="string">"DataType"</span>, <span class="string">"Student"</span>, <span class="string">"Worker"</span>, <span class="string">"DataBody"</span>, &#125;);</span><br><span class="line">    internal_static_Student_descriptor =</span><br><span class="line">      getDescriptor().getMessageTypes().get(<span class="number">1</span>);</span><br><span class="line">    internal_static_Student_fieldAccessorTable = <span class="keyword">new</span></span><br><span class="line">      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(</span><br><span class="line">        internal_static_Student_descriptor,</span><br><span class="line">        <span class="keyword">new</span> String[] &#123; <span class="string">"Id"</span>, <span class="string">"Name"</span>, &#125;);</span><br><span class="line">    internal_static_Worker_descriptor =</span><br><span class="line">      getDescriptor().getMessageTypes().get(<span class="number">2</span>);</span><br><span class="line">    internal_static_Worker_fieldAccessorTable = <span class="keyword">new</span></span><br><span class="line">      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(</span><br><span class="line">        internal_static_Worker_descriptor,</span><br><span class="line">        <span class="keyword">new</span> String[] &#123; <span class="string">"Name"</span>, <span class="string">"Age"</span>, &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @@protoc_insertion_point(outer_class_scope)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建BossGroup 和 WorkerGroup</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span></span><br><span class="line">        <span class="comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span></span><br><span class="line">        <span class="comment">//3. 两个都是无限循环</span></span><br><span class="line">        <span class="comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span></span><br><span class="line">        <span class="comment">//   默认实际 cpu核数 * 2</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>) //使用<span class="title">NioSocketChannel</span> 作为服务器的通道实现</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 128) // 设置线程队列得到连接个数</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>) //设置保持活动连接状态</span></span><br><span class="line"><span class="class">//                    .<span class="title">handler</span>(<span class="title">null</span>) // 该 <span class="title">handler</span>对应 <span class="title">bossGroup</span> , <span class="title">childHandler</span> 对应 <span class="title">workerGroup</span></span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;<span class="comment">//创建一个通道初始化对象(匿名对象)</span></span><br><span class="line">                        <span class="comment">//给pipeline 设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline加入ProtoBufDecoder</span></span><br><span class="line">                            <span class="comment">//指定对哪种对象进行解码</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">".....服务器 is ready..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span></span><br><span class="line">            <span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给cf 注册监听器，监控我们关心的事件</span></span><br><span class="line"></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cf.isSuccess()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"监听端口 6668 成功"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"监听端口 6668 失败"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span></span><br><span class="line"><span class="comment">2. 这时我们自定义一个Handler , 才能称为一个handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MyDataInfo</span>.<span class="title">MyMessage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">    2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MyDataInfo.MyMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据dataType 来显示不同的信息</span></span><br><span class="line"></span><br><span class="line">        MyDataInfo.MyMessage.DataType dataType = msg.getDataType();</span><br><span class="line">        <span class="keyword">if</span>(dataType == MyDataInfo.MyMessage.DataType.StudentType) &#123;</span><br><span class="line"></span><br><span class="line">            MyDataInfo.Student student = msg.getStudent();</span><br><span class="line">            System.out.println(<span class="string">"学生id="</span> + student.getId() + <span class="string">" 学生名字="</span> + student.getName());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dataType == MyDataInfo.MyMessage.DataType.WorkerType) &#123;</span><br><span class="line">            MyDataInfo.Worker worker = msg.getWorker();</span><br><span class="line">            System.out.println(<span class="string">"工人的名字="</span> + worker.getName() + <span class="string">" 年龄="</span> + worker.getAge());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"传输的类型不正确"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    //读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line"><span class="comment">//    /*</span></span><br><span class="line"><span class="comment">//    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">//    2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">//     */</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //读取从客户端发送的StudentPojo.Student</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        StudentPOJO.Student student = (StudentPOJO.Student) msg;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println("客户端发送的数据 id=" + student.getId() + " 名字=" + student.getName());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello, 客户端~(&gt;^ω^&lt;)喵1"</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常, 一般是需要关闭通道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>) // 设置客户端通道的实现类(反射)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline中加入 ProtoBufEncoder</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyClientHandler()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"客户端 ok.."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道就绪就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//随机的发送Student 或者 Workder 对象</span></span><br><span class="line">        <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">        MyDataInfo.MyMessage myMessage = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == random) &#123; <span class="comment">//发送Student 对象</span></span><br><span class="line"></span><br><span class="line">            myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.StudentType).setStudent(MyDataInfo.Student.newBuilder().setId(<span class="number">5</span>).setName(<span class="string">"玉麒麟 卢俊义"</span>).build()).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 发送一个Worker 对象</span></span><br><span class="line"></span><br><span class="line">            myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.WorkerType).setWorker(MyDataInfo.Worker.newBuilder().setAge(<span class="number">20</span>).setName(<span class="string">"老李"</span>).build()).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(myMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道有读取事件时，会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"服务器回复的消息:"</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"服务器的地址： "</span>+ ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h3 id="七，Netty编码器和handler的调用机制"><a href="#七，Netty编码器和handler的调用机制" class="headerlink" title="七，Netty编码器和handler的调用机制"></a>七，Netty编码器和handler的调用机制</h3><h4 id="1，基本说明："><a href="#1，基本说明：" class="headerlink" title="1，基本说明："></a>1，基本说明：</h4><ul>
<li><p>netty的组件设计：Netty的主要组件有Channel，EventLoop，ChannelFuture，ChannelHandler，ChannelPipe等</p>
</li>
<li><p>ChannelHandler充当了处理入站和出站数据的应用程序逻辑的容器，例如，实现ChannelInboundHandler接口（或ChannelInboundHandlerAdapter），你就可以接收入站事件和数据，这些数据会被业务逻辑处理，当要给客户端发送响应时，也可以从ChannelInboundHandler冲刷数据。业务逻辑通过写在一个或者多个ChannelInboundHandlerAdapter中。ChannelOutboundHandler原理一样，只不过它是用来处理出站数据的</p>
</li>
<li><p>ChannelPipeline提供了ChannelHandler链的容器，以客户端应用程序为例，如果事件的运动方向是从客户端到服务端，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过pipeline中的一系列ChannelOutboundHandler，并被这些Handler处理，反之则称为入站的</p>
<p><img src="/2021/07/16/netty/45.png" alt="image-20210722171332614"></p>
</li>
</ul>
<h4 id="2，编码解码器"><a href="#2，编码解码器" class="headerlink" title="2，编码解码器"></a>2，编码解码器</h4><ul>
<li>当Netty发送或者接收一个消息的时候，就将会发生一次数据转换，入站消息会被解码：从字节转换为另一种格式（比如Java对象）；如果是出站消息，它会被编码成字节</li>
<li>Netty提供一系列实用的编解码器，他们都实现了ChannelInboundHandler或者ChannelOutboundHandler接口，在这些类中，channelRead方法已经被重写了。以入站为例，对于每个从入站Channel读取的消息，这个方法会被调用。随后，他将调用由解码器所提供的decode（）方法进行解码，并将已经解码的字节转发给ChannelPipeline中的下一个ChannelInboundHandler</li>
</ul>
<h5 id="3，解码器——ByteToMessageDecoder"><a href="#3，解码器——ByteToMessageDecoder" class="headerlink" title="3，解码器——ByteToMessageDecoder"></a>3，解码器——ByteToMessageDecoder</h5><ul>
<li><p>关系继承图：</p>
<p><img src="/2021/07/16/netty/46.png" alt="image-20210722171740774"></p>
</li>
<li><p>由于不可能知道远程结点是否回一次性发送一个完整的信息，TCP有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理</p>
</li>
<li><p>一个关于ByteToMessageDecoder实例分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToInteerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx,ByteBuf in,List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">            out.add(in.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这个例子，每次入站从ByteBuf中读取4字节，将其解码为一个int，然后将它添加到下一个List中。当没有更多元素可以被添加到该List中时，它的内容将会被发送给下一个ChannelInboundHandler。int在被添加到List中时，会被自动装箱到Integer。在调用readInt()方法前必须验证所输入的ByteBuf是否具有足够的数据</p>
</li>
<li><p>decode执行分析图</p>
<p><img src="/2021/07/16/netty/47.png" alt="image-20210722181752704"></p>
</li>
</ul>
</li>
</ul>
<h4 id="4，Netty的handler链的调用机制"><a href="#4，Netty的handler链的调用机制" class="headerlink" title="4，Netty的handler链的调用机制"></a>4，Netty的handler链的调用机制</h4><ul>
<li><p>实例要求：</p>
<ul>
<li>使用自定义的编码器和解码器来说明Netty的handler调用机制<ul>
<li>客户端发送long ——》 服务端</li>
<li>服务端发送long ——》 客户端</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/16/netty/48.png" alt="image-20210722182142441"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>).<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">MyServerInitializer</span>())</span>; <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"从客户端"</span> + ctx.channel().remoteAddress() + <span class="string">" 读取到long "</span> + msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给客户端发送一个long</span></span><br><span class="line">        ctx.writeAndFlush(<span class="number">98765L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();<span class="comment">//一会下断点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//入站的handler进行解码 MyByteToLongDecoder</span></span><br><span class="line">        <span class="comment">//pipeline.addLast(new MyByteToLongDecoder());</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder2());</span><br><span class="line">        <span class="comment">//出站的handler进行编码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line">        <span class="comment">//自定义的handler 处理业务逻辑</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">        System.out.println(<span class="string">"xx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//编码方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"MyLongToByteEncoder encode 被调用"</span>);</span><br><span class="line">        System.out.println(<span class="string">"msg="</span> + msg);</span><br><span class="line">        out.writeLong(msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * decode 会根据接收的数据，被调用多次, 直到确定没有新的元素被添加到list</span></span><br><span class="line"><span class="comment">     * , 或者是ByteBuf 没有更多的可读字节为止</span></span><br><span class="line"><span class="comment">     * 如果list out 不为空，就会将list的内容传递给下一个 channelinboundhandler处理, 该处理器的方法也会被调用多次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 入站的 ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out List 集合，将解码后的数据传给下一个handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"MyByteToLongDecoder 被调用"</span>);</span><br><span class="line">        <span class="comment">//因为 long 8个字节, 需要判断有8个字节，才能读取一个long</span></span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder2</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"MyByteToLongDecoder2 被调用"</span>);</span><br><span class="line">        <span class="comment">//在 ReplayingDecoder 不需要判断数据是否足够读取，内部会进行处理判断</span></span><br><span class="line">        out.add(in.readLong());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">MyClientInitializer</span>())</span>; <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span>  <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器的ip="</span> + ctx.channel().remoteAddress());</span><br><span class="line">        System.out.println(<span class="string">"收到服务器消息="</span> + msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写channelActive 发送数据</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyClientHandler 发送数据"</span>);</span><br><span class="line">        <span class="comment">//ctx.writeAndFlush(Unpooled.copiedBuffer(""))</span></span><br><span class="line">        ctx.writeAndFlush(<span class="number">123456L</span>); <span class="comment">//发送的是一个long</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析</span></span><br><span class="line">        <span class="comment">//1. "abcdabcdabcdabcd" 是 16个字节</span></span><br><span class="line">        <span class="comment">//2. 该处理器的前一个handler 是  MyLongToByteEncoder</span></span><br><span class="line">        <span class="comment">//3. MyLongToByteEncoder 父类  MessageToByteEncoder</span></span><br><span class="line">        <span class="comment">//4. 父类  MessageToByteEncoder</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</span></span><br><span class="line"><span class="comment">        ByteBuf buf = null;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            if (acceptOutboundMessage(msg)) &#123; //判断当前msg 是不是应该处理的类型，如果是就处理，不是就跳过encode</span></span><br><span class="line"><span class="comment">                @SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="comment">                I cast = (I) msg;</span></span><br><span class="line"><span class="comment">                buf = allocateBuffer(ctx, cast, preferDirect);</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    encode(ctx, cast, buf);</span></span><br><span class="line"><span class="comment">                &#125; finally &#123;</span></span><br><span class="line"><span class="comment">                    ReferenceCountUtil.release(cast);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                if (buf.isReadable()) &#123;</span></span><br><span class="line"><span class="comment">                    ctx.write(buf, promise);</span></span><br><span class="line"><span class="comment">                &#125; else &#123;</span></span><br><span class="line"><span class="comment">                    buf.release();</span></span><br><span class="line"><span class="comment">                    ctx.write(Unpooled.EMPTY_BUFFER, promise);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                buf = null;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                ctx.write(msg, promise);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        4. 因此我们编写 Encoder 是要注意传入的数据类型和处理的数据类型一致</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// ctx.writeAndFlush(Unpooled.copiedBuffer("abcdabcdabcdabcd",CharsetUtil.UTF_8));</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个出站的handler 对数据进行一个编码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这时一个入站的解码器(入站handler )</span></span><br><span class="line">        <span class="comment">//pipeline.addLast(new MyByteToLongDecoder());</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder2());</span><br><span class="line">        <span class="comment">//加入一个自定义的handler ， 处理业务</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结论：<ul>
<li>不论解码器handler还是编码器handler即接收的消息类型必须与待处理的消息类型一致，否则该handler不会被执行</li>
<li>在解码器进行数据解码时，需要判断缓存区（ByteBuf）的数据是否足够，否则接收到的结果会期望结果可能不一致</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5，解码器——ReplayingDecoder"><a href="#5，解码器——ReplayingDecoder" class="headerlink" title="5，解码器——ReplayingDecoder"></a>5，解码器——ReplayingDecoder</h4><ul>
<li><p><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></p>
</li>
<li><p>ReplayingDecoder扩展了ByteToMessageDecoder类，使用这个类，我们不必调用readableBytes()方法，参数S指定了用户状态管理的类型，其中Void代表不需要状态管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder2</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"MyByteToLongDecoder2 被调用"</span>);</span><br><span class="line">        <span class="comment">//在 ReplayingDecoder 不需要判断数据是否足够读取，内部会进行处理判断</span></span><br><span class="line">        out.add(in.readLong());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ReplayingDecoder使用方便，但它也有一些局限性：<ul>
<li>并不是所有的ByteBuf操作都被支持，如果调用了一个不被支持的方法，将会抛出一个<code>UnsupportedOpreationException</code></li>
<li>ReplayingDecoder在某些情况下可能稍微慢于ByteToMessageDecoder，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6，其他编解码器"><a href="#6，其他编解码器" class="headerlink" title="6，其他编解码器"></a>6，其他编解码器</h4><ul>
<li><code>LineBaseFrameDecoder</code>：这个类在Netty内部也有使用，它使用行尾控制字符（\n 或者\r \n）作为分隔符来解析数据</li>
<li><code>DelimiterBaseFrameDecoder</code>：使用自定义的特殊字符作为消息的分隔符</li>
<li><code>HttpObjectDecoder</code>：一个HTTP数据的解码器</li>
<li><code>LengthFieldBaseFrameDecoder</code>：通过指定长度来标识整包消息，这样就可以自动的处理粘包和半包消息</li>
</ul>
<p><img src="/2021/07/16/netty/49.png" alt="image-20210722230943867"></p>
<h4 id="7，Log4j整合到Netty"><a href="#7，Log4j整合到Netty" class="headerlink" title="7，Log4j整合到Netty"></a>7，Log4j整合到Netty</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;dependency&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;groupId&gt;log4j&lt;/groupId&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;artifactId&gt;log4j&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;version&gt;1.2.17&lt;/version&gt;--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;/dependency&gt;--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;dependency&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;groupId&gt;org.slf4j&lt;/groupId&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;version&gt;1.7.25&lt;/version&gt;--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;/dependency&gt;--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;dependency&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;groupId&gt;org.slf4j&lt;/groupId&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;version&gt;1.7.25&lt;/version&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;/dependency&gt;--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;dependency&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;groupId&gt;org.slf4j&lt;/groupId&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;version&gt;1.7.25&lt;/version&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;/dependency&gt;--&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#log4j.rootLogger=DEBUG, stdout</span></span><br><span class="line"><span class="comment">#log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="comment">#log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="comment">#log4j.appender.stdout.layout.ConversionPattern=[%p] %C&#123;1&#125; - %m%n</span></span><br></pre></td></tr></table></figure>





<h3 id="八，TCP粘包和拆包及解决方案"><a href="#八，TCP粘包和拆包及解决方案" class="headerlink" title="八，TCP粘包和拆包及解决方案"></a>八，TCP粘包和拆包及解决方案</h3><h4 id="1，TCP粘包和拆包基本介绍"><a href="#1，TCP粘包和拆包基本介绍" class="headerlink" title="1，TCP粘包和拆包基本介绍"></a>1，TCP粘包和拆包基本介绍</h4><ul>
<li><p>TCP是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提供了效率，但是接收端就难于分辨出完成的数据包了，因为面向流的通信是无消息保护边界的</p>
</li>
<li><p>由于TCP无消息保护边界，需要在接收端处理消息边界问题，也就是我们所说的粘包，拆包问题</p>
</li>
<li><p>TCP粘包，拆包图解</p>
<p><img src="/2021/07/16/netty/50.png" alt="image-20210723115508470"></p>
<ul>
<li>假设客户端分别发送了两个数据报D1和D2给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：<ul>
<li>服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包</li>
<li>服务端一次接受到了两个数据包，D1和D2粘合在一起，称之为TCP粘包</li>
<li>服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为TCP拆包</li>
<li>服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2，TCP粘包和拆包现象实例"><a href="#2，TCP粘包和拆包现象实例" class="headerlink" title="2，TCP粘包和拆包现象实例"></a>2，TCP粘包和拆包现象实例</h4><ul>
<li><p>在编写Netty程序时，如果没有做处理，就会发生粘包和拆包的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>).<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">MyServerInitializer</span>())</span>; <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//cause.printStackTrace();</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将buffer转成字符串</span></span><br><span class="line">        String message = <span class="keyword">new</span> String(buffer, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器接收到数据 "</span> + message);</span><br><span class="line">        System.out.println(<span class="string">"服务器接收到消息量="</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务器回送数据给客户端, 回送一个随机id ,</span></span><br><span class="line">        ByteBuf responseByteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="string">" "</span>, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line">        ctx.writeAndFlush(responseByteBuf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">MyClientInitializer</span>())</span>; <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用客户端发送10条数据 hello,server 编号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(<span class="string">"hello,server "</span> + i, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line">            ctx.writeAndFlush(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(buffer);</span><br><span class="line"></span><br><span class="line">        String message = <span class="keyword">new</span> String(buffer, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line">        System.out.println(<span class="string">"客户端接收到消息="</span> + message);</span><br><span class="line">        System.out.println(<span class="string">"客户端接收消息数量="</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







</li>
</ul>
<h4 id="3，TCP粘包和拆包解决方案"><a href="#3，TCP粘包和拆包解决方案" class="headerlink" title="3，TCP粘包和拆包解决方案"></a>3，TCP粘包和拆包解决方案</h4><ul>
<li><p>使用自定义协议+编码器来解决</p>
</li>
<li><p>关键就是要解决服务器端每次读取数据长度的问题，这个问题解决就不会出现服务器多读或少读数据的问题，从而避免的TCP粘包，拆包</p>
</li>
<li><p>案例实例；</p>
<ul>
<li><p>要求客户端发送5个Message对象，客户端每次发送一个Message对象</p>
</li>
<li><p>服务器端每次接受一个Message，分5次进行解码，每读取到一个Message，会回复一个Message对象给客户端</p>
<p><img src="/2021/07/16/netty/51.png" alt="image-20210723120355909"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>).<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">MyServerInitializer</span>())</span>; <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理业务的handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageProtocol</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//cause.printStackTrace();</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收到数据，并处理</span></span><br><span class="line">        <span class="keyword">int</span> len = msg.getLen();</span><br><span class="line">        <span class="keyword">byte</span>[] content = msg.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"服务器接收到信息如下"</span>);</span><br><span class="line">        System.out.println(<span class="string">"长度="</span> + len);</span><br><span class="line">        System.out.println(<span class="string">"内容="</span> + <span class="keyword">new</span> String(content, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器接收到消息包数量="</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line"></span><br><span class="line">        String responseContent = UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">int</span> responseLen = responseContent.getBytes(<span class="string">"utf-8"</span>).length;</span><br><span class="line">        <span class="keyword">byte</span>[]  responseContent2 = responseContent.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="comment">//构建一个协议包</span></span><br><span class="line">        MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">        messageProtocol.setLen(responseLen);</span><br><span class="line">        messageProtocol.setContent(responseContent2);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(messageProtocol);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder());<span class="comment">//解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder());<span class="comment">//编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协议包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len; <span class="comment">//关键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLen</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.len = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getContent() &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(<span class="keyword">byte</span>[] content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">MyClientInitializer</span>())</span>; <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用客户端发送10条数据 "今天天气冷，吃火锅" 编号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String mes = <span class="string">"今天天气冷，吃火锅"</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] content = mes.getBytes(Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line">            <span class="keyword">int</span> length = mes.getBytes(Charset.forName(<span class="string">"utf-8"</span>)).length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建协议包对象</span></span><br><span class="line">            MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">            messageProtocol.setLen(length);</span><br><span class="line">            messageProtocol.setContent(content);</span><br><span class="line">            ctx.writeAndFlush(messageProtocol);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = msg.getLen();</span><br><span class="line">        <span class="keyword">byte</span>[] content = msg.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"客户端接收到消息如下"</span>);</span><br><span class="line">        System.out.println(<span class="string">"长度="</span> + len);</span><br><span class="line">        System.out.println(<span class="string">"内容="</span> + <span class="keyword">new</span> String(content, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"客户端接收消息数量="</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异常消息="</span> + cause.getMessage());</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder()); <span class="comment">//加入编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder()); <span class="comment">//加入解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyMessageDecoder decode 被调用"</span>);</span><br><span class="line">        <span class="comment">//需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)</span></span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理</span></span><br><span class="line">        MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">        messageProtocol.setLen(length);</span><br><span class="line">        messageProtocol.setContent(content);</span><br><span class="line"></span><br><span class="line">        out.add(messageProtocol);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyMessageEncoder encode 方法被调用"</span>);</span><br><span class="line">        out.writeInt(msg.getLen());</span><br><span class="line">        out.writeBytes(msg.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="九，Netty核心源码剖析"><a href="#九，Netty核心源码剖析" class="headerlink" title="九，Netty核心源码剖析"></a>九，Netty核心源码剖析</h3><h4 id="1，Netty启动过程源码剖析"><a href="#1，Netty启动过程源码剖析" class="headerlink" title="1，Netty启动过程源码剖析"></a>1，Netty启动过程源码剖析</h4><h5 id="a，源码剖析目的"><a href="#a，源码剖析目的" class="headerlink" title="a，源码剖析目的"></a>a，源码剖析目的</h5><ul>
<li>用源码剖析的方式走一下Netty（服务器）的启动过程，更好的理解Netty的整体设计和运行机制</li>
</ul>
<h5 id="b，源码剖析——demo源码的基本理解"><a href="#b，源码剖析——demo源码的基本理解" class="headerlink" title="b，源码剖析——demo源码的基本理解"></a>b，源码剖析——demo源码的基本理解</h5><ul>
<li><p>源码需要剖析到Netty调用doBind方法，追踪到NioServerSocketChannel的doBind</p>
</li>
<li><p>并且要Debug程序到NioEventLoop类的run代码，无限循环，在服务器端运行</p>
<p><img src="/2021/07/16/netty/52.png" alt="image-20210724001724702"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Echoes back any received data from a client.</span></span><br><span class="line"><span class="comment">服务端启动类源码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SSL = System.getProperty(<span class="string">"ssl"</span>) != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">"port"</span>, <span class="string">"8007"</span>));</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Configure SSL.</span></span><br><span class="line">        <span class="keyword">final</span> SslContext sslCtx; <span class="keyword">if</span> (SSL) &#123;</span><br><span class="line">            SelfSignedCertificate ssc = <span class="keyword">new</span> SelfSignedCertificate();</span><br><span class="line">            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sslCtx = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Configure the server.</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>); </span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); </span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 100)</span></span><br><span class="line"><span class="class">                .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">                .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123; </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline p = ch.pipeline();           </span><br><span class="line">                        <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123; </span><br><span class="line">                            p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO)); </span></span><br><span class="line">                        p.addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="comment">// Start the server.</span></span><br><span class="line">            ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line">            <span class="comment">// Wait until the server socket is closed. </span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads. </span></span><br><span class="line">            bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>先看启动类：main方法中，首先创建了关于SSL的配置类</p>
</li>
<li><p>重点分析创建了两个EventLoopGroup对象：</p>
<ul>
<li><p><code>EventLoopGroup bossGroup = new NioEventLoopGroup(1);</code></p>
</li>
<li><p><code>EventLoopGroup workerGroup = new NioEventLoopGroup();</code></p>
<ol>
<li><p>这两个对象是整个Netty的核心对象，可以说，整个Netty的运作都依赖于他们。bossGroup用于接受TCP请求，他会将请求交给workerGroup，workerGroup会获取真正的连接，然后和连接进行通信，比如读写解码编码等操作</p>
</li>
<li><p>EventLoopGroup是事件循环组（线程组）含有多个EventLoop，可以注册channel，用于在事件循环中去进行选择（和选择器相关）</p>
</li>
<li><p><code>new NioEventLoopGroup(1)</code>：这个1表示bossGroup事件组有1个线程，你可以指定，如果<code>new NioEventLoopGroup()</code>会含有默认个线程 cpu核数 * 2，即可以充分的利用多核的优势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>,SystemPropertyUtil.getInt(<span class="string">"io.netty.eventLoopThreads"</span>,NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>会创建EventExecutor数组<code>children = new EventExecutor[nThreads];</code></p>
<p>每个元素的类型就是NioEventLoop，NioEventLoop实现了EventLoop接口和Executor接口，try块中创建了一个ServerBootstrap对象，他是一个引导类，用于启动服务器和引导整个程序的初始化。它和ServerChannel关联，而ServerChannel继承了Channel，有一些方法remoteAddress等，随后，变量b调用了group方法将两个group放入了自己的字段中，用于后期引导使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Set the &#123;<span class="doctag">@link</span> EventLoopGroup&#125; for the parent (acceptor) and the child (client). These &#123;<span class="doctag">@link</span> EventLoopGroup&#125;'s are used to handle all the events and IO for &#123;<span class="doctag">@link</span> ServerChannel&#125; and &#123;<span class="doctag">@link</span> Channel&#125;'s.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后添加了一个channel，其中参数一个Class对象，引导类将通过这个Class对象反射创建ChannelFactory。然后添加了一些TCP的参数。【说明：Channel的创建在bind方法，可以Debug下bind，会找到<code>channel = channelFactory.newChannel();</code>】</p>
</li>
<li><p>再添加了一个服务器专属的日志处理器handler</p>
</li>
<li><p>再添加一个SocketChannel（不是ServerSocketChannel）的handler</p>
</li>
<li><p>然后绑定端口并阻塞至连接成功</p>
</li>
<li><p>最后main线程阻塞等待关闭</p>
</li>
<li><p>finally块中的代码将在服务器关闭时优雅关闭所有资源</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端处理器源码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Copyright 2012 The Netty Project</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*The Netty Project licenses this file to you under the Apache License,</span></span><br><span class="line"><span class="comment">*version 2.0 (the "License"); you may not use this file except in compliance</span></span><br><span class="line"><span class="comment">*with the License. You may obtain a copy of the License at:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">*distributed under the License is distributed on an "AS IS" BASIS, WITHOUT</span></span><br><span class="line"><span class="comment">*WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span></span><br><span class="line"><span class="comment">*License for the specific language governing permissions and limitations</span></span><br><span class="line"><span class="comment">*under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> atguigu.netty.example.echo2;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler.Sharable;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Handler implementation for the echo server.</span></span><br><span class="line"><span class="comment">*/</span> <span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ctx.write(msg);	</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="meta">@Override</span>	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;	</span><br><span class="line">        ctx.flush();	</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="meta">@Override</span>	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;	</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.	</span></span><br><span class="line">        cause.printStackTrace();	</span><br><span class="line">        ctx.close();	</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是一个普通的处理器类，用于处理客户端发送来的消息，在我们这里，我们简单的解析出客户端传过来的内容，然后打印，最后发送字符串给客户端</li>
</ul>
<h5 id="c，源码剖析——分析EventLoopGroup"><a href="#c，源码剖析——分析EventLoopGroup" class="headerlink" title="c，源码剖析——分析EventLoopGroup"></a>c，源码剖析——分析EventLoopGroup</h5><ul>
<li><p>构造器方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads,(Executor)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的<code>this(nThreads,(Executor)null);</code>调用下面构造器（通过alt+d看）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads,Executor executor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads,executor,SelectorProvider.provider());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的<code>this(nThreads,executor,SelectorProvider.provider());</code>调用下面构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads,Executor executor,<span class="keyword">final</span> SelectorProvider selectorProvider)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(nThreads,executor,selectorProvider,DefaultSelectStrategyFactory.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的<code>this(nThreads,executor,selectorProvider,DefaultSelectStrategyFactory.INSTANCE);</code>调用下面构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads,Executor executor,<span class="keyword">final</span> SelectorProvider selectorProvider,<span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads,executor,selectorProvider,selectStrategyFactory,RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的<code>super(nThreads,executor,selectorProvider,selectStrategyFactory,RejectedExecutionHandlers.reject());</code>的方法的父类<code>MultithreadEventLoopGroup</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads,Executor executor,Object... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads,executor,args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>追踪到源码抽象类<code>MultithreadEventExecutorGroup</code>的构造器方法<code>MultithreadEventExecutorGroup</code>才是<code>NioEventLoopGroup</code>真正的构造方法，这里可以看成是一个模板方法，使用了设计模式的模板方法，所以，我们就需要好好分析<code>MultithreadEventExecutorGroup</code>方法了</p>
</li>
<li><p>分析<code>MultithreadEventExecutorGroup</code></p>
<ul>
<li>参数说明：<ul>
<li><code>nThreads</code>：使用的线程数，默认为core * 2</li>
<li><code>executor</code>：执行器，如果传入null，则采用Netty默认的线程工厂和默认的执行器<code>ThreadPerTaskExecutor</code></li>
<li><code>chooserFactory</code>：单例<code>new DefaultEventExecutorChooserFactory()</code></li>
<li><code>args</code>：args在创建执行器的时候传入固定参数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"nThreads: %d (expected: &gt; 0)"</span>, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123; <span class="comment">//如果传入的执行器是空的则采用默认的线程工厂和默认的执行器</span></span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建指定线程数的执行器数组 </span></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line">    <span class="comment">//初始化线程数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创 建 new NioEventLoop</span></span><br><span class="line">            children[i] = newChild(executor, args); success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type       </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果创建失败，优雅关闭</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    EventExecutor e = children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        <span class="comment">// Let the caller handle the interruption. Thread.currentThread().interrupt(); break;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="keyword">null</span>);	</span><br><span class="line">            &#125;	</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;;	</span><br><span class="line">    <span class="comment">//为每一个单例线程池添加一个关闭监听器	</span></span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;	</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);	</span><br><span class="line">    &#125;	</span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);	</span><br><span class="line">    <span class="comment">//将所有的单例线程池添加到一个 HashSet 中。	</span></span><br><span class="line">    Collections.addAll(childrenSet, children);	</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果executor是null，创建一个默认的ThreadPerTaskExecutor，使用Netty默认的线程工厂</li>
<li>根据传入的线程数（CPU*2）创建一个线程池（单例线程池）数组</li>
<li>循环填充数组中的元素，如果异常，则关闭所有的单例线程池</li>
<li>根据线程选择工厂创建一个线程选择器</li>
<li>为每一个单例线程池添加一个关闭监听器</li>
<li>将所有的单例线程池添加到一个HashSet中</li>
</ul>
</li>
</ul>
<h5 id="d，源码剖析——ServerBootstrap创建和构造过程"><a href="#d，源码剖析——ServerBootstrap创建和构造过程" class="headerlink" title="d，源码剖析——ServerBootstrap创建和构造过程"></a>d，源码剖析——ServerBootstrap创建和构造过程</h5><ul>
<li><p>ServerBootstrap是一个空构造，但是有默认的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="keyword">new</span> LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();	</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="keyword">new</span> LinkedHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();</span><br><span class="line"><span class="comment">//config 对象，会在后面起很大作用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerBootstrapConfig config = <span class="keyword">new</span> ServerBootstrapConfig(<span class="keyword">this</span>); <span class="keyword">private</span> <span class="keyword">volatile</span> EventLoopGroup childGroup;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler childHandler;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析一下ServerBootstrap基本使用情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 100)</span></span><br><span class="line"><span class="class">    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">            ChannelPipeline p = ch.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123; </span><br><span class="line">                p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">            p.addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>链式调用：group方法，将boss和worker传入，boss赋值给parentGroup属性，worker赋值给childGroup属性</li>
<li>channel方法传入NioServerSocketChannel class对象，会根据这个class创建channel对象</li>
<li>option方法传入TCP参数，放在一个LinkedHashMap中</li>
<li>handler方法传入一个handler中，这个handler只专属于ServerSocketChannel而不是SocketChannel</li>
<li>childHandler传入一个handler，这个handler将会在每个客户端连接的时候调用，供SocketChannel使用</li>
</ul>
</li>
</ul>
<h5 id="e，源码剖析——绑定端口的分析："><a href="#e，源码剖析——绑定端口的分析：" class="headerlink" title="e，源码剖析——绑定端口的分析："></a>e，源码剖析——绑定端口的分析：</h5><ul>
<li><p><strong>服务器就是在这个bind方法里启动完成的</strong></p>
</li>
<li><p><strong>bind方法代码，追踪到创建了一个端口对象，并做了一些空判断，核心代码doBind</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doBind(localAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>doBind源码剖析，核心是两个方法initAndRegister和doBind0</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister(); </span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// At this point we know that the registration was complete and successful. ChannelPromise promise = channel.newPromise();                 //============================================</span></span><br><span class="line">        <span class="comment">//说明:执行 doBind0  方法，完成对端口的绑定                       //============================================</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not</span></span><br><span class="line">                    <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel. promise.setFailure(cause);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/2586 promise.registered();</span></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分析说明initAndRegister</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();<span class="comment">//NioServerSocketChannel</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123; </span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>	<span class="keyword">new</span>	DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel); </span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>channel = channelFactory.newChannel();</code>：通过ServerBootstrap的通道工厂反射创建一个NioServerSocketChannel<ul>
<li>通过NIO的SelectorProvider的openServerSocketChannel方法得到JDK的channel。目的是让Netty包装JDK的channel</li>
<li>创建了一个唯一的ChannelId，创建了一个NioMessageUnsafe，用于操作消息，创建了一个DefaultChannelPipeline管道，是一个双向链表结构，用于过滤所有的进出的消息</li>
<li>创建了一个NioServerSocketChannelConfig对象，用于对外展示一些配置</li>
</ul>
</li>
<li><code>init(channel);</code>初始化这个NioServerSocketChannel<ul>
<li>init方法，这是个抽象方法（AbstractBootstrap类），由ServerBootstrap实现（<code>setChannelOptions(channel,options,logger);</code>）</li>
<li>设置NioServerSocketChannel的TCP属性</li>
<li>由于LinkedHashMap是非线程安全的，使用同步进行处理</li>
<li>对NioServerSocketChannel的ChannelPipeline添加ChannelInitializer处理器</li>
<li>可以看出，init的方法核心作用在和ChannelPipeline相关</li>
<li>从NioServerSocketChannel的初始化过程中，我们知道，pipeline是一个双向链表，并且他本身就初始化了head和tail，这里调用了他的allLast方法，也就是将整个handler插入到tail的前面，因为tail永远会在后面，需要做一些系统的固定工作</li>
</ul>
</li>
<li>对<code>initAndRegister</code>的分析说明：<ul>
<li>基本说明：initAndRegister（）初始化NioServerSocketChannel通道并注册各个handler，返回一个future</li>
<li>通过ServerBootstrap的通道工厂反射创建一个NioServerSocketChannel</li>
<li>init初始化这个NioServerSocketChannel</li>
<li>config().group.register(channel)通过ServerBootstrap的bossGroup注册NioServerSocketChannel</li>
<li>最后，返回这个异步执行的占位符即regFuture</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>init方法会调用addLast，现在进入到addLast方法内查看</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">        addLast0(newCtx);</span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            newCtx.setAddPending(); </span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="keyword">true</span>); <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">            newCtx.setAddPending(); </span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span>	</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    callHandlerAdded0(newCtx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>addLast方法，在DefaultChannelPipeline类中</li>
<li>addLast方法这就是pipeline方法的核心</li>
<li>检查该handler是否符合标准</li>
<li>创建一个AbstractChannelHandlerContext对象，这里说一下，ChannelHandlerContext对象是ChannelHandler和ChannelPipeline之间关联，每当有ChannelHandler添加到Pipeline中时，都会创建Context。Context的主要功能是管理他所关联的Handler和同一个Pipeline中的其他Handler之间的交互</li>
<li>将Context添加到链表中，也就是追加到tail节点的前面</li>
<li>最后，同步或者异步或者晚点异步的调用callHandlerAdded0方法</li>
</ul>
</li>
<li><p>前面说了dobind方法有2个重要的步骤，initAndRegister说完，接下来看doBind0方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This method is invoked before channelRegistered() is triggered.	Give user handlers a chance to set up	</span></span><br><span class="line">    <span class="comment">// the pipeline in its channelRegistered() implementation.	</span></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;	</span><br><span class="line">        <span class="meta">@Override</span>	</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;	</span><br><span class="line">                <span class="comment">//bind 方法这里下断点，这里下断点，来玩!!	</span></span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);	</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;	</span><br><span class="line">                promise.setFailure(regFuture.cause());	</span><br><span class="line">            &#125;	</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该方法的参数initAndRegister的future，NioServerSocketChannel，端口地址，NioServerSocketChannel的promise</p>
</li>
<li><p>这里就可以根据前面下的断电，一直debug</p>
<ul>
<li>将调用 LoggingHandler 的 invokeBind  方法,  最后会追到DefaultChannelPipeline 类的 bind然后进入到 unsafe.bind 方法 debug ,  注意要追踪到 unsafe.bind , 要 debug 第二圈的时候，才能看到.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;		</span><br><span class="line">    unsafe.bind(localAddress, promise);		</span><br><span class="line">&#125;		</span><br><span class="line"><span class="comment">//继续追踪 AbstractChannel  的		</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;		</span><br><span class="line">    <span class="comment">//....		</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;		</span><br><span class="line">        <span class="comment">//!!!!小红旗 可以看到，这里最终的方法就是 doBind 方法，执行成功后，执行通道的		</span></span><br><span class="line">        <span class="comment">//fireChannelActive 方法，告诉所有的 handler，已经成功绑定。		</span></span><br><span class="line">            doBind(localAddress);<span class="comment">//		</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;		</span><br><span class="line">        safeSetFailure(promise, t);		</span><br><span class="line">        closeIfClosed();		</span><br><span class="line">        <span class="keyword">return</span>;		</span><br><span class="line">    &#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终doBind就会追踪到NioServerSocketChannel的doBind，说明Netty底层使用的Nio</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>回到bind方法（alt+v），最后一步：<code>safeSetSuccess(promise)</code>，告诉promise任务成功了，其可以执行监听器的方法了，到此整个启动过程已经结束了</p>
</li>
<li><p>继续alt+V服务器就会进入的（NioEventLoop类）一个循环代码，进行监听</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="f，Netty启动过程梳理"><a href="#f，Netty启动过程梳理" class="headerlink" title="f，Netty启动过程梳理"></a>f，Netty启动过程梳理</h5><ul>
<li>创建2个EventLoopGroup线程池数组，数组默认大小 CPU * 2，方便chooser选择线程池时提高性能</li>
<li>BootStrap将boss设置为group属性，将worker设置为childer属性</li>
<li>通过bind方法启动，内部重要方法为initAndRegister和dobind方法</li>
<li>initAndRegister方法会反射创建NioServerSocketChannel及其相关的NIO的对象，pipeline，unsafe，同时也为pipeline初始了heal节点和tail节点</li>
<li>在register（）方法成功以后调用在dobind方法中调用doBind()方法，该方法会调用NioServerSocketChannel的doBind方法对JDK的channel和端口进行绑定，完成Netty服务器的所有启动，并开始监听连接事件</li>
</ul>
<h4 id="2，Netty接受请求过程源码剖析"><a href="#2，Netty接受请求过程源码剖析" class="headerlink" title="2，Netty接受请求过程源码剖析"></a>2，Netty接受请求过程源码剖析</h4><h5 id="a，源码剖析的目的"><a href="#a，源码剖析的目的" class="headerlink" title="a，源码剖析的目的"></a>a，源码剖析的目的</h5><ul>
<li>服务器启动后肯定是要接受客户端请求并返回客户端想要的信息的，下面源码分析Netty在启动之后是如何接受客户端请求的</li>
</ul>
<h5 id="b，源码剖析"><a href="#b，源码剖析" class="headerlink" title="b，源码剖析"></a>b，源码剖析</h5><blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li>从之前服务器启动的源码中，我们得知，服务器最终注册了一个Accept事件等待客户端的连接，我们也知道，NioServerSocketChannel将自己注册到boss单例线程池（reactor线程）上，也就是EventLoop</li>
<li>先简单说下，EventLoop的逻辑</li>
<li>EventLoop的作用是一个死循环，而这个循环中做3件事情：<ul>
<li>有条件的等待Nio事件</li>
<li>处理Nio事件</li>
<li>处理消息队列中的任务</li>
</ul>
</li>
<li>仍用前面的项目来分析：进入到NioEventLoop源码中后，在<code>private void processSelectedKey(SelectionKey k,AbstractNioChannel ch)</code>方法开始调试最终我们要分析到AbstractNioChannel的doBeginRead方法，当到这个方法时，针对于这个客户端连接就完成了，接下里就可以监听读事件了</li>
</ul>
</blockquote>
<ul>
<li><p>断点位置NioEventLoop的如下方法proecssSelectedKey</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123; </span><br><span class="line">    unsafe.read(); <span class="comment">//断点位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行浏览器<a href="http://localhost:8007，客户端发出请求">http://localhost:8007，客户端发出请求</a></p>
</li>
<li><p>从断点我们可以看出，readyOps是16，也就是Accept事件，说明浏览器的请求已经进来了</p>
</li>
<li><p>这个unsafe是boss线程中NioServerSocketChannel的AbstractNioMessageChannel $ NioMessageUnsafe对象。我们进入到AbstractNioMessageChannel $ NioMessageUnsafe的read方法中</p>
</li>
<li><p>read方法代码并分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle(); </span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>; </span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">                <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;	</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123; </span><br><span class="line">                    closed = <span class="keyword">true</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            exception = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123; </span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        readBuf.clear();</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closed = closeOnReadError(exception);</span><br><span class="line">            pipeline.fireExceptionCaught(exception);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">                close(voidPromise());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Check if there is a readPending which was not processed yet.</span></span><br><span class="line">        <span class="comment">// This could be for two reasons:</span></span><br><span class="line">        <span class="comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span></span><br><span class="line">        <span class="comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...)</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/2254</span></span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>检查该eventloop线程是否是当前线程<code>assert eventLoop().inEventLoop()</code></li>
<li>执行doReadMessage方法，并传入一个readBuf变量，这个变量是一个List，也就是容器</li>
<li>循环容器，执行<code>pipeline.fireChannelRead(readBuf.get(i));</code></li>
<li>doReadMessages是读取boss线程中NioServerSocketChannel接受到的请求，并把这些请求放进容器</li>
<li>循环遍历容器中的所有请求，调用pipeline中fireChannelRead方法，用于处理这些接受的请求或者其他事件，在read方法中，循环调用ServerSocket的pipeline的fireChannelRead方法，开始执行管道中的handler的ChannelRead方法</li>
</ul>
</li>
<li><p>追踪一下doReadMessages方法，就可以看得更清晰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">    buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过工具类，调用NioServerSocketChannel内部封装的ServerSocketChannel的accept方法，这是Nio做法</li>
<li>获取到一个JDK的SocketChannel，然后使用NioSocketChannel进行封装，最后添加到容器中</li>
<li>这样容器buf中就有NioSocketChannel</li>
</ul>
</li>
<li><p>回到read方法，继续分析循环执行<code>pipeline.fireChannelRead</code>方法</p>
<ul>
<li><p>前面分析doReadMessages方法的作用是通过ServerSocket的accept方法获取到TCP连接，然后封装成Netty的NioSocketChannel对象，最后添加到容器中</p>
</li>
<li><p>在read方法中，循环调用ServerSocket的pipeline的fireChannelRead方法，开始执行管道中的handler的ChannelRead方法</p>
</li>
<li><p>经过debug，可以看到会反复执行多个handler的ChannelRead，我们知道，pipeline里面又4个handler，分别是Head，LoggingHandler，ServerBootstrapAcceptor，Tail</p>
</li>
<li><p>我们重点看看ServerBootstrapAcceptor，debug之后，断电会进入到ServerBootstrapAcceptor中来，我们来看看ServerBootstrapAccesstor的channelRead方法</p>
</li>
<li><p>channelRead方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Obprotected <span class="keyword">int</span> doReadMessages(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">    buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">                        ject msg) &#123;</span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123; </span><br><span class="line">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//将客户端连接注册到 worker 线程池</span></span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123; </span><br><span class="line">        forceClose(child, t);	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>msg强转成Channel，实际上就是NioSocketChannel</li>
<li>添加NioSocketChannel的pipeline的handler，就是我们main方法里面设置的childHanlder方法里的</li>
<li>设置NioSocketChannel的各种属性</li>
<li>将该NioSocketChannel注册到childGroup中的一个EventLoop上，并添加一个监听器</li>
<li>这个childGroup就是我们main方法创建的数组workerGroup</li>
</ul>
</li>
</ul>
</li>
<li><p>进入register方法查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123; </span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                register0(promise);<span class="comment">//进入到这里	</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//继续进入到 下面方法， 执行管道中可能存在的任务, 这里我们就不追了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最终会调用deBeginRead方法，也就是AbstractNioChannel类的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>	</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;	</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called	</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey; <span class="comment">//断点	</span></span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;	</span><br><span class="line">        <span class="keyword">return</span>;	</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();	</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;	</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);	</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个地方调试时，请把前面的断点都去掉，然后启动服务器就会停止在doBeginRead（需要先放过该断点，然后浏览器请求，才能看到效果）</p>
</li>
<li><p>执行到这里时，针对这个客户端的连接就完成了，接下来就可以监听读事件了</p>
</li>
</ul>
<h5 id="c，Netty接受请求过程梳理："><a href="#c，Netty接受请求过程梳理：" class="headerlink" title="c，Netty接受请求过程梳理："></a>c，Netty接受请求过程梳理：</h5><ul>
<li>总体流程：接受连接——》创建一个新的NioSocketChannel ——》注册到一个workerEventLoop上——》注册selector Read事件</li>
<li>服务器轮询Accept事件，获取事件后调用unsafe的read方法，这个unsafe是ServerSocket的内部类，该方法内部由2部分组成</li>
<li>doReadMessages用于创建NioSocketChannel对象，该对象包装JDK的NioChannel客户端，该方法会像创建ServerSocketChannel类似创建相关的pipeline，unsafe，config</li>
<li>随后执行pipeline.fireChannelRead方法，并将自己绑定到一个chooser选择器选择的workerGroup中的一个EventLoop，并注册一个0，表示注册成功，但没有注册读（1）事件</li>
</ul>
<h4 id="3，Pipeline-Handler-HandlerContext创建源码剖析"><a href="#3，Pipeline-Handler-HandlerContext创建源码剖析" class="headerlink" title="3，Pipeline | Handler | HandlerContext创建源码剖析"></a>3，Pipeline | Handler | HandlerContext创建源码剖析</h4><h5 id="a，源码剖析目的："><a href="#a，源码剖析目的：" class="headerlink" title="a，源码剖析目的："></a>a，源码剖析目的：</h5><ul>
<li>Netty中ChannelPipeline，ChannelHandler和ChannelHandlerContext是非常核心的组件，我们从源码来分析Netty是如何设计这三个核心组件，并分析是如何创建和协调工作的·</li>
</ul>
<h5 id="b，ChannelPipeline-ChannelHandler-ChannelHandlerContext介绍"><a href="#b，ChannelPipeline-ChannelHandler-ChannelHandlerContext介绍" class="headerlink" title="b，ChannelPipeline | ChannelHandler | ChannelHandlerContext介绍"></a>b，ChannelPipeline | ChannelHandler | ChannelHandlerContext介绍</h5><ul>
<li><p>三者关系：</p>
<ul>
<li><p>每当ServerSocket创建一个新的连接，就会创建一个Socket，对应的就是目标客户端</p>
</li>
<li><p>每一个新创建的Socket都将会分配一个全新的ChannelPipeline</p>
</li>
<li><p>每个ChannelPipeline内部都含有多个ChannelHandlerContext</p>
</li>
<li><p>他们一起组成了双向链表，这些Context用于包装我们调用addLast方法时添加的ChannelHandler</p>
<p><img src="/2021/07/16/netty/53.png" alt="image-20210724171924637"></p>
<ul>
<li>上图中：ChannelSocket和ChannelPipeline是一对一的关联关系，而pipeline内部的多个Context形成了链表：Context只是对Handler的封装</li>
<li>当一个请求进来的时候，会进入Socket对应的pipeline，并经过pipeline所有的handler对，就是设计模式中的过滤器模式</li>
</ul>
</li>
</ul>
</li>
<li><p>ChannelPipeline作用及设计</p>
<ul>
<li><p>pipeline接口设计</p>
<p><img src="/2021/07/16/netty/54.png" alt="image-20210724172215446"></p>
<p><img src="/2021/07/16/netty/55.png" alt="image-20210724172257867"></p>
<p>可以看到该接口继承了inBound，outBound，Iterable接口，表示他可以调用数据出站和入站的方法，同时也能遍历内部的链表，看看他的几个代表性的方法，基本上都是针对handler链表的插入，追加，删除，替换操作，类似是一个LinkedList。同时，也能返回channel（也就是socket）</p>
</li>
<li><p>在pipeline的接口文档上，提供了一幅图</p>
<p><img src="/2021/07/16/netty/56.png" alt="image-20210724172644171"></p>
<ul>
<li><p>这是一个handler的list，handler用于处理或拦截入站事件和出站事件，pipeline实现了过滤器的高级形式，以便用户控制事件如何处理以及handler在pipeline中如何交互</p>
</li>
<li><p>上图描述了一个典型的handler在pipeline中处理I/O事件的方式，IO事件由inboundHandler或者outBoundHandler处理，并通过调用ChannelHandlerContext.fireChannelRead方法转发给其最近的处理程序</p>
</li>
<li><p>入站事件由入站处理程序以自下而上的方向处理，如图所示，入站处理程序通常处理由图底部的I/O线程生成入站数据，入站数据通常从如SocketChannel.read(ByteBuffer)获取</p>
</li>
<li><p>通常一个pipeline有多个handler，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序协议解码器——将二进制数据转换成Java对象</p>
</li>
<li><p>业务逻辑处理程序 —— 执行实际业务逻辑（例如数据库访问）</p>
</li>
<li><p>你的业务程序不能将线程阻塞，会影响IO的速度，进而影响整个Netty程序的性能，如果你的业务程序很快，就可以放在IO线程中，反之，你需要异步执行，或者在添加handler的时候添加一个线程池，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这个任务执行的时候，将不会阻塞IO线程，执行的线程来自group线程池</span></span><br><span class="line">pipeline.addLast(group,<span class="string">"handler"</span>,<span class="keyword">new</span> MyBusinessLogicHandler());</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="c，ChanndlerHandler作用及设计"><a href="#c，ChanndlerHandler作用及设计" class="headerlink" title="c，ChanndlerHandler作用及设计"></a>c，ChanndlerHandler作用及设计</h5><ul>
<li><p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当把 ChannelHandler 添加到 pipeline 时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">//当从 pipeline 中移除时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">// 当处理过程中在 pipeline 发生异常时调用</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>ChannelHandler的作用就是处理IO事件或拦截IO事件，并将其转发给下一个处理程序ChannelHandler。Handler处理事件时分入站和出站的，两个方向的操作都是不同的，因此，Netty定义了两个子接口继承ChannelHandler</p>
</li>
<li><p>ChannelInboundHandler入站事件接口</p>
<p><img src="/2021/07/16/netty/57.png" alt="image-20210724173847758"></p>
<ul>
<li>channelActive用于当Channel处于活动状态时被调用</li>
<li>channelRead当从Channel读取数据时被调用等等方法</li>
<li>程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因为当事件发生时，Netty会回调对应的方法</li>
</ul>
</li>
<li><p>ChannelOutboundHandler出站事件接口</p>
<p><img src="/2021/07/16/netty/58.png" alt="image-20210724174107505"></p>
<ul>
<li>bind方法：当请求将Channel绑定到本地地址时调用</li>
<li>close方法，当请求关闭Channel时调用等等</li>
<li>出站操作都是一些连接和写出数据类似的方法</li>
</ul>
</li>
</ul>
<ul>
<li><p>ChannelDuplexHandler处理出站和入站事件（不推荐使用）</p>
<p><img src="/2021/07/16/netty/59.png" alt="image-20210724174256454"></p>
<ul>
<li>ChannelDuplexHandler间接实现了入站接口并直接实现了出站接口</li>
<li>是一个通用的能够同时处理入站事件和出站事件的类</li>
</ul>
</li>
<li><p>ChannelHandlerContext作用及设计</p>
<ul>
<li><p>ChannelHandlerContextUML图</p>
<p><img src="/2021/07/16/netty/60.png" alt="image-20210724174436374"></p>
</li>
<li><p>ChannelHandlerContext继承了出站方法调用接口和入站方法调用及饿哦库</p>
<ul>
<li><p>ChannelOutboundInvoker和ChannelInboundInvoker</p>
<p><img src="/2021/07/16/netty/61.png" alt="image-20210724174608999"></p>
<p><img src="/2021/07/16/netty/62.png" alt="image-20210724174646749"></p>
<ul>
<li>这两个invoker就是针对入站或出站方法来的，就是在入站或者出站handler的外层再包装一层，达到在方法前后拦截并做一些特定操作的目的</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="/2021/07/16/netty/63.png" alt="image-20210724174828182"></p>
<ul>
<li>ChannelHandlerContext不仅仅是继承了他们两个的方法，同时也定义了一些自己的方法</li>
<li>这些方法能够获取Context上下文环境中对应的比如channel，executor，handler，pipeline，内存分配器，关联的handler是否被删除</li>
<li>Context就是包装了handler相关的一切，以方便Context可以在pipeline方便的操作handler</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="d，ChannelPipeline-ChannelHandler-ChannelHandlerContext创建过程"><a href="#d，ChannelPipeline-ChannelHandler-ChannelHandlerContext创建过程" class="headerlink" title="d，ChannelPipeline | ChannelHandler | ChannelHandlerContext创建过程"></a>d，ChannelPipeline | ChannelHandler | ChannelHandlerContext创建过程</h5><ul>
<li><p>分为3个步骤来看创建的过程：</p>
<ul>
<li>任何一个ChannelSocket创建的同时都会创建一个pipeline</li>
<li>当用户或系统内部调用pipeline的add*** 方法添加handler时，都会创建一个包装这handler的Context</li>
<li>这些Context在pipeline中组成了双向链表</li>
</ul>
</li>
<li><p>Socket创建的时候创建pipeline</p>
<ul>
<li><p>在SocketChannel的抽象父类AbstractChannel的构造方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent; <span class="comment">//断点测试</span></span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br><span class="line">DefaultChannelPipeline(Channel channel) &#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>); </span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>); </span><br><span class="line">    voidPromise = <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>); head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将channel赋值给channel字段，用于pipeline操作channel</li>
<li>创建一个future和promise，用于异步回调使用</li>
<li>创建一个inbound的tailContext，创建一个既是inbound类型又是outbound类型的headContext</li>
<li>最后，将两个Context相互连接，形成双向链表</li>
<li>tailContext和HeadContext非常的重要，所有pipeline中的事件都会流经他们</li>
</ul>
</li>
</ul>
</li>
<li><p>在add<em>*<em>添加处理器的时候创建Context\</em>\</em></p>
<ul>
<li><p>看下DefaultChannelPipeline的addLast方法如何创建Context</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123; <span class="comment">//断点</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handlers"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ChannelHandler h: handlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addLast(executor, <span class="keyword">null</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; checkMultiplicity(handler);</span><br><span class="line">                         newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">                         addLast0(newCtx);</span><br><span class="line">                         <span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line">                         <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">                         <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered. if (!registered) &#123;</span></span><br><span class="line">                         newCtx.setAddPending();</span><br><span class="line">                         callHandlerCallbackLater(newCtx, <span class="keyword">true</span>); </span><br><span class="line">                         <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">    EventExecutor executor = newCtx.executor(); </span><br><span class="line">    <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">        newCtx.setAddPending();</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                callHandlerAdded0(newCtx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">callHandlerAdded0(newCtx); </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>pipeline添加handler，参数是线程池，name是null，handler是我们或者系统传入的handler，Netty为了防止多个线程导致安全问题，同步了这段代码，步骤如下：<ul>
<li>检查这个handler实例是否是共享的，如果不是，并且已经被别的pipeline使用了，则抛出异常</li>
<li>调用<code>newContext(group,filterName(name,handler),handler)</code>方法，创建一个Context，从这里可以看出来了，每次添加一个handler都会创建一个关联Context</li>
<li>调用addLast方法，将Context追加到链表中</li>
<li>如果这个通道还没有注册到selector上，就将这个Context添加到这个pipeline的待办任务中，当注册好了以后，就会调用callHandlerAdded()方法（默认是什么都不做，用户可以实现这个方法）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="f，Pipeline-Handler-HandlerContext创建过程梳理"><a href="#f，Pipeline-Handler-HandlerContext创建过程梳理" class="headerlink" title="f，Pipeline Handler HandlerContext创建过程梳理"></a>f，Pipeline Handler HandlerContext创建过程梳理</h5><ul>
<li>每当创建ChannelSocket的时候都会创建一个绑定的pipeline，一对一的关系，创建pipeline的时候也会创建tail节点和head节点，形成最初的链表</li>
<li>在调用pipeline的addLast方法的时候，会根据给定的handler创建一个Context，然后将这个Context插入到链表的尾端（tail前面）</li>
<li>Context包装handler，多个Context在pipeline中形成了双向链表</li>
<li>入站方向叫inbound，由head节点开始，出站方法叫outbound，由tail节点开始</li>
</ul>
<h4 id="4，ChannelPipeline调度handler的源码剖析"><a href="#4，ChannelPipeline调度handler的源码剖析" class="headerlink" title="4，ChannelPipeline调度handler的源码剖析"></a>4，ChannelPipeline调度handler的源码剖析</h4><h5 id="a，源码剖析目的-1"><a href="#a，源码剖析目的-1" class="headerlink" title="a，源码剖析目的"></a>a，源码剖析目的</h5><ul>
<li>当一个请求进来的时候，ChannelPipeline是如何调用内部的这些handler的呢？</li>
<li>首先，当一个请求进来的时候，会第一个调用pipeline的相关方法，如果是入站事件，这些方法由fire开头，表示开始管道的流动，让后面的handler继续处理</li>
</ul>
<h5 id="b，源码剖析——DefaultChannelPipeline如何实现fire方法？"><a href="#b，源码剖析——DefaultChannelPipeline如何实现fire方法？" class="headerlink" title="b，源码剖析——DefaultChannelPipeline如何实现fire方法？"></a>b，源码剖析——DefaultChannelPipeline如何实现fire方法？</h5><blockquote>
<p>说明：</p>
<ul>
<li><p>当浏览器输入<a href="http://localhost:8007，可以看到执行handler在Debug时，可以将断电下在DefaultChannelPipeline类">http://localhost:8007，可以看到执行handler在Debug时，可以将断电下在DefaultChannelPipeline类</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelActive(head); <span class="comment">//断点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li><p>DefaultChannelPipeline源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123; <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        AbstractChannelHandlerContext.invokeChannelActive(head);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelInactive</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        AbstractChannelHandlerContext.invokeChannelInactive(head); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireExceptionCaught</span><span class="params">(Throwable cause)</span> </span>&#123; </span><br><span class="line">        AbstractChannelHandlerContext.invokeExceptionCaught(head, cause); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireUserEventTriggered</span><span class="params">(Object event)</span> </span>&#123; </span><br><span class="line">        AbstractChannelHandlerContext.invokeUserEventTriggered(head, event); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123; </span><br><span class="line">        AbstractChannelHandlerContext.invokeChannelRead(head, msg); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelReadComplete</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        AbstractChannelHandlerContext.invokeChannelReadComplete(head);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelWritabilityChanged</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        AbstractChannelHandlerContext.invokeChannelWritabilityChanged(head);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看出来，这些方法都是inbound的方法，也就是入站事件，调用静态方法传入的也是inbound的类型head handler。这些静态方法则会调用head的ChannelInboundInvoker接口的方法，再然后调用handler的真正方法</li>
</ul>
</li>
<li><p>再看下pipeline的outbound的fire方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> tail.bind(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> tail.connect(remoteAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> tail.connect(remoteAddress, localAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">deregister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail.deregister();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">flush</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        tail.flush();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail.connect(remoteAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail.connect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">disconnect</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail.disconnect(promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这些都是出站的实现，但是调用的是outbound类型的tail handler来进行处理，因为这些都是outbound事件</li>
<li><strong>出站是tail开始，入站从head开始</strong>，因为出站是从内存向外面写，从tail开始，能够让前面的handler进行处理，防止handler被遗漏，比如编码。反之，入站当然是从head往内部输入，让后面的handler能够处理这些输入的数据。比如解码，因此虽然head也实现了outbound接口，但不是从head开始执行出站任务</li>
</ul>
</li>
</ul>
<h5 id="c，源码剖析——关于如何调度？"><a href="#c，源码剖析——关于如何调度？" class="headerlink" title="c，源码剖析——关于如何调度？"></a>c，源码剖析——关于如何调度？</h5><p><img src="/2021/07/16/netty/64.png" alt="image-20210724203055068"></p>
<ul>
<li>pipeline首先会调用Context的静态方法fireXXX，并传入Context</li>
<li>然后，静态方法调用Contetxt的invoker方法，而invoker方法内部会调用该Context所包含的Handler的真正的XXX方法，调用结束后，如果还需要继续向后传递，就调用Context的fireXXX2方法，循环往复</li>
</ul>
<h5 id="d，ChannelPipeline调度handler梳理"><a href="#d，ChannelPipeline调度handler梳理" class="headerlink" title="d，ChannelPipeline调度handler梳理"></a>d，ChannelPipeline调度handler梳理</h5><ul>
<li>Context包装handler，多个Context在pipeline中形成了双向链表，入站方向叫inbound，由head节点开始，出站方法叫outbound，由tail节点开始</li>
<li>而节点中间的传递通过AbstractChannelHandlerContext类内部的fire系列方法，找到当前节点的下一个节点不断的循环传播，是一个过滤器形式完成对handler的调度</li>
</ul>
<h4 id="5，Netty心跳（heartbeat）服务源码剖析"><a href="#5，Netty心跳（heartbeat）服务源码剖析" class="headerlink" title="5，Netty心跳（heartbeat）服务源码剖析"></a>5，Netty心跳（heartbeat）服务源码剖析</h4><h5 id="a，源码剖析目的-2"><a href="#a，源码剖析目的-2" class="headerlink" title="a，源码剖析目的"></a>a，源码剖析目的</h5><ul>
<li>Netty作为一个网络框架，提供了诸多功能，比如编码解等，Netty还提供了非常重要的一个服务——心跳机制heartbeat。通过心跳检查对方是否有效，这是RPC框架中必不可少的功能，下面我们分析一下Netty内部心跳服务源码实现</li>
</ul>
<h5 id="b，源码剖析——Netty提供的心跳介绍"><a href="#b，源码剖析——Netty提供的心跳介绍" class="headerlink" title="b，源码剖析——Netty提供的心跳介绍"></a>b，源码剖析——Netty提供的心跳介绍</h5><blockquote>
<p>说明：</p>
<ul>
<li><p>Netty提供了IdleStateHandler，ReadTimeoutHandler，WriteTimeoutHandler三个Handler检测连接的有效性，重点分析IdleStateHandler</p>
<p><img src="/2021/07/16/netty/65.png" alt="image-20210724230702193"></p>
</li>
<li><p>ReadTimeout事件和WriteTimeout事件都会自动关闭连接，而且属于异常处理</p>
</li>
</ul>
</blockquote>
<h5 id="c，源码剖析——IdleStateHandler分析"><a href="#c，源码剖析——IdleStateHandler分析" class="headerlink" title="c，源码剖析——IdleStateHandler分析"></a>c，源码剖析——IdleStateHandler分析</h5><ul>
<li><p>4个属性：</p>
<ul>
<li><code>private final boolean observeOutput</code>：是否考虑出站时较慢的情况，默认值是false</li>
<li><code>private final long readerIdleTimeNanos</code>：读事件空闲时间，0则禁用事件</li>
<li><code>private final long writeIdleTimeNanos</code>：写事件空闲时间，0则禁用事件</li>
<li><code>private final long allIdleTimeNanos</code>：读或写空闲时间，0则禁用事件</li>
</ul>
</li>
<li><p>handlerAdded方法</p>
<ul>
<li><p>当该handler被添加到pipeline中时，则调用initialize方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Avoid the case where destroy() is called before scheduling timeouts.</span></span><br><span class="line">    <span class="comment">// See: https://github.com/netty/netty/issues/143 </span></span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state = <span class="number">1</span>;</span><br><span class="line">    initOutputChanged(ctx);</span><br><span class="line">    lastReadTime = lastWriteTime = ticksInNanos(); </span><br><span class="line">    <span class="keyword">if</span> (readerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的 schedule 方法会调用 eventLoop 的 schedule 方法，将定时任务添加进队列中</span></span><br><span class="line">        readerIdleTimeout = schedule(ctx, <span class="keyword">new</span> ReaderIdleTimeoutTask(ctx), readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        writerIdleTimeout = schedule(ctx, <span class="keyword">new</span> WriterIdleTimeoutTask(ctx), writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        allIdleTimeout = schedule(ctx, <span class="keyword">new</span> AllIdleTimeoutTask(ctx), allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只要给定的参数大于0，就创建一个定时任务，每个事件都创建。同时，将state状态设置为1，防止重复初始化。调用initOutputChanged方法，初始化“监控出站数据属性”</li>
</ul>
</li>
</ul>
</li>
<li><p>该类内部的3个定时任务类</p>
<p><img src="/2021/07/16/netty/66.png" alt="image-20210724231629620"></p>
<ul>
<li><p>这3个定时任务分别对应读，写，读或者写事件，共有一个父类（AbstractIdleTask），这个父类提供了一个模板方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractIdleTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandlerContext ctx;</span><br><span class="line">    AbstractIdleTask(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ctx.channel().isOpen()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        run(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当通道关闭了，就不执行任务了，反之，执行子类的run方法</li>
</ul>
</li>
</ul>
</li>
<li><p>读事件的run方法（即ReaderIdleTimeoutTast的run方法）分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nextDelay = readerIdleTimeNanos;</span><br><span class="line">    <span class="keyword">if</span> (!reading) &#123;</span><br><span class="line">        nextDelay -= ticksInNanos() - lastReadTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Reader is idle - set a new timeout and notify the callback.</span></span><br><span class="line">        <span class="comment">// 用于取消任务 promise</span></span><br><span class="line">        readerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        <span class="keyword">boolean</span> first = firstReaderIdleEvent; firstReaderIdleEvent = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//再次提交任务</span></span><br><span class="line">            IdleStateEvent event = newIdleStateEvent(IdleState.READER_IDLE, first);</span><br><span class="line">            <span class="comment">//触发用户 handler use channelIdle(ctx, event);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123; </span><br><span class="line">            ctx.fireExceptionCaught(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Read occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class="line">        readerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>得到用户设置的超时时间</li>
<li>如果读取操作结束了（执行了channelReadComplete方法设置），就用当前时间减去给定时间和最后一次读（执行操作的时间channelReadComplete方法设置），如果小于0，就触发事件，反之，继续放入队列，间隔时间是新的计算时间</li>
<li>触发的逻辑是：首先将任务再次放到队列，时间是刚开始设置的时间，返回一个promise对象，用于做取消操作，然后，设置first属性为false，表示下一次读取不再是是第一次了，这个属性在channelRead方法会被改成true</li>
<li>创建一个IdleStateEvent类型的写事件对象，将此对象传递个用户的UserEventTriggered方法，完成触发事件的操作</li>
<li>总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果间隔超过了设置的时间，就触发UserEventTrigered方法</li>
</ul>
</li>
<li><p>写事件run方法（即WriteIdleTimeoutTask的run方法）分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> lastWriteTime = IdleStateHandler.<span class="keyword">this</span>.lastWriteTime;</span><br><span class="line">    <span class="keyword">long</span> nextDelay = writerIdleTimeNanos - (ticksInNanos() - lastWriteTime); <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Writer is idle - set a new timeout and notify the callback.</span></span><br><span class="line">        writerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        <span class="keyword">boolean</span> first = firstWriterIdleEvent; firstWriterIdleEvent = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasOutputChanged(ctx, first)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            IdleStateEvent event = newIdleStateEvent(IdleState.WRITER_IDLE, first);</span><br><span class="line">            channelIdle(ctx, event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ctx.fireExceptionCaught(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Write occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class="line">        writerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>写任务的run代码逻辑基本和读任务的逻辑是一样的，唯一不同的就是有一个针对出站较慢数据的判断hasOutputChanged</li>
</ul>
</li>
<li><p>所有事件的run方法（即AllIdleTimeoutTask的run方法）分析代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nextDelay = allIdleTimeNanos; </span><br><span class="line">    <span class="keyword">if</span> (!reading) &#123;</span><br><span class="line">        nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Both reader and writer are idle - set a new timeout and</span></span><br><span class="line">        <span class="comment">// notify the callback.</span></span><br><span class="line">        allIdleTimeout = schedule(ctx, <span class="keyword">this</span>, allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        <span class="keyword">boolean</span> first = firstAllIdleEvent; </span><br><span class="line">        firstAllIdleEvent = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasOutputChanged(ctx, first)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            IdleStateEvent event = newIdleStateEvent(IdleState.ALL_IDLE, first); </span><br><span class="line">            channelIdle(ctx, event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ctx.fireExceptionCaught(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Either read or write occurred before the timeout - set a new</span></span><br><span class="line">        <span class="comment">// timeout with shorter delay.</span></span><br><span class="line">        allIdleTimeout = schedule(ctx, <span class="keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>表示这个监控着所有的事件，当读写事件发生时，都会记录，代码逻辑和写事件的基本一致</p>
</li>
<li><p>需要大家注意的地方是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> nextDelay = allIdleTimeNanos;</span><br><span class="line"><span class="keyword">if</span> (!reading) &#123;</span><br><span class="line">    <span class="comment">// 当前时间减去 最后一次写或读 的时间 ，若大于 0，说明超时了</span></span><br><span class="line">    nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里的时间计算是取读写事件中的最大值来的，然后像写事件一样，判断是否发生了写的慢的情况</p>
</li>
</ul>
</li>
</ul>
<h5 id="d，小结Netty的心跳机制"><a href="#d，小结Netty的心跳机制" class="headerlink" title="d，小结Netty的心跳机制"></a>d，小结Netty的心跳机制</h5><ul>
<li>IdleStateHandler可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户handler的userEventTriggered方法，用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关闭连接</li>
<li>IdleStateHandler的实现基于EventLoop的定时任务，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲</li>
<li>内部有3个定时任务，分别对应读事件，写事件，读写事件，通常用户监听读写事件就足够了</li>
<li>同时，IdleStateHandler内部也考虑一些极端情况：客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间，Netty通过构造方法中observeOutput属性来决定是否对出站缓冲区的情况进行判断</li>
<li>如果出站缓慢，Netty不认为这是空闲，也就不触发空闲事件，但第一次无论如何也是要触发的，因为第一次无法判断是出站缓慢还是空闲，当然，出站缓慢的话，可能造成OOM，OOM比空闲的问题更大</li>
<li>所以，当你的应用出现了内存溢出，OOM之类，并且写空闲极少发生（使用了observeOutput为true），那么就需要注意是不是数据出站速度过慢</li>
<li>还有一个注意的地方：就是ReadTimeoutHandler，它继承自IdleStateHandler，当触发读空闲事件的时候，就触发<code>ctx.fireExceptionCaught</code>方法，并传入一个ReadTimeoutException，然后关闭Socket</li>
<li>而WriteTimeoutHandler的实现不是基于IdleStateHandler的，他的原理，当调用write方法的时候，会创建一个定时任务，任务内容是根据传入的promise的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现promise的isDone方法返回false，表明还没有写完，说明超时了，则抛出异常，当write方法完成后，会打断定时任务。</li>
</ul>
<h4 id="6，Netty核心组件EventLoop源码剖析"><a href="#6，Netty核心组件EventLoop源码剖析" class="headerlink" title="6，Netty核心组件EventLoop源码剖析"></a>6，Netty核心组件EventLoop源码剖析</h4><h5 id="a，源码剖析目的：-1"><a href="#a，源码剖析目的：-1" class="headerlink" title="a，源码剖析目的："></a>a，源码剖析目的：</h5><p>Echo第一行代码就是：<code>EventLoopGroup bossGroup = new NioEventLoopGroup;</code>下面分析其最核心的组件EventLoop</p>
<h5 id="b，源码剖析-1"><a href="#b，源码剖析-1" class="headerlink" title="b，源码剖析"></a>b，源码剖析</h5><ul>
<li><p>EventLoop介绍：</p>
<p><img src="/2021/07/16/netty/67.png" alt="image-20210725003045275"></p>
<ul>
<li>ScheduleExecutorService接口表示是一个定时任务接口，EventLoop可以接收定时任务</li>
<li>EventLoop接口：Netty接口文档说明该接口作用：一旦Channel注册了，就处理该Channel对应的所有I/O操作</li>
<li>SingleThreadEvetExecutor表示这是一个单个线程的线程池</li>
<li>EventLoop是一个单例的线程池，里面含有一个死循环的线程不断的做着3件事情：监听端口，处理端口事件，处理队列事件。每个EventLoop都可以绑定多个Channel，而每个Channel始终只能由一个EventLoop来处理</li>
</ul>
</li>
<li><p>NioEventLoop的使用——execute方法</p>
<p><img src="/2021/07/16/netty/68.png" alt="image-20210725003732579"></p>
<ul>
<li><p>在EventLoop的使用，一般都是eventloop.execute(task)；看下execute方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">        addTask(task);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        addTask(task);</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先判断该EventLoop的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试启动线程（但由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去</li>
<li>如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常</li>
<li>如果addTaskWakesUp是false，并且任务不是NonWakeupRunable类型，就尝试唤醒selector。这个时候，阻塞在selector的线程就会立即返回</li>
</ul>
</li>
<li><p>addTask和offerTask方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!offerTask(task)) &#123;</span><br><span class="line">        reject(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">offerTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskQueue.offer(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>NioEventLoop的父类SingleThreadEventExecutor的startThread方法</p>
<ul>
<li><p>当执行execute方法的时候，如果当前线程不是EventLoop所属线程，则尝试启动线程，也就是startThread方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doStartThread();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123; </span><br><span class="line">                STATE_UPDATER.set(<span class="keyword">this</span>, ST_NOT_STARTED);</span><br><span class="line"></span><br><span class="line">                PlatformDependent.throwException(cause);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该方法首先判断是否启动过了，保证EventLoop只有一个线程，如果没有启动过，则尝试使用CAS将state状态改为ST_STARTED，也就是已启动，然后调用doStartThread方法，如果失败，则进行回滚</li>
</ul>
</li>
<li><p>doStartThread方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            updateLastExecutionTime(); </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line"></span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">int</span> oldState = state;</span><br><span class="line">                    <span class="keyword">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet( SingleThreadEventExecutor.<span class="keyword">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        cleanup();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class="keyword">this</span>, ST_TERMINATED);</span><br><span class="line">                        threadLock.release();</span><br><span class="line">                        terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先调用executor的execute方法，这个executor就是在创建EventLoopGroup的时候创建的ThreadPerTaskExecutor类，该execute方法会将Runnable包装成Netty的FastThreadLocalThread</li>
<li>任务中，首先判断线程中断状态，然后设置最后一次的执行时间</li>
<li>执行当前NioEventLoop的run方法，注意：这个方法是个死循环，是整个EventLoop的核心</li>
<li>在finally块中，使用CAS不断修改state状态，改成ST_SHUTTING_DOWN，也就是当线程Loop结束的时候，关闭线程。最后还要死循环确认是否关闭，否则不会break。然后，执行cleanup操作，更新状态为ST_TERMINATED，并释放当前线程锁，如果任务队列不是空，则打印队列中海油多少个未完成的任务。并回调terminationFuture方法</li>
<li>其实最核心的就是EventLoop自身的run方法，再继续深入run方法</li>
</ul>
</li>
</ul>
</li>
<li><p>EventLoop中的Loop是靠run实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT: select(wakenUp.getAndSet(<span class="keyword">false</span>)); <span class="keyword">if</span> (wakenUp.get()) &#123;	</span><br><span class="line">                    selector.wakeup();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            cancelledKeys = <span class="number">0</span>; needsToSelectAgain = <span class="keyword">false</span>; </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio; <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks. </span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime(); </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime; </span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);	</span><br><span class="line">        &#125;	</span><br><span class="line">        <span class="comment">// Always handle shutdown even if the loop processing threw an exception.	</span></span><br><span class="line">        <span class="keyword">try</span> &#123;	</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;	</span><br><span class="line">                closeAll();	</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;	</span><br><span class="line">                    <span class="keyword">return</span>;	</span><br><span class="line">                &#125;	</span><br><span class="line">            &#125;	</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;	</span><br><span class="line">            handleLoopException(t);	</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从上面的步骤可以看出，整个run方法做了3件事情：</p>
<ul>
<li>select获取感兴趣的事件</li>
<li>processSelectedKeys处理事件</li>
<li>runAllTasks执行队列中的任务</li>
</ul>
</li>
<li><p>上面的三个方法，我们追一下select方法（体现非阻塞）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;		</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123; </span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If a task was submitted when wakenUp value was true, the task didn't get a chance to call</span></span><br><span class="line">            <span class="comment">// Selector#wakeup. So we need to check task queue again before executing select operation.</span></span><br><span class="line">            <span class="comment">// If we don't, the task might be pended until select operation was timed out.</span></span><br><span class="line">            <span class="comment">// It might be pended until idle timeout if IdleStateHandler existed in pipeline.</span></span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                selector.selectNow(); selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);<span class="comment">//否则阻塞给定时间，默认一秒</span></span><br><span class="line">            selectCnt ++;</span><br><span class="line">            <span class="comment">// 如果 1 秒后返回，有返回值 || select 被用户唤醒 || 任务队列有任务 || 有定时任务即将被执行； 则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="comment">// - Selected something,</span></span><br><span class="line">                <span class="comment">// - waken up by user, or</span></span><br><span class="line">                <span class="comment">// - the task queue has a pending task.</span></span><br><span class="line">                <span class="comment">// - a scheduled task is ready for processing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">// Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span></span><br><span class="line">                <span class="comment">// As this is most likely a bug in the handler of the user or it's client library we will</span></span><br><span class="line">                <span class="comment">// also log it.</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/2426</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Selector.select() returned prematurely because "</span> + <span class="string">"Thread.currentThread().interrupt() was called. Use "</span> + <span class="string">"NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                selectCnt = <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                <span class="comment">// timeoutMillis elapsed without anything selected.</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                <span class="comment">// The selector returned prematurely many times in a row.</span></span><br><span class="line">                <span class="comment">// Rebuild the selector to work around the problem. </span></span><br><span class="line">                logger.warn(</span><br><span class="line">                    <span class="string">"Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;."</span>,</span><br><span class="line">                    selectCnt, selector);</span><br><span class="line">                rebuildSelector();</span><br><span class="line">                selector = <span class="keyword">this</span>.selector;</span><br><span class="line">                <span class="comment">// Select again to populate selectedKeys. </span></span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;."</span>, selectCnt - <span class="number">1</span>, selector);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123; </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(</span><br><span class="line">                CancelledKeyException.class.getSimpleName() + " raised by a Selector &#123;&#125; - JDK bug?",</span><br><span class="line">                selector, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Harmless exception - log anyway</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用selector的select方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上0.5秒进行阻塞，当执行execute方法的时候，也就是添加任务的时候，唤醒selector，防止selector阻塞时间过长</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="c，EventLoop作为Netty的核心的运行机制梳理"><a href="#c，EventLoop作为Netty的核心的运行机制梳理" class="headerlink" title="c，EventLoop作为Netty的核心的运行机制梳理"></a>c，EventLoop作为Netty的核心的运行机制梳理</h5><ul>
<li>每次执行execute方法都是向队列中添加任务，当第一次添加时就启动线程，执行run方法，而run方法是整个EventLoop的核心，就像EventLoop的名字一样，Loop，不停的Loop，Loop做什么呢？做3件事：<ul>
<li>调用selector的select方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上0.5秒进行阻塞，当执行execute方法的时候，也就是添加任务的时候，唤醒selector，防止selector阻塞时间过长</li>
<li>当selector返回的时候，回调用processSelectedKeys方法对selectKey进行处理</li>
<li>当processSelectedKeys方法执行结束后，则按照ioRatio的比例执行runAllTasks方法，默认是IO任务时间和非IO任务时间是相同的，你也可以根据你的应用特点进行调优。比如非IO任务比较多，那么你就将ioRatio调小一点，这样非IO任务就能执行的长一点，防止队列积攒过多的任务</li>
</ul>
</li>
</ul>
<h4 id="7，handler中加入线程池和Context中添加线程池的源码剖析"><a href="#7，handler中加入线程池和Context中添加线程池的源码剖析" class="headerlink" title="7，handler中加入线程池和Context中添加线程池的源码剖析"></a>7，handler中加入线程池和Context中添加线程池的源码剖析</h4><h5 id="a，源码剖析目的：-2"><a href="#a，源码剖析目的：-2" class="headerlink" title="a，源码剖析目的："></a>a，源码剖析目的：</h5><ul>
<li>在Netty中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响Netty对Socket的处理速度</li>
<li>而解决犯法就是将耗时任务添加到异步线程中，但就添加线程池这步操作来讲，可以有2种方式，而且这2中方式实现的区别也比较大</li>
<li>处理耗时业务的第一种方式——handler中加入线程池</li>
<li>处理耗时业务的第二种方式——Context中添加线程池</li>
</ul>
<h5 id="b，源码剖析——handler中加入线程池"><a href="#b，源码剖析——handler中加入线程池" class="headerlink" title="b，源码剖析——handler中加入线程池"></a>b，源码剖析——handler中加入线程池</h5><ul>
<li><p>对前面的Netty demo源码进行修改，在EchoServerHandler的channelRead方法进行异步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span>	</span>&#123;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> EventExecutorGroup group = <span class="keyword">new</span> DefaultEventExecutorGroup(<span class="number">16</span>); </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> UnsupportedEncodingException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object msgCop = msg;</span><br><span class="line">        <span class="keyword">final</span> ChannelHandlerContext cxtCop = ctx;</span><br><span class="line">        group.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">                ByteBuf buf = (ByteBuf) msgCop;</span><br><span class="line">                <span class="keyword">byte</span>[] req = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()]; buf.readBytes(req);  </span><br><span class="line">                String body = <span class="keyword">new</span> String(req, <span class="string">"UTF-8"</span>); Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">                System.err.println(body + <span class="string">" "</span> + Thread.currentThread().getName()); String reqString = <span class="string">"Hello i am server~~~"</span>;</span><br><span class="line">                ByteBuf resp = Unpooled.copiedBuffer(reqString.getBytes()); cxtCop.writeAndFlush(resp);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"go	on .."</span>);</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="meta">@Override</span>	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;	</span><br><span class="line">        ctx.flush();	</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="meta">@Override</span>	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;	</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.	</span></span><br><span class="line">        cause.printStackTrace();	</span><br><span class="line">        ctx.close();	</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在channelRead方法，模拟一个耗时10秒的操作，这里我们将这个任务提交到了一个自定义的业务线程池中，这样，就不会阻塞Netty的IO线程</li>
<li><img src="/2021/07/16/netty/69.png" alt="image-20210725101351041"><ul>
<li>解释一下上图，当IO线程轮询到一个socket事件，然后IO线程开始处理，当走到耗时handler的时候，将耗时任务交给业务线程池</li>
<li>当耗时任务执行完毕再执行pipeline write方法的时候，（代码中使用的是context的write方法，上图画的是执行pipeline方法，是一个意思）会将这个任务交给IO线程</li>
</ul>
</li>
</ul>
</li>
<li><p>write方法的源码（在AbstractChannelHandlerContext类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123; </span><br><span class="line">    AbstractChannelHandlerContext next = findContextOutbound(); </span><br><span class="line">    <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line"></span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	</span><br><span class="line"></span><br><span class="line">        AbstractWriteTask task; <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;	<span class="keyword">else</span> &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">        safeExecute(executor, task, promise, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当判定下个outbound的executor线程不是当前线程的时候，会将当前的工作封装成task，然后放入mpsc队列中，等待IO任务执行完毕后执行队列中的任务</li>
<li>这里可以Debug来验证（提醒：Debug时，服务器端Debug，客户端run的方式）。当我们使用了<code>group.submit(new Callable&lt;Object&gt;()){}</code>在handler中加入线程池，就会进入到<code>safeExecute(executor,task,promise,m);</code>如果去掉这段代码，而使用普通方式来执行耗时的业务，那么就不会进入到<code>safeExecute(executor,task,promise,m);</code>（说明：普通方式执行耗时代码）</li>
</ul>
</li>
</ul>
<h5 id="c，源码剖析——Context中添加线程池"><a href="#c，源码剖析——Context中添加线程池" class="headerlink" title="c，源码剖析——Context中添加线程池"></a>c，源码剖析——Context中添加线程池</h5><ul>
<li><p>在添加pipeline中的handler时候，添加一个线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> EventExecutorGroup group = <span class="keyword">new</span> DefaultEventExecutorGroup(<span class="number">16</span>); ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 100)	</span></span><br><span class="line"><span class="class">    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">            ChannelPipeline p = ch.pipeline();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123; p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">                                &#125;</span><br><span class="line">            <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">            <span class="comment">//p.addLast(new EchoServerHandler());</span></span><br><span class="line">            p.addLast(group,<span class="keyword">new</span> EchoServerHandler() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>handler中的代码就使用普通的方式来处理耗时业务</p>
</li>
<li><p>当我们在调用addLast方法添加线程池后，handler将优先使用这个线程池，如果不添加，将使用IO线程</p>
</li>
<li><p>当走到AbstractChannelHandlerContext的invokeChannelRead方法的时候，executor.inEventLoop()是不会通过的，因为当前线程是IO线程Context也就是Handler的executor是业务线程，所以会异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123; <span class="comment">//执行 run @Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证时，我们如果去掉<code>p.addLast(group,new EchoServerHandler());</code>改成<code>p.addLast(new EchoServerHandler();</code>你会发现代码不会进入异步执行</p>
</li>
<li><p>后面的整个流程就变成和第一个方式一样了</p>
</li>
</ul>
</li>
</ul>
<h5 id="d，两种方式的比较"><a href="#d，两种方式的比较" class="headerlink" title="d，两种方式的比较"></a>d，两种方式的比较</h5><ul>
<li>第一种方式在handler中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需要，就不异步，异步会拖长接口响应时间，因为需要将任务放进mpscTask中。如果IO时间很短，task很多，可能一个循环下来，都没时间执行整个task，导致响应时间达不到指标</li>
<li>第二种方式是Netty标准方式（即加入到队列），但是，这么做会将整个handler都交给业务线程池，不论耗不耗时，都加入到队列里，不够灵活</li>
<li>各有 优劣，从灵活性考虑，第一种较好</li>
</ul>
<h3 id="十，用Netty自己实现dubboRPC"><a href="#十，用Netty自己实现dubboRPC" class="headerlink" title="十，用Netty自己实现dubboRPC"></a>十，用Netty自己实现dubboRPC</h3><h4 id="1，RPC基本介绍："><a href="#1，RPC基本介绍：" class="headerlink" title="1，RPC基本介绍："></a>1，RPC基本介绍：</h4><ul>
<li><p>RPC（Remote Procedure Call）——远程过程调用 ,是一个计算机通信协议，该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地位这个交互作用编程</p>
</li>
<li><p>两个或多个应用程序都分布在不同的服务器上，他们之间的调用都像是本地方法调用一样</p>
<p><img src="/2021/07/16/netty/70.png" alt="image-20210726013531927"></p>
</li>
<li><p>常见的RPC框架有：比较知名的阿里dubbo，google的gRPC，Go语言的rppcx，Apache的thrift，Spring旗下的Spring Cloud</p>
</li>
</ul>
<h4 id="2，RPC调用流程图"><a href="#2，RPC调用流程图" class="headerlink" title="2，RPC调用流程图"></a>2，RPC调用流程图</h4><p><img src="/2021/07/16/netty/71.png" alt="image-20210726013727654"></p>
<ul>
<li>服务消费方（client）以本地调用方式调用服务</li>
<li>client stub 接收到调用后负责将方法，参数等封装成能够进行网络传输的消息体</li>
<li>client stub将消息进行编码并发送到服务端</li>
<li>server stub收到消息后进行解码</li>
<li>server stub根据解码结果调用本地的服务</li>
<li>本地服务执行并将结果返回给server stub</li>
<li>server stub将返回导入结果进行编码并发送至消费方</li>
<li>client stub接收到消息并进行解码</li>
<li>服务消费方（client）得到结果</li>
</ul>
<p>小结：RPC的目标就是将2-8这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用</p>
<h4 id="3，自己实现dubbO-RPC（基于Netty）"><a href="#3，自己实现dubbO-RPC（基于Netty）" class="headerlink" title="3，自己实现dubbO RPC（基于Netty）"></a>3，自己实现dubbO RPC（基于Netty）</h4><ul>
<li><p>需求说明：</p>
<ul>
<li>dubbo底层使用了Netty作为网络通讯框架，要求用Netty实现一个简单的RPC框架</li>
<li>模仿dubbo，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用Netty</li>
</ul>
</li>
<li><p>设计说明：</p>
<ul>
<li><p>创建一个接口，定义抽象方法，用于消费者和提供者之间的约定</p>
</li>
<li><p>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据</p>
</li>
<li><p>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用Netty请去提供者返回数据</p>
<p><img src="/2021/07/16/netty/72.png" alt="image-20210726014818683"></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个是接口，是服务提供方和 服务消费方都需要</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String mes)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当有消费方调用该方法时， 就返回一个结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String mes)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到客户端消息="</span> + mes);</span><br><span class="line">        <span class="comment">//根据mes 返回不同的结果</span></span><br><span class="line">        <span class="keyword">if</span>(mes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"你好客户端, 我已经收到你的消息 ["</span> + mes + <span class="string">"] 第"</span> + (++count) + <span class="string">" 次"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"你好客户端, 我已经收到你的消息 "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootstrap 会启动一个服务提供者，就是 NettyServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码代填..</span></span><br><span class="line">        NettyServer.startServer(<span class="string">"127.0.0.1"</span>, <span class="number">7000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里定义协议头</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String providerName = <span class="string">"HelloService#hello#"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个消费者</span></span><br><span class="line">        NettyClient customer = <span class="keyword">new</span> NettyClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        HelloService service = (HelloService) customer.getBean(HelloService<span class="class">.<span class="keyword">class</span>, <span class="title">providerName</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;; ) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//通过代理对象调用服务提供者的方法(服务)</span></span><br><span class="line">            String res = service.hello(<span class="string">"你好 dubbo~"</span>);</span><br><span class="line">            System.out.println(<span class="string">"调用的结果 res= "</span> + res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">(String hostName, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        startServer0(hostName,port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成对NettyServer的初始化和启动</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer0</span><span class="params">(String hostname, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                                      <span class="meta">@Override</span></span><br><span class="line">                                      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                          ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                                          pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                                          pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                                          pipeline.addLast(<span class="keyword">new</span> NettyServerHandler()); <span class="comment">//业务处理器</span></span><br><span class="line"></span><br><span class="line">                                      &#125;</span><br><span class="line">                                  &#125;</span><br><span class="line"></span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(hostname, port).sync();</span><br><span class="line">            System.out.println(<span class="string">"服务提供方开始提供服务~~"</span>);</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器这边handler比较简单</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取客户端发送的消息，并调用服务</span></span><br><span class="line">        System.out.println(<span class="string">"msg="</span> + msg);</span><br><span class="line">        <span class="comment">//客户端在调用服务器的api 时，我们需要定义一个协议</span></span><br><span class="line">        <span class="comment">//比如我们要求 每次发消息是都必须以某个字符串开头 "HelloService#hello#你好"</span></span><br><span class="line">        <span class="keyword">if</span>(msg.toString().startsWith(ClientBootstrap.providerName)) &#123;</span><br><span class="line"></span><br><span class="line">            String result = <span class="keyword">new</span> HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(<span class="string">"#"</span>) + <span class="number">1</span>));</span><br><span class="line">            ctx.writeAndFlush(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NettyClientHandler client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法使用代理模式，获取一个代理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; serivceClass, <span class="keyword">final</span> String providerName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class&lt;?&gt;[]&#123;serivceClass&#125;, (proxy, method, args) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"(proxy, method, args) 进入...."</span> + (++count) + <span class="string">" 次"</span>);</span><br><span class="line">                    <span class="comment">//&#123;&#125;  部分的代码，客户端每调用一次 hello, 就会进入到该代码</span></span><br><span class="line">                    <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        initClient();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//设置要发给服务器端的信息</span></span><br><span class="line">                    <span class="comment">//providerName 协议头 args[0] 就是客户端调用api hello(???), 参数</span></span><br><span class="line">                    client.setPara(providerName + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">return</span> executor.submit(client).get();</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client = <span class="keyword">new</span> NettyClientHandler();</span><br><span class="line">        <span class="comment">//创建EventLoopGroup</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">handler</span>(</span></span><br><span class="line"><span class="class">                        <span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                                pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                                pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                                pipeline.addLast(client);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">7000</span>).sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelHandlerContext context;<span class="comment">//上下文</span></span><br><span class="line">    <span class="keyword">private</span> String result; <span class="comment">//返回的结果</span></span><br><span class="line">    <span class="keyword">private</span> String para; <span class="comment">//客户端调用方法时，传入的参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//与服务器的连接创建后，就会被调用, 这个方法是第一个被调用(1)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" channelActive 被调用  "</span>);</span><br><span class="line">        context = ctx; <span class="comment">//因为我们在其它方法会使用到 ctx</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到服务器的数据后，调用方法 (4)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" channelRead 被调用  "</span>);</span><br><span class="line">        result = msg.toString();</span><br><span class="line">        notify(); <span class="comment">//唤醒等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理对象调用, 发送数据给服务器，-&gt; wait -&gt; 等待被唤醒(channelRead) -&gt; 返回结果 (3)-》5</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" call1 被调用  "</span>);</span><br><span class="line">        context.writeAndFlush(para);</span><br><span class="line">        <span class="comment">//进行wait</span></span><br><span class="line">        wait(); <span class="comment">//等待channelRead 方法获取到服务器的结果后，唤醒</span></span><br><span class="line">        System.out.println(<span class="string">" call2 被调用  "</span>);</span><br><span class="line">        <span class="keyword">return</span>  result; <span class="comment">//服务方返回的结果</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPara</span><span class="params">(String para)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" setPara  "</span>);</span><br><span class="line">        <span class="keyword">this</span>.para = para;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/07/16/netty/" data-id="cks69tgb30006iwuaao8w0oo7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DynamicProgramming" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/29/DynamicProgramming/" class="article-date">
  <time datetime="2021-05-28T16:41:53.000Z" itemprop="datePublished">2021-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/29/DynamicProgramming/">Dynamic Programming</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h1><h3 id="一，动态规划概念"><a href="#一，动态规划概念" class="headerlink" title="一，动态规划概念"></a>一，动态规划概念</h3><blockquote>
<p><strong>动态规划</strong>（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在<strong>背包问题</strong>、<strong>生产经营问题</strong>、<strong>资金管理问题</strong>、<strong>资源分配问题</strong>、<strong>最短路径问题</strong>和<strong>复杂系统可靠性问题</strong>等中取得了显著的效果。</p>
<p>​                                                                                                                                ——百度百科</p>
</blockquote>
<h3 id="二，动态规划算法思想"><a href="#二，动态规划算法思想" class="headerlink" title="二，动态规划算法思想"></a>二，动态规划算法思想</h3><blockquote>
<p>​    动态规划算法通常用于<strong>求解具有某种最优性质的问题</strong>。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与<strong>分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的</strong>。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以<strong>用一个表来记录所有已解的子问题的答案</strong>。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式</p>
<p>​                                                                                                                                ——百度百科</p>
<p>​    若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用</p>
</blockquote>
<h3 id="三，动态规划和分治法的异同点"><a href="#三，动态规划和分治法的异同点" class="headerlink" title="三，动态规划和分治法的异同点"></a>三，动态规划和分治法的异同点</h3><ul>
<li><strong>共同点</strong>：二者都要求原问题具有最优子结构性质,都是将原问题分而治之,分解成若干个规模较小(小到很容易解决的程序)的子问题.然后将子问题的解合并,形成原问题的解.</li>
<li>不同点：<ul>
<li>分治法将分解后的子问题看成相互独立的，通过用递归来做。</li>
<li>动态规划将分解后的子问题理解为相互间有联系,有重叠部分，需要记忆，通常用迭代来做。</li>
</ul>
</li>
</ul>
<h3 id="四，动态规划中出现的术语"><a href="#四，动态规划中出现的术语" class="headerlink" title="四，动态规划中出现的术语"></a>四，动态规划中出现的术语</h3><ul>
<li><p><strong>多阶段决策问题</strong></p>
<ul>
<li>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题</li>
<li>各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果</li>
</ul>
</li>
<li><p><strong>动态规划问题中的术语</strong></p>
<ul>
<li><p><strong>阶段</strong>：把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续</p>
</li>
<li><p><strong>状态</strong>：状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。在上面的例子中状态就是某阶段的出发位置，它既是该阶段某路的起点，同时又是前一阶段某支路的终点</p>
</li>
<li><p><strong>无后效性</strong>：我们要求状态具有下面的性质：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。换句话说，过程的每一次实现可以用一个状态序列表示，在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性</p>
</li>
<li><p><strong>决策</strong>：一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。在最优控制中，也称为控制。在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。描述决策的变量称决策变量，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史</p>
<p>​     决策变量的范围称为允许决策集合</p>
</li>
<li><p><strong>策略</strong>：由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合</p>
<pre><code>允许策略集合中达到最优效果的策略称为最优策略</code></pre></li>
<li><p><strong>状态转移方程</strong>：给定k阶段状态变量x(k)的值后，如果这一阶段的决策变量一经确定，第k+1阶段的状态变量x(k+1)也就完全确定，即x(k+1)的值随x(k)和第k阶段的决策u(k)的值变化而变化，那么可以把这一关系看成(x(k)，u(k))与x(k+1)确定的对应关系，用x(k+1)=Tk(x(k),u(k))表示。这是从k阶段到k+1阶段的状态转移规律，称为状态转移方程</p>
</li>
<li><p><strong>最优化原理</strong>：作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略”</p>
<p>​    最优性原理实际上是要求问题的最优策略的子策略也是最优</p>
</li>
</ul>
</li>
</ul>
<h3 id="五，基本结构"><a href="#五，基本结构" class="headerlink" title="五，基本结构"></a>五，基本结构</h3><blockquote>
<p>​    多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法</p>
</blockquote>
<h3 id="六，适用条件"><a href="#六，适用条件" class="headerlink" title="六，适用条件"></a>六，适用条件</h3><blockquote>
<p>​    任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性</p>
<ul>
<li><strong>最优化原理</strong>（最优子结构性质）<ul>
<li>最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质</li>
</ul>
</li>
<li><strong>无后效性</strong><ul>
<li>将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性</li>
</ul>
</li>
<li><strong>子问题的重叠性</strong><ul>
<li>动态规划算法的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间<strong>（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="七，分类"><a href="#七，分类" class="headerlink" title="七，分类"></a>七，分类</h3><blockquote>
<p>​    动态规划的数学模型。根据决策过程的演变是确定性的还是随机性的。可分为确定性决策过程和随机性决策过程。另外。也可按时间参量是离散的或是连续的变量。分为离散决策过程和连续决策过程。组合起来就有离散确定性．离散随机性．连续确定性．连续随机性四种决策过程模型</p>
<p>​    对于确定性的决策过程。问题中下一段的状态已由当前段的状态及决策完全确定。对于随机性决策过程。它与确定性决策过程的区别在于下一段的状态并不能由当前段的状态及决策完全确定。而是按某种概率分布来决定下一段的状态。这种概率分布是由当前段的状态和决策完全确定</p>
</blockquote>
<h3 id="八，动态规划局限性"><a href="#八，动态规划局限性" class="headerlink" title="八，动态规划局限性"></a>八，动态规划局限性</h3><blockquote>
<p>​    动态规划对于解决多阶段决策问题的效果是明显的，但是动态规划也有一定的局限性。首先，它没有统一的处理方法，必须根据问题的各种性质并结合一定的技巧来处理；另外当变量的维数增大时，总的计算量及存贮量急剧增大。因而，受计算机的存贮量及计算速度的限制，当今的计算机仍不能用动态规划方法来解决较大规模的问题，这就是“维数障碍”</p>
</blockquote>
<h3 id="九，动态规划算法思路"><a href="#九，动态规划算法思路" class="headerlink" title="九，动态规划算法思路"></a>九，动态规划算法思路</h3><blockquote>
<p>​    动态规划所处理的问题是<strong>一个多阶段决策问题</strong>，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求最优的活动路线），如图所示：动态规划的设计都有着一定的模式，一般要经历以下几个步骤：</p>
<p>​<br>$$<br>初始状态 ——》 |决策1| ——》 |决策2| ——》。。——》|决策n| ——》结束状态<br>$$</p>
<ol>
<li><strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段，在划分阶段时，注意<strong>划分后的阶段一定要是==有序或者是可排序==的</strong>，否则问题就无法求解</li>
<li><strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足<strong>无后效性</strong></li>
<li><strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，<strong>状态转移就是根据上一阶段的状态和决策来导出本阶段的状态</strong>，所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来的，<strong>根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程</strong></li>
<li><strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件</li>
</ol>
<p>一般，只要解决问题的<strong>阶段</strong>，<strong>状态</strong>和<strong>状态转移决策</strong>确定了，就可以写出<strong>状态转移方程（包括边界条件）</strong></p>
<p><strong>实际应用中可以按以下几个简化的步骤进行设计：</strong></p>
<ol>
<li>分析最优解的性质，并刻画其结构特征</li>
<li>递归的定义最优解</li>
<li>以自底向上或自顶向上的记忆化方式（备忘录法）计算出最优值</li>
<li>根据计算最优值时得到的信息，构造问题的最优解</li>
</ol>
<p><strong>算法实现的说明：</strong></p>
<p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要就是<strong>确定动态规划三要素</strong>：</p>
<ol>
<li><p><strong>问题的阶段</strong></p>
</li>
<li><p><strong>每个阶段的状态</strong></p>
</li>
<li><p><strong>从前一个阶段转化到后一个阶段之间的递推关系</strong></p>
</li>
</ol>
<p>​     递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过<strong>因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</strong></p>
<p>​    确定了动态规划的这三要素，<strong>整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态</strong>，表格需要<strong>填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等）</strong>，填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解<br>$$<br>f(n,m) = max{f(n-1,m),f(n-1,m-w[n])+P(n,m)}<br>$$<br>​    </p>
</blockquote>
<h3 id="十，动态规划算法模板"><a href="#十，动态规划算法模板" class="headerlink" title="十，动态规划算法模板"></a>十，动态规划算法模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line"> <span class="number">2</span>    xn[j] = 初始值;</span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span>  <span class="keyword">for</span>(i=n-<span class="number">1</span>; i&gt;=<span class="number">1</span>; i=i-<span class="number">1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line"> <span class="number">5</span>    <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line"> <span class="number">6</span>      xi[j]=j=max（或min）&#123;g(xi-<span class="number">1</span>[j1:j2]), ......, g(xi-<span class="number">1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> t = g(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span> print(x1[j1]);</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span> <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n-<span class="number">1</span>; i=i+<span class="number">1</span>）</span><br><span class="line"><span class="number">15</span> &#123;  </span><br><span class="line"><span class="number">17</span>      t = t-xi-<span class="number">1</span>[ji];</span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span>      <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)</span><br><span class="line"><span class="number">21</span>         <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line"><span class="number">23</span>              <span class="keyword">break</span>;</span><br><span class="line"><span class="number">25</span> &#125;</span><br></pre></td></tr></table></figure>







<h1 id="动态规划经典例题："><a href="#动态规划经典例题：" class="headerlink" title="动态规划经典例题："></a>动态规划经典例题：</h1><h4 id="1，最长有效括号"><a href="#1，最长有效括号" class="headerlink" title="1，最长有效括号"></a>1，最长有效括号</h4><p><strong>题目：</strong></p>
<blockquote>
<p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：s &#x3D; &quot;(()&quot;</span><br><span class="line">&#x2F;&#x2F;输出：2</span><br><span class="line">&#x2F;&#x2F;解释：最长有效括号子串是 &quot;()&quot;</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：s &#x3D; &quot;)()())&quot;</span><br><span class="line">&#x2F;&#x2F;输出：4</span><br><span class="line">&#x2F;&#x2F;解释：最长有效括号子串是 &quot;()()&quot;</span><br><span class="line">&#x2F;&#x2F; 示例 3： </span><br><span class="line">&#x2F;&#x2F;输入：s &#x3D; &quot;&quot;</span><br><span class="line">&#x2F;&#x2F;输出：0</span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 0 &lt;&#x3D; s.length &lt;&#x3D; 3 * 104 </span><br><span class="line">&#x2F;&#x2F; s[i] 为 &#39;(&#39; 或 &#39;)&#39; </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现：</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProgrammingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"(())()()))("</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] status = <span class="keyword">new</span> <span class="keyword">int</span>[cs.length];</span><br><span class="line">        Arrays.fill(status, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//第一个元素无论是什么,状态(有效长度)都是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cs[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - status[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; cs[i - status[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i - status[i - <span class="number">1</span>] - <span class="number">2</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        status[i] = <span class="number">2</span> + status[i - <span class="number">1</span>] + <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        status[i] = <span class="number">2</span> + status[i - <span class="number">1</span>] + status[i - status[i - <span class="number">1</span>] - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.stream(status).max().getAsInt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：动态规划对于每个元素都应该有一个对应状态，并且这个状态是可以根据前面元素的状态推导出当前元素的状态</p>
</blockquote>
<h4 id="2，不同路径"><a href="#2，不同路径" class="headerlink" title="2，不同路径"></a>2，不同路径</h4><p><strong>题目：</strong></p>
<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：m &#x3D; 3, n &#x3D; 7</span><br><span class="line">&#x2F;&#x2F;输出：28 </span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：m &#x3D; 3, n &#x3D; 2</span><br><span class="line">&#x2F;&#x2F;输出：3</span><br><span class="line">&#x2F;&#x2F;解释：</span><br><span class="line">&#x2F;&#x2F;从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">&#x2F;&#x2F;1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">&#x2F;&#x2F;2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">&#x2F;&#x2F;3. 向下 -&gt; 向右 -&gt; 向下</span><br><span class="line">&#x2F;&#x2F; 示例 3： </span><br><span class="line">&#x2F;&#x2F;输入：m &#x3D; 7, n &#x3D; 3</span><br><span class="line">&#x2F;&#x2F;输出：28</span><br><span class="line">&#x2F;&#x2F; 示例 4： </span><br><span class="line">&#x2F;&#x2F;输入：m &#x3D; 3, n &#x3D; 3</span><br><span class="line">&#x2F;&#x2F;输出：6 </span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; m, n &lt;&#x3D; 100 </span><br><span class="line">&#x2F;&#x2F; 题目数据保证答案小于等于 2 * 109 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProgrammingTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> solves = solution(m, n);</span><br><span class="line">        System.out.println(solves);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//第一行和第一列所能到达的路径均为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//状态转移方程:matrix[i][j]=matrix[i-1][j]+matrix[i][j-1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                matrix[i][j] = matrix[i - <span class="number">1</span>][j] + matrix[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="3，不同路径II"><a href="#3，不同路径II" class="headerlink" title="3，不同路径II"></a>3，不同路径II</h4><p><strong>题目</strong></p>
<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">&#x2F;&#x2F;输出：2</span><br><span class="line">&#x2F;&#x2F;解释：</span><br><span class="line">&#x2F;&#x2F;3x3 网格的正中间有一个障碍物。</span><br><span class="line">&#x2F;&#x2F;从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">&#x2F;&#x2F;1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">&#x2F;&#x2F;2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：obstacleGrid &#x3D; [[0,1],[0,0]]</span><br><span class="line">&#x2F;&#x2F;输出：1</span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; m &#x3D;&#x3D; obstacleGrid.length </span><br><span class="line">&#x2F;&#x2F; n &#x3D;&#x3D; obstacleGrid[i].length </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; m, n &lt;&#x3D; 100 </span><br><span class="line">&#x2F;&#x2F; obstacleGrid[i][j] 为 0 或 1 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现：</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProgrammingTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] obstacleGrid = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> solves = solution(obstacleGrid);</span><br><span class="line">        System.out.println(solves);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> c = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//该行中每一列的所能到达的路径条数（滚动数组思想）</span></span><br><span class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[c];</span><br><span class="line">        Arrays.fill(row,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//第一行所能达到的路径条数为1,而碰到障碍物的后面为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row[j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//状态转移方程:obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]</span></span><br><span class="line">        <span class="comment">//且遇到障碍物时跳过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    row[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//赋值号右边的row[j]表示上一行该列的所能到达的路径条数</span></span><br><span class="line">                    row[j] = row[j] + row[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> row[c - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：可以通过滚动数组思想来节省算法额外开辟的内存空间，一般动态规划记录状态时适用</p>
</blockquote>
<h4 id="4，最小路径和"><a href="#4，最小路径和" class="headerlink" title="4，最小路径和"></a>4，最小路径和</h4><p><strong>题目</strong></p>
<blockquote>
<p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">&#x2F;&#x2F;输出：7</span><br><span class="line">&#x2F;&#x2F;解释：因为路径 1→3→1→1→1 的总和最小。</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：grid &#x3D; [[1,2,3],[4,5,6]]</span><br><span class="line">&#x2F;&#x2F;输出：12</span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; m &#x3D;&#x3D; grid.length </span><br><span class="line">&#x2F;&#x2F; n &#x3D;&#x3D; grid[i].length </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; m, n &lt;&#x3D; 200 </span><br><span class="line">&#x2F;&#x2F; 0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProgrammingTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] grid = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> solves = solution(grid);</span><br><span class="line">        System.out.println(solves);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = grid.length;</span><br><span class="line">        <span class="keyword">int</span> c = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//用来记录该行中每列他的最小路径和（滚动数组思想）</span></span><br><span class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[c];</span><br><span class="line">        <span class="comment">//第一行每列的最小路径和等于该左边积累值+自身长度</span></span><br><span class="line">        row[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; c; j++) &#123;</span><br><span class="line">            row[j] = grid[<span class="number">0</span>][j] + row[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    row[j] = grid[i][j] + row[j];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                row[j] = grid[i][j] + (row[j - <span class="number">1</span>] &gt; row[j] ? row[j] : row[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> row[c-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="5，买卖股票的最佳时机"><a href="#5，买卖股票的最佳时机" class="headerlink" title="5，买卖股票的最佳时机"></a>5，买卖股票的最佳时机</h4><p><strong>题目：</strong></p>
<blockquote>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：[7,1,5,3,6,4]</span><br><span class="line">&#x2F;&#x2F;输出：5</span><br><span class="line">&#x2F;&#x2F;解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">&#x2F;&#x2F;     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：prices &#x3D; [7,6,4,3,1]</span><br><span class="line">&#x2F;&#x2F;输出：0</span><br><span class="line">&#x2F;&#x2F;解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; prices.length &lt;&#x3D; 105 </span><br><span class="line">&#x2F;&#x2F; 0 &lt;&#x3D; prices[i] &lt;&#x3D; 104 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProgrammingTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] prices = &#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = solution(prices);</span><br><span class="line">        System.out.println(maxProfit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//表示前i天中的最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[] maxProfit = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="comment">//最小价格</span></span><br><span class="line">        <span class="keyword">int</span> minPrices = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minPrices &gt; prices[i]) &#123;</span><br><span class="line">                minPrices = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxProfit[i] = maxProfit[i-<span class="number">1</span>] &gt; prices[i] - minPrices ? maxProfit[i-<span class="number">1</span>] : prices[i] - minPrices;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit[prices.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="6，买卖股票的最佳时机II"><a href="#6，买卖股票的最佳时机II" class="headerlink" title="6，买卖股票的最佳时机II"></a>6，买卖股票的最佳时机II</h4><p><strong>题目</strong></p>
<blockquote>
<p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1: </span><br><span class="line">&#x2F;&#x2F;输入: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">&#x2F;&#x2F;输出: 7</span><br><span class="line">&#x2F;&#x2F;解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">&#x2F;&#x2F;     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br><span class="line">&#x2F;&#x2F; 示例 2: </span><br><span class="line">&#x2F;&#x2F;输入: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">&#x2F;&#x2F;输出: 4</span><br><span class="line">&#x2F;&#x2F;解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">&#x2F;&#x2F;     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line">&#x2F;&#x2F; 示例 3: </span><br><span class="line">&#x2F;&#x2F;输入: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">&#x2F;&#x2F;输出: 0</span><br><span class="line">&#x2F;&#x2F;解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 </span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 104 </span><br><span class="line">&#x2F;&#x2F; 0 &lt;&#x3D; prices[i] &lt;&#x3D; 104 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProgrammingTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] prices = &#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = solution(prices);</span><br><span class="line">        System.out.println(maxProfit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] maxProfit = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span> minPrices = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxPrices = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">//因为最大值需要为最小值后面的数值的最大值,所以每次最小值移动时,需要将最大值重新初始化</span></span><br><span class="line">            <span class="keyword">if</span> (minPrices &gt; prices[i]) &#123;</span><br><span class="line">                minPrices = prices[i];</span><br><span class="line">                maxPrices = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxPrices &lt; prices[i]) &#123;</span><br><span class="line">                maxPrices = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//多次抛售则继承前面累计的收益</span></span><br><span class="line">            maxProfit[i] = maxProfit[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                maxProfit[i] += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较多次抛售的收益和一次最大最小抛售的收益的大小,选择收益大的</span></span><br><span class="line">            maxProfit[i] = maxProfit[i] &gt; maxPrices - minPrices ? maxProfit[i] : maxPrices - minPrices;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit[prices.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="7，买卖股票最佳时机III"><a href="#7，买卖股票最佳时机III" class="headerlink" title="7，买卖股票最佳时机III"></a>7，买卖股票最佳时机III</h4><p><strong>题目：</strong></p>
<blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1: </span><br><span class="line">&#x2F;&#x2F;输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">&#x2F;&#x2F;输出：6</span><br><span class="line">&#x2F;&#x2F;解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br><span class="line">&#x2F;&#x2F;     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。 </span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：prices &#x3D; [1,2,3,4,5]</span><br><span class="line">&#x2F;&#x2F;输出：4</span><br><span class="line">&#x2F;&#x2F;解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。   </span><br><span class="line">&#x2F;&#x2F;     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">&#x2F;&#x2F;     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line">&#x2F;&#x2F; 示例 3： </span><br><span class="line">&#x2F;&#x2F;输入：prices &#x3D; [7,6,4,3,1] </span><br><span class="line">&#x2F;&#x2F;输出：0 </span><br><span class="line">&#x2F;&#x2F;解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 </span><br><span class="line">&#x2F;&#x2F; 示例 4： </span><br><span class="line">&#x2F;&#x2F;输入：prices &#x3D; [1]</span><br><span class="line">&#x2F;&#x2F;输出：0</span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; prices.length &lt;&#x3D; 105 </span><br><span class="line">&#x2F;&#x2F; 0 &lt;&#x3D; prices[i] &lt;&#x3D; 105 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProgrammingTest6</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] prices = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = maxProfit(prices);</span><br><span class="line">        System.out.println(maxProfit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> buy1 = -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy2 = -prices[<span class="number">0</span>], sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">//找状态转移方程式时,可以尝试将一种状态拆分成几分状态的递推形式,最终的递推结果即当前状态</span></span><br><span class="line">            buy1 = Math.max(buy1, -prices[i]);<span class="comment">//第一次购买选择之前最低价格买入</span></span><br><span class="line">            sell1 = Math.max(sell1, buy1 + prices[i]);<span class="comment">//第一次卖出选择之前最高价格卖出</span></span><br><span class="line">            buy2 = Math.max(buy2, sell1 - prices[i]);<span class="comment">//当第一次卖出后,考虑第二次买入</span></span><br><span class="line">            sell2 = Math.max(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="8，三角形最小路径和"><a href="#8，三角形最小路径和" class="headerlink" title="8，三角形最小路径和"></a>8，三角形最小路径和</h4><p><strong>题目</strong>：</p>
<blockquote>
<p>给定一个三角形 triangle ，找出自顶向下的最小路径和。<br> 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果<br>正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：triangle &#x3D; [[2],[3,4],[6,5,7],[4,1,8,3]]</span><br><span class="line">&#x2F;&#x2F;输出：11</span><br><span class="line">&#x2F;&#x2F;解释：如下面简图所示：</span><br><span class="line">&#x2F;&#x2F;   2</span><br><span class="line">&#x2F;&#x2F;  3 4</span><br><span class="line">&#x2F;&#x2F; 6 5 7</span><br><span class="line">&#x2F;&#x2F;4 1 8 3</span><br><span class="line">&#x2F;&#x2F;自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：triangle &#x3D; [[-10]]</span><br><span class="line">&#x2F;&#x2F;输出：-10</span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; triangle.length &lt;&#x3D; 200 </span><br><span class="line">&#x2F;&#x2F; triangle[0].length &#x3D;&#x3D; 1 </span><br><span class="line">&#x2F;&#x2F; triangle[i].length &#x3D;&#x3D; triangle[i - 1].length + 1 </span><br><span class="line">&#x2F;&#x2F; -104 &lt;&#x3D; triangle[i][j] &lt;&#x3D; 104 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong>：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        取得最后一行的长度,由于是等腰三角形,所以等于行数</span></span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="comment">//n是因为最终目的是存储最后一行的最小路径和</span></span><br><span class="line">        <span class="comment">//2是因为一个用来使用上一行存放的数据,一个用来存储当前行的数据</span></span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][n];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            current = i % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> prev = <span class="number">1</span> - current;</span><br><span class="line">            f[current][<span class="number">0</span>] = f[prev][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//等腰三角形,当前行的长度等于行号</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                f[current][j] = Math.min(f[prev][j - <span class="number">1</span>], f[prev][j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            f[current][i] = f[prev][i-<span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minTotal = f[current][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            minTotal = Math.min(f[current][i], minTotal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minTotal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：动态规划不一定是每一步的最优解才是，因为拆分成每一步的子问题时该子问题不一定满足最优子问题，大部分时候可以看成将每个地方全部遍历一遍的最优解，从所有的最优解里面找出下一个子问题的所有的最优解，依次找到最终问题的所有最优解，然后从最终的最优解数组中选择出问题的解</p>
</blockquote>
<h4 id="9，不同的二叉搜索树"><a href="#9，不同的二叉搜索树" class="headerlink" title="9，不同的二叉搜索树"></a>9，不同的二叉搜索树</h4><p><strong>题目</strong>；</p>
<blockquote>
<p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：n &#x3D; 3</span><br><span class="line">&#x2F;&#x2F;输出：5</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：n &#x3D; 1</span><br><span class="line">&#x2F;&#x2F;输出：1</span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; n &lt;&#x3D; 19 </span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>代码实现</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] g = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                g[i] += g[j - <span class="number">1</span>] * g[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解题过程：</p>
<p>G(n)：为 长度为 n 的序列能构成的不同二叉搜索树的个数。</p>
<p>F(i, n)： 以 i 为根、序列长度为 n的不同二叉搜索树个数 (1 ≤ i ≤ n)。<br>$$<br>G(n) = ∑F(i,n)<br>$$<br>比如当二叉树以2为根，以5为长度，则F(2,5) = G(2)<em>G(3)，相当于左右子树种类数之积<br>$$<br>F(i,n) = G(i-1)</em>G(n-i)<br>$$<br>由上面两式子得状态转移方程式：<br>$$<br>G(n) = ∑G(i-1)*G(n-i)<br>$$</p>
</blockquote>
<h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><ul>
<li>==<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin" target="_blank" rel="noopener">百度百科</a>==</li>
<li>==<a href="https://blog.csdn.net/zw6161080123/article/details/80639932" target="_blank" rel="noopener">六大算法之三：动态规划</a>==</li>
<li><a href="https://blog.csdn.net/flowing_wind/article/details/81949689" target="_blank" rel="noopener">【算法】详解动态规划</a></li>
<li><a href="https://www.sohu.com/a/149075950_684445" target="_blank" rel="noopener">漫画：什么是动态规划？（整合版） </a></li>
<li>==<a href="https://zhuanlan.zhihu.com/p/78220312" target="_blank" rel="noopener">动态规划套路详解</a>==</li>
<li>==<a href="https://www.cnblogs.com/raichen/p/5772056.html" target="_blank" rel="noopener">动态规划</a>==</li>
<li><a href="https://blog.csdn.net/iva_brother/article/details/84037050" target="_blank" rel="noopener">动态规划：从入门到放弃</a></li>
</ul>
<p>​    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/05/29/DynamicProgramming/" data-id="cks69tfss0000iwua0bmg52hu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Greedy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/08/Greedy/" class="article-date">
  <time datetime="2021-05-08T01:53:45.000Z" itemprop="datePublished">2021-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/08/Greedy/">Greedy</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="贪心算法（Greedy）"><a href="#贪心算法（Greedy）" class="headerlink" title="贪心算法（Greedy）"></a>贪心算法（Greedy）</h1><h3 id="一，贪心算法概念"><a href="#一，贪心算法概念" class="headerlink" title="一，贪心算法概念"></a>一，贪心算法概念</h3><blockquote>
<p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 </p>
<p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择</p>
<p>​                                                                                                                                ——百度百科</p>
<p>所谓贪心算法是指，在对问题求解时，总是<strong>做出在当前看来是最好的选择</strong>。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的<strong>局部最优解</strong>。<br>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）<br> <strong>所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。</strong></p>
</blockquote>
<h3 id="二，贪心算法思路："><a href="#二，贪心算法思路：" class="headerlink" title="二，贪心算法思路："></a>二，贪心算法思路：</h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;算法一般思考步骤如下</span><br><span class="line">1️⃣建立数学模型来描述问题</span><br><span class="line">2️⃣把求解的问题分成若干个子问题</span><br><span class="line">3️⃣对每个子问题求解，得到子问题的局部最优解</span><br><span class="line">4️⃣把子问题的解局部最优解合成原来解问题的一个解</span><br></pre></td></tr></table></figure>

<p>贪心算法是一种对某些求最优解问题的更简单、更迅速的设计技术。贪心算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，省去了为找最优解要穷尽所有可能而必须耗费的大量时间。贪心算法采用<strong>自顶向下</strong>，以迭代的方法做出相继的贪心选择，每做一次贪心选择，就<strong>将所求问题简化为一个规模更小的子问题</strong>，通过每一步贪心选择，可得到问题的一个最优解。虽然每一步上都要保证能获得<strong>局部最优解</strong>，但由此产生的全局解有时不一定是最优的，所以<strong>贪心算法不要回溯</strong></p>
</blockquote>
<h3 id="三，贪心算法的问题特性"><a href="#三，贪心算法的问题特性" class="headerlink" title="三，贪心算法的问题特性"></a>三，贪心算法的问题特性</h3><blockquote>
<p>贪心算法可解决的问题通常大部分都有如下的特性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1️⃣有一个以最优方式来解决的问题。为了构造问题的解决方案，有一个候选的对象的集合：比如不同面值的硬币</span><br><span class="line">2️⃣随着算法的进行，将积累起其他两个集合：一个包含已经被考虑过并被选出的候选对象，另一个包含已经被考虑过但被丢弃的候选对象</span><br><span class="line">3️⃣有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优</span><br><span class="line">4️⃣还有一个函数检查是否一个候选对象的集合是可行的，即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性</span><br><span class="line">5️⃣选择函数可以指出哪一个剩余的候选对象最有希望构成问题的解</span><br><span class="line">6️⃣最后，目标函数给出解的值</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="四，贪心算法的使用条件"><a href="#四，贪心算法的使用条件" class="headerlink" title="四，贪心算法的使用条件"></a>四，贪心算法的使用条件</h3><blockquote>
<p>利用贪心法求解的问题应具有如下两个特征</p>
<ol>
<li><strong>贪心选择性质</strong><ul>
<li>一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次的选择可以依赖以前作出的选择，但不依赖于后面要作出的选择。这就是贪心选择性质。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解</li>
</ul>
</li>
<li><strong>最优子结构性质</strong><ul>
<li>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用贪心法求解的关键所在。在实际应用中，至于什么问题具有什么样的贪心选择性质是不确定的，需要具体问题具体分析</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="五，贪心算法的解题策略"><a href="#五，贪心算法的解题策略" class="headerlink" title="五，贪心算法的解题策略"></a>五，贪心算法的解题策略</h3><blockquote>
<p>贪心算法不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优选择。使用贪心策略要注意局部最优与全局最优的关系，选择当前的局部最优并不一定能推导出问题的全局最优。贪心策略解题需要解决以下两个问题：</p>
<ul>
<li>该问题是否适合使用贪心策略求解，也就是该问题是否具有贪心选择性质</li>
<li>制定贪心策略，以达到问题的最优解或较优解</li>
</ul>
<p>要确定一个问题是否适合用贪心算法求解，必须证明每一步所作的贪心选择最终导致问题的整体最优解。证明的大致过程为：首先考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始，做了贪心选择后，原问题简化为规模更小的类似子问题。然后用数学归纳法证明通过每一步做贪心选择，最终可得到问题的整体最优解</p>
</blockquote>
<h3 id="六，贪心算法存在的问题"><a href="#六，贪心算法存在的问题" class="headerlink" title="六，贪心算法存在的问题"></a>六，贪心算法存在的问题</h3><blockquote>
<p>贪心算法也存在如下问题：</p>
<ul>
<li>不能保证解是最佳的。因为贪心算法总是从局部出发，并没从整体考虑</li>
<li>贪心算法一般用来解决求最大或最小解</li>
<li>贪心算法只能确定某些问题的可行性范围</li>
</ul>
</blockquote>
<h3 id="七，贪心算法的模板"><a href="#七，贪心算法的模板" class="headerlink" title="七，贪心算法的模板"></a>七，贪心算法的模板</h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从问题的某一初始解出发;</span><br><span class="line">while (朝给定总目标前进一步)</span><br><span class="line">&#123;</span><br><span class="line">	利用可行的决策，求出可行解的一个解元素;</span><br><span class="line">&#125;</span><br><span class="line">由所有解元素组合成问题的一个可行解;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="经典例题："><a href="#经典例题：" class="headerlink" title="经典例题："></a>经典例题：</h2><h4 id="1，加油站"><a href="#1，加油站" class="headerlink" title="1，加油站"></a>1，加油站</h4><p><strong>题目</strong></p>
<blockquote>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。<br>说明:<br>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1: </span><br><span class="line">&#x2F;&#x2F; 输入: </span><br><span class="line">&#x2F;&#x2F;gas  &#x3D; [1,2,3,4,5]</span><br><span class="line">&#x2F;&#x2F;cost &#x3D; [3,4,5,1,2]</span><br><span class="line">&#x2F;&#x2F;输出: 3</span><br><span class="line">&#x2F;&#x2F;解释:</span><br><span class="line">&#x2F;&#x2F;从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">&#x2F;&#x2F;开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油</span><br><span class="line">&#x2F;&#x2F;开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油</span><br><span class="line">&#x2F;&#x2F;开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油</span><br><span class="line">&#x2F;&#x2F;开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油</span><br><span class="line">&#x2F;&#x2F;开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">&#x2F;&#x2F;因此，3 可为起始索引。 </span><br><span class="line">&#x2F;&#x2F; 示例 2: </span><br><span class="line">&#x2F;&#x2F; 输入: </span><br><span class="line">&#x2F;&#x2F;gas  &#x3D; [2,3,4]</span><br><span class="line">&#x2F;&#x2F;cost &#x3D; [3,4,3]</span><br><span class="line">&#x2F;&#x2F;输出: -1</span><br><span class="line">&#x2F;&#x2F;解释:</span><br><span class="line">&#x2F;&#x2F;你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">&#x2F;&#x2F;我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</span><br><span class="line">&#x2F;&#x2F;开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油</span><br><span class="line">&#x2F;&#x2F;开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油</span><br><span class="line">&#x2F;&#x2F;你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">&#x2F;&#x2F;因此，无论怎样，你都不可能绕环路行驶一周。 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现：</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreedyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] gas = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] cost = &#123;<span class="number">3</span>, <span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = gas.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> sumOfGas = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> process = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (process &lt; n) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = (i + process) % gas.length;</span><br><span class="line">                sumOfGas = sumOfGas + gas[j] - cost[j];</span><br><span class="line">                <span class="keyword">if</span> (sumOfGas &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                process++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (process == n) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i + process + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="3，任务调度器"><a href="#3，任务调度器" class="headerlink" title="3，任务调度器"></a>3，任务调度器</h4><h4 id="4，课程表"><a href="#4，课程表" class="headerlink" title="4，课程表"></a>4，课程表</h4><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800?fr=aladdin" target="_blank" rel="noopener">百度百科</a></li>
<li><a href="https://www.jianshu.com/p/ab89df9759c8" target="_blank" rel="noopener">五大常用算法之一：贪心算法</a></li>
<li><a href="https://www.cnblogs.com/tianqizhi/p/9571939.html" target="_blank" rel="noopener">贪心算法与近似算法</a></li>
<li><a href="https://blog.csdn.net/effective_coder/article/details/8736718" target="_blank" rel="noopener">贪心算法详解</a></li>
<li><a href="https://www.cnblogs.com/chinazhangjie/archive/2010/11/23/1885330.html" target="_blank" rel="noopener">贪心算法</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/05/08/Greedy/" data-id="cks69tfsz0002iwua1qm6fv57" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-BackTracking" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/08/BackTracking/" class="article-date">
  <time datetime="2021-04-08T01:45:59.000Z" itemprop="datePublished">2021-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/08/BackTracking/">BackTracking</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="回溯算法（Back-Tracking"><a href="#回溯算法（Back-Tracking" class="headerlink" title="回溯算法（Back Tracking)"></a>回溯算法（Back Tracking)</h1><h3 id="一，回溯算法概念：·"><a href="#一，回溯算法概念：·" class="headerlink" title="一，回溯算法概念：·"></a>一，回溯算法概念：·</h3><blockquote>
<p>​    回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优<a href="https://baike.baidu.com/item/搜索/2791632" target="_blank" rel="noopener">搜索</a>法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。                                                                                     ————百度百科</p>
</blockquote>
<h3 id="二，回溯算法思想："><a href="#二，回溯算法思想：" class="headerlink" title="二，回溯算法思想："></a>二，回溯算法思想：</h3><blockquote>
<p>​    回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。<a href="https://baike.baidu.com/item/八皇后问题" target="_blank" rel="noopener">八皇后问题</a>就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的<a href="https://baike.baidu.com/item/节点" target="_blank" rel="noopener">节点</a>，从而减少状态空间树节点的生成。</p>
<p>​    <a href="https://baike.baidu.com/item/回溯法" target="_blank" rel="noopener">回溯法</a>是一个既带有系统性又带有跳跃性的的<a href="https://baike.baidu.com/item/搜索算法" target="_blank" rel="noopener">搜索算法</a>。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而<a href="https://baike.baidu.com/item/回溯法" target="_blank" rel="noopener">回溯法</a>在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。</p>
</blockquote>
<h3 id="三，回溯算法一般解题步骤"><a href="#三，回溯算法一般解题步骤" class="headerlink" title="三，回溯算法一般解题步骤"></a>三，回溯算法一般解题步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 定义一个解空间，它包含问题的解</span><br><span class="line">2. 用适于搜索的方式组织该空间</span><br><span class="line">3. 用深度优先法(DFS)搜索该空间，利用限界函数避免移动到不可能产生解的子空间</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​    回溯算法的一个有趣的特性是在搜索执行的同时产生解空间。在搜索期间的任何时刻，仅保留从开始节点到当前节点的路径。因此，回溯算法的空间需求为O（从开始节点起最长路径的长度）。这个特性非常重要，因为解空间的大小通常是最长路径长度的指数或阶乘。所以如果要存储全部解空间的话，再多的空间也不够用。</p>
</blockquote>
<h3 id="四，回溯算法能解决的问题："><a href="#四，回溯算法能解决的问题：" class="headerlink" title="四，回溯算法能解决的问题："></a>四，回溯算法能解决的问题：</h3><ol>
<li><strong>组合问题</strong>：N个数里面按一定规则找出k个数的集合</li>
<li><strong>排列问题</strong>：N个数按一定规则全排列，有几种排列方式</li>
<li><strong>切割问题</strong>：一个字符串按一定规则有几种切割方式</li>
<li><strong>子集问题</strong>：一个N个数的集合里有多少符合条件的子集</li>
<li><strong>棋盘问题</strong>：N皇后，解数独等等</li>
</ol>
<h3 id="五，回溯算法模板"><a href="#五，回溯算法模板" class="headerlink" title="五，回溯算法模板"></a>五，回溯算法模板</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归：[for循环横向遍历，递归纵向遍历，回溯不断调整结果集]</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="回溯算法经典例题："><a href="#回溯算法经典例题：" class="headerlink" title="回溯算法经典例题："></a>回溯算法经典例题：</h2><h4 id="1，电话号码的字母组合："><a href="#1，电话号码的字母组合：" class="headerlink" title="1，电话号码的字母组合："></a>1，电话号码的字母组合：</h4><p><strong>题目</strong>：</p>
<blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：digits &#x3D; &quot;23&quot;</span><br><span class="line">&#x2F;&#x2F;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：digits &#x3D; &quot;&quot;</span><br><span class="line">&#x2F;&#x2F;输出：[]</span><br><span class="line">&#x2F;&#x2F; 示例 3： </span><br><span class="line">&#x2F;&#x2F;输入：digits &#x3D; &quot;2&quot;</span><br><span class="line">&#x2F;&#x2F;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>实现代码</strong>：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest1</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = letterCombinations(<span class="string">"23"</span>);</span><br><span class="line">     System.out.println(strings.toString());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//用来存放电话号码组合的字符串</span></span><br><span class="line">     List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> combinations;</span><br><span class="line">     &#125;</span><br><span class="line">     Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> HashMap&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">         put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">        put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">         put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">         put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">         put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">            put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">            put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backTracking(combinations,phoneMap,digits,<span class="number">0</span>,<span class="keyword">new</span> StringBuffer());</span><br><span class="line">     <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 回溯算法获得字母号码组合</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> combinations：存放字母号码组合</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> phoneMap：号码对应的字母</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> digits：输入的号码</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> startIndex：下次递归开始的位置</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> combination 每次到最深处的字母组合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(List&lt;String&gt; combinations,Map&lt;Character,String&gt; phoneMap, String digits,<span class="keyword">int</span> startIndex,StringBuffer combination)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//当递归到数字结束时为最大深度</span></span><br><span class="line">           <span class="keyword">if</span> (startIndex == digits.length() )&#123;</span><br><span class="line">               combinations.add(combination.toString());</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; phoneMap.get(digits.charAt(startIndex)).length(); i++) &#123;</span><br><span class="line">                   combination.append(phoneMap.get(digits.charAt(startIndex)).charAt(i));</span><br><span class="line">                   backTracking(combinations,phoneMap,digits,startIndex+<span class="number">1</span>,combination);</span><br><span class="line">                   combination.deleteCharAt(startIndex);</span><br><span class="line">            &#125;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2，括号生成"><a href="#2，括号生成" class="headerlink" title="2，括号生成"></a>2，括号生成</h4><p><strong>题目</strong></p>
<blockquote>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：n &#x3D; 3</span><br><span class="line">&#x2F;&#x2F;输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：n &#x3D; 1</span><br><span class="line">&#x2F;&#x2F;输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>实现代码</strong>：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backing(result, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backing</span><span class="params">(List&lt;String&gt; result, StringBuilder cur, <span class="keyword">int</span> right, <span class="keyword">int</span> left, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.length() == n * <span class="number">2</span>) &#123;</span><br><span class="line">            result.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; n) &#123;</span><br><span class="line">            cur.append(<span class="string">'('</span>);</span><br><span class="line">            backing(result, cur, right + <span class="number">1</span>, left, n);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            cur.append(<span class="string">')'</span>);</span><br><span class="line">            backing(result, cur, right, left + <span class="number">1</span>, n);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS1：如果使用回溯算法，每一层递归都需要在递归结束后递出的时候回溯到进入递归前的状态，即回溯——撤销之前的操作</p>
<p>PS2：连续递归即求出全排列</p>
</blockquote>
<h4 id="3，组合求和（1）"><a href="#3，组合求和（1）" class="headerlink" title="3，组合求和（1）"></a>3，组合求和（1）</h4><p><strong>题目</strong>；</p>
<blockquote>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; candidates 中的数字可以无限制重复被选取。 </span><br><span class="line">&#x2F;&#x2F; 说明： </span><br><span class="line">&#x2F;&#x2F; 所有数字（包括 target）都是正整数。 </span><br><span class="line">&#x2F;&#x2F; 解集不能包含重复的组合。 </span><br><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F; 输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">&#x2F;&#x2F;所求解集为：</span><br><span class="line">&#x2F;&#x2F;[</span><br><span class="line">&#x2F;&#x2F;  [7],</span><br><span class="line">&#x2F;&#x2F;  [2,2,3]</span><br><span class="line">&#x2F;&#x2F;]</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F; 输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">&#x2F;&#x2F;所求解集为：</span><br><span class="line">&#x2F;&#x2F;[</span><br><span class="line">&#x2F;&#x2F;  [2,2,2,2],</span><br><span class="line">&#x2F;&#x2F;  [2,3,3],</span><br><span class="line">&#x2F;&#x2F;  [3,5]</span><br><span class="line">&#x2F;&#x2F;] </span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; candidates.length &lt;&#x3D; 30 </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; candidates[i] &lt;&#x3D; 200 </span><br><span class="line">&#x2F;&#x2F; candidate 中的每个元素都是独一无二的。 </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; target &lt;&#x3D; 500 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong>：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Integer target = <span class="number">7</span>;</span><br><span class="line">        Integer[] candidates = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        combinationSum(combinations, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), target,candidates,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(combinations.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combinationSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; combinations, ArrayList&lt;Integer&gt; combination, Integer target, Integer[] candidates,Integer sum,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            combinations.add(<span class="keyword">new</span> ArrayList&lt;&gt;(combination));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = index;i&lt; candidates.length;i++) &#123;<span class="comment">//由于数组是有序的，所以可以通过i = index进行去重</span></span><br><span class="line">                sum = sum + candidates[i];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt;= target) &#123;<span class="comment">//由于数组是有序的，所以当sum&gt;target时就无需再往下递归了，同层次的数组也无需继续遍历</span></span><br><span class="line">                    combination.add(candidates[i]);</span><br><span class="line">                	 combinationSum(combinations,combination,target,candidates,sum,i);</span><br><span class="line">                    sum = sum - candidates[i];</span><br><span class="line">                    combination.remove(combination.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS1：由于递归回溯出来的结果是一个个全排列子集，所以当进行组合时需要去除重复的子集，这也是回溯算法解决组合问题的最大难点</p>
<p>PS2：当使用回溯时，需要找到一个合适的条件进行剪枝</p>
</blockquote>
<h4 id="4，组合求和（2）"><a href="#4，组合求和（2）" class="headerlink" title="4，组合求和（2）"></a>4，组合求和（2）</h4><p><strong>题目</strong>：</p>
<blockquote>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; candidates 中的每个数字在每个组合中只能使用一次。 </span><br><span class="line">&#x2F;&#x2F; 说明： </span><br><span class="line">&#x2F;&#x2F; 所有数字（包括目标数）都是正整数。 </span><br><span class="line">&#x2F;&#x2F; 解集不能包含重复的组合。 </span><br><span class="line">&#x2F;&#x2F; 示例 1: </span><br><span class="line">&#x2F;&#x2F; 输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">&#x2F;&#x2F;所求解集为:</span><br><span class="line">&#x2F;&#x2F;[</span><br><span class="line">&#x2F;&#x2F;  [1, 7],</span><br><span class="line">&#x2F;&#x2F;  [1, 2, 5],</span><br><span class="line">&#x2F;&#x2F;  [2, 6],</span><br><span class="line">&#x2F;&#x2F;  [1, 1, 6]</span><br><span class="line">&#x2F;&#x2F;]</span><br><span class="line">&#x2F;&#x2F; 示例 2: </span><br><span class="line">&#x2F;&#x2F; 输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">&#x2F;&#x2F;所求解集为:</span><br><span class="line">&#x2F;&#x2F;[</span><br><span class="line">&#x2F;&#x2F;  [1,2,2],</span><br><span class="line">&#x2F;&#x2F;  [5]</span><br><span class="line">&#x2F;&#x2F;] </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span>[] candidates = &#123;<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        combinationSum2(combinations, candidates, target, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        System.out.println(combinations.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combinationSum2</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; combinations, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;Integer&gt; combination, <span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            combinations.add(<span class="keyword">new</span> ArrayList&lt;&gt;(combination));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>])<span class="keyword">continue</span>;<span class="comment">//区别于组合求和（1），需要对同个树层的重复数字进行去重，对于同个树枝的重复数字则保留</span></span><br><span class="line">                sum += candidates[i];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt;= target ) &#123;</span><br><span class="line">                    combination.add(candidates[i]);</span><br><span class="line">                    combinationSum2(combinations, candidates,target, combination, sum, i + <span class="number">1</span>);<span class="comment">//index表示递归深入的树层数，i表示遍历集合的树枝数</span></span><br><span class="line">                    sum -= candidates[i];</span><br><span class="line">                    combination.remove(combination.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS1：求组合问题时有些时候需要进行树层去重，而树枝不去重</p>
<p>PS2：index表示当前递归层次，i表示当前遍历集合中第i个元素</p>
</blockquote>
<h4 id="5，全排列（1）"><a href="#5，全排列（1）" class="headerlink" title="5，全排列（1）"></a>5，全排列（1）</h4><p><strong>题目</strong>：</p>
<blockquote>
<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例: </span><br><span class="line">&#x2F;&#x2F; 输入: [1,2,3]</span><br><span class="line">&#x2F;&#x2F;输出:</span><br><span class="line">&#x2F;&#x2F;[</span><br><span class="line">&#x2F;&#x2F;  [1,2,3],</span><br><span class="line">&#x2F;&#x2F;  [1,3,2],</span><br><span class="line">&#x2F;&#x2F;  [2,1,3],</span><br><span class="line">&#x2F;&#x2F;  [2,3,1],</span><br><span class="line">&#x2F;&#x2F;  [3,1,2],</span><br><span class="line">&#x2F;&#x2F;  [3,2,1]</span><br><span class="line">&#x2F;&#x2F;] </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong>：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        arrange(arrayList, nums, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        System.out.println(arrayList.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrange</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; arrayList, <span class="keyword">int</span>[] nums, ArrayList&lt;Integer&gt; array, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            arrayList.add(<span class="keyword">new</span> ArrayList&lt;&gt;(array));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] == array.get(j)) &#123;</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                array.add(nums[i]);</span><br><span class="line">                arrange(arrayList, nums, array, index + <span class="number">1</span>);</span><br><span class="line">                array.remove(array.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：无重复数字序列时，全排列需要对树枝去重，而不对树层去重</p>
</blockquote>
<h4 id="6，全排列（2）"><a href="#6，全排列（2）" class="headerlink" title="6，全排列（2）"></a>6，全排列（2）</h4><p><strong>题目</strong></p>
<blockquote>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：nums &#x3D; [1,1,2]</span><br><span class="line">&#x2F;&#x2F;输出：</span><br><span class="line">&#x2F;&#x2F;[[1,1,2],</span><br><span class="line">&#x2F;&#x2F; [1,2,1],</span><br><span class="line">&#x2F;&#x2F; [2,1,1]]</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：nums &#x3D; [1,2,3]</span><br><span class="line">&#x2F;&#x2F;输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; nums.length &lt;&#x3D; 8 </span><br><span class="line">&#x2F;&#x2F; -10 &lt;&#x3D; nums[i] &lt;&#x3D; 10 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        arrange(arrayList, nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>,visit);</span><br><span class="line">        System.out.println(arrayList.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrange</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; arrayList, <span class="keyword">int</span>[] nums, ArrayList&lt;Integer&gt; array, <span class="keyword">int</span> index, <span class="keyword">boolean</span>[] visit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            arrayList.add(<span class="keyword">new</span> ArrayList&lt;&gt;(array));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visit[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visit[i - <span class="number">1</span>])) &#123;<span class="comment">//对树层去重和对索引使用去重</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                array.add(nums[i]);</span><br><span class="line">                visit[i] = <span class="keyword">true</span>;</span><br><span class="line">                arrange(arrayList, nums, array, index + <span class="number">1</span>, visit);</span><br><span class="line">                visit[i] = <span class="keyword">false</span>;</span><br><span class="line">                array.remove(array.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PS1：在含重复数字的序列全排列时，需要进行树层去重，和使用索引去重</p>
<p>PS2：使用索引去重一般通过建立一个boolean[] visit数组记录每个被使用的索引</p>
</blockquote>
<h4 id="7，N皇后"><a href="#7，N皇后" class="headerlink" title="7，N皇后"></a>7，N皇后</h4><p><strong>题目</strong>：</p>
<blockquote>
<p>皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案</span><br><span class="line">&#x2F;&#x2F; 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。</span><br><span class="line">&#x2F;&#x2F; 示例 1：</span><br><span class="line">&#x2F;&#x2F;输入：n &#x3D; 4</span><br><span class="line">&#x2F;&#x2F;输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">&#x2F;&#x2F;解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br><span class="line">&#x2F;&#x2F; 示例 2：</span><br><span class="line">&#x2F;&#x2F;输入：n &#x3D; 1</span><br><span class="line">&#x2F;&#x2F;输出：[[&quot;Q&quot;]]</span><br><span class="line">&#x2F;&#x2F; 提示：</span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; n &lt;&#x3D; 9 </span><br><span class="line">&#x2F;&#x2F; 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//存放解决方案</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; solution = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//存放每个棋子在其对应行的位置</span></span><br><span class="line">        <span class="keyword">int</span>[] queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(queens,-<span class="number">1</span>);</span><br><span class="line">        List&lt;Integer&gt; col = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; diagonals1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; diagonals2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        solvesQueen(solution,queens,<span class="number">0</span>,col,diagonals1,diagonals2,n);</span><br><span class="line">        System.out.println(solution.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solvesQueen</span><span class="params">(List&lt;List&lt;String&gt;&gt; solution, <span class="keyword">int</span>[] queens, <span class="keyword">int</span> row, List&lt;Integer&gt; col, List&lt;Integer&gt; diagonals1, List&lt;Integer&gt; diagonals2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            List&lt;String&gt; board = generate(queens, n);</span><br><span class="line">            solution.add(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col.contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当从右上到左下的行列之差,即为一条斜线的索引</span></span><br><span class="line">                <span class="keyword">int</span> diagonal1 = row - i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals1.contains(diagonal1)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当从左上到右下的行列之差,即为一条斜线的索引</span></span><br><span class="line">                <span class="keyword">int</span> diagonal2 = row + i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals2.contains(diagonal2)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queens[row] = i;</span><br><span class="line">                col.add(i);</span><br><span class="line">                diagonals1.add(diagonal1);</span><br><span class="line">                diagonals2.add(diagonal2);</span><br><span class="line">                solvesQueen(solution, queens, row + <span class="number">1</span>, col, diagonals1, diagonals2, n);</span><br><span class="line">                queens[row] = -<span class="number">1</span>;</span><br><span class="line">                col.remove(col.size() - <span class="number">1</span>);</span><br><span class="line">                diagonals1.remove(diagonals1.size() - <span class="number">1</span>);</span><br><span class="line">                diagonals2.remove(diagonals2.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span>[] queens, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; board = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] row = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">            Arrays.fill(row, <span class="string">'.'</span>);</span><br><span class="line">            row[queens[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            board.add(<span class="keyword">new</span> String(row));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：画图寻找出可以通过一个数值来表示一条斜线的规律</p>
</blockquote>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p>==<a href="https://blog.51cto.com/15069438/2575872" target="_blank" rel="noopener">一篇总结带你彻底搞透回溯算法！</a>==</p>
<p><a href="https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/9258495?fr=aladdin" target="_blank" rel="noopener">百度百科——回溯算法</a></p>
<p><a href="https://www.sohu.com/a/431494940_373022" target="_blank" rel="noopener">什么叫回溯算法，一看就会，一写就废</a></p>
<p><a href="https://my.oschina.net/u/3024426/blog/4689026" target="_blank" rel="noopener">简单易懂的回溯算法（Back Tracking)</a></p>
<p><a href="https://blog.csdn.net/weiyuefei/article/details/79316653" target="_blank" rel="noopener">[回溯算法] 五大常用算法之回溯法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/08/BackTracking/" data-id="cks69tfzo0004iwua3gkiadsi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jvm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/05/jvm/" class="article-date">
  <time datetime="2021-04-05T14:58:19.000Z" itemprop="datePublished">2021-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/05/jvm/">jvm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="JVM上篇——内存与垃圾回收"><a href="#JVM上篇——内存与垃圾回收" class="headerlink" title="JVM上篇——内存与垃圾回收"></a>JVM上篇——内存与垃圾回收</h2><h3 id="一，JVM和Java体系结构"><a href="#一，JVM和Java体系结构" class="headerlink" title="一，JVM和Java体系结构"></a>一，JVM和Java体系结构</h3><h4 id="1，虚拟机和Java虚拟机"><a href="#1，虚拟机和Java虚拟机" class="headerlink" title="1，虚拟机和Java虚拟机"></a>1，虚拟机和Java虚拟机</h4><ul>
<li><p><strong>虚拟机</strong>：所谓虚拟机（Virtual Machine），就是一台虚拟的计算机，它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p>
</li>
<li><p>大名鼎鼎的Visual Box，VMware就是属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台</p>
<ul>
<li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行指令单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令</li>
</ul>
</li>
<li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
</li>
<li><p><strong>Java虚拟机</strong>：</p>
<ul>
<li><p>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成</p>
</li>
<li><p>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性，优秀的垃圾回收器，以及可靠的即时编译器</p>
</li>
<li><p>Java技术的核心就是Java虚拟机（JVM，JAVA Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2，JVM的位置"><a href="#2，JVM的位置" class="headerlink" title="2，JVM的位置"></a>2，JVM的位置</h4><p><img src="/2021/04/05/jvm/1.png" alt="image-20210407202220536"></p>
<p><img src="/2021/04/05/jvm/2.png" alt="image-20210407202342534"></p>
<h4 id="3，JVM的整体结构"><a href="#3，JVM的整体结构" class="headerlink" title="3，JVM的整体结构"></a>3，JVM的整体结构</h4><p><img src="/2021/04/05/jvm/3.png" alt="image-20210407202737422"></p>
<h4 id="4，Java代码执行流程"><a href="#4，Java代码执行流程" class="headerlink" title="4，Java代码执行流程"></a>4，Java代码执行流程</h4><p><img src="/2021/04/05/jvm/4.png" alt="image-20210407202908303"></p>
<ul>
<li>Java编译器编译过程中共，任何一个节点执行失败就会造成编译失败</li>
<li>虽然各个平台的Java虚拟机内部实现细节不尽相同，但是他们共同执行的字节码内容却是一样的</li>
<li>JVM的主要任务就是负责将字节码装载到其内容，解释/编译为对应平台上的机器指令（即：汇编语言）执行</li>
<li>Java虚拟机使用类加载器（Class Loader）装载class文件</li>
<li>类加载完成之后，会进行字节码校验，字节码检验通过之后JVM解释器会把字节码翻译成机器码（即：汇编语言）交由操作系统执行</li>
<li>但不是所有代码都是解释执行的，JVM对此做了优化，比如：以Hotspot虚拟机来说，它本身提供了JIT（Just In Time)</li>
</ul>
<h4 id="5，JVM的架构模型："><a href="#5，JVM的架构模型：" class="headerlink" title="5，JVM的架构模型："></a>5，JVM的架构模型：</h4><ul>
<li>Java编译器输入的指令流基本上只是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构</li>
<li>具体来说：这两种架构之间的区别：<ul>
<li><strong>基于栈式架构的特点</strong>：<ul>
<li>设计和实现更简单，适用于资源受限的系统</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配</li>
<li>指令流的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
</li>
<li><strong>基于寄存器架构的特点</strong>：<ul>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机</li>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项擦欧总</li>
<li>在大部分情况下，基于寄存器结构的指令集往往都以一地址指令，二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li>
</ul>
</li>
<li><strong>总结</strong>：<ul>
<li>由于跨平台的设计，Java的指令都是根据栈来设计的，不同平台CPU架构不同，所以不能设计为基于寄存器的，优点式跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li>
<li>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</li>
<li>栈：跨平台性，指令集小，指令多：执行性能比寄存器差</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6，JVM的生命周期："><a href="#6，JVM的生命周期：" class="headerlink" title="6，JVM的生命周期："></a>6，JVM的生命周期：</h4><ul>
<li><strong>虚拟机的启动</strong>：<ul>
<li>Java虚拟机的启动是通过引导类加载器（bootstrap class loader)创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</li>
</ul>
</li>
<li><strong>虚拟机的执行</strong>：<ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li>
<li>程序开始执行时它才运行，程序结束时它就停止</li>
<li><strong>执行功一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</strong></li>
</ul>
</li>
<li><strong>虚拟机的退出</strong>：<ul>
<li>有如下的几种情况：<ul>
<li>程序正常执行结束；</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
<li>某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作</li>
<li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7，JVM的发展历程："><a href="#7，JVM的发展历程：" class="headerlink" title="7，JVM的发展历程："></a>7，JVM的发展历程：</h4><ul>
<li>Sun Classic VM：世界上第一款商用Java虚拟机，只提供了解释器</li>
<li>Exact VM</li>
<li>HotSpot VM</li>
<li>JRockit：是世界上最快的JVM</li>
<li>IBM J9</li>
<li>KVM，CDC和CLDC</li>
<li>Azul VM</li>
<li>Liquid VM</li>
<li>Apache Harmony</li>
<li>Microsoft JVM</li>
<li>Taobao JVM</li>
<li>Dalvik VM</li>
<li>Graal VM</li>
</ul>
<h3 id="二，类加载子系统"><a href="#二，类加载子系统" class="headerlink" title="二，类加载子系统"></a>二，类加载子系统</h3><h4 id="1，内存结构概述"><a href="#1，内存结构概述" class="headerlink" title="1，内存结构概述"></a>1，内存结构概述</h4><p><img src="/2021/04/05/jvm/5.png" alt="image-20210410022103360"></p>
<h4 id="2，类加载器与类的加载过程"><a href="#2，类加载器与类的加载过程" class="headerlink" title="2，类加载器与类的加载过程"></a>2，类加载器与类的加载过程</h4><p><img src="/2021/04/05/jvm/C:%5CUsers%5C92540%5CDesktop%5CmyselfBlog%5Chexo%5Csource_posts%5Cjvm%5C6.png" alt="image-20210410022315301"></p>
<blockquote>
<ul>
<li>类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识 (CA FE BA BE)</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定</li>
<li>加载的类信息存放于一块称为方法去的内存空间。除了类的信息外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）</li>
</ul>
</blockquote>
<p><strong>类加载器ClassLoader角色</strong></p>
<p><img src="/2021/04/05/jvm/7.png" alt="image-20210410022721196"></p>
<blockquote>
<ol>
<li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例</li>
<li>class file 加载到JVM中，被称为DNA元数据模板，放在方法区</li>
<li>在.class文件——》JVM——》最终成为元数据模板，此过程就要一个运输工具（类加载器Class Loader），扮演一个快递员的角色</li>
</ol>
</blockquote>
<p><strong>类的加载过程</strong></p>
<p><img src="/2021/04/05/jvm/8.png" alt="image-20210410023209973"></p>
<ol>
<li><p><strong>加载</strong></p>
<blockquote>
<ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法去的运行时数据结构</li>
<li>在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p><strong>补充</strong>：加载.class文件的方式</p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从zip压缩包中读取，成为日后jar,war格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，典型场景：JSP应用</li>
<li>从专有数据库中提取.class文件，比较少见</li>
<li>从加密文件中获取，典型的防class文件被反编译的保护措施    </li>
</ul>
</blockquote>
</li>
<li><p><strong>链接（Linking）</strong></p>
<blockquote>
<ol>
<li><strong>验证（Verify）</strong>:<ul>
<li>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证，<strong>文件格式验证（CA FE BA BE）</strong>，<strong>元数据验证</strong>，<strong>字节码验证</strong>，<strong>符号引用验证</strong></li>
</ul>
</li>
<li><strong>准备（Prepare)</strong>：<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值</li>
<li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</li>
<li>这里不会实例变量分配初始化，；类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li>
</ul>
</li>
<li><strong>解析（Resolve）</strong>：<ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的class文件格式中，直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄</li>
<li>解析动作主要针对类或接口，字段，类方法，接口方法，方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info，CONSTANT_Methodref_info等</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>初始化</strong></p>
<blockquote>
<ul>
<li>初始化阶段就是执行类构造器方法<clinit>()的过程</clinit></li>
<li>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        number = <span class="number">20</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        <span class="comment">//System.out.println(number);//报错：非法向前引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> numbet = <span class="number">10</span>; <span class="comment">//linking之prepare:number=0 ——》 initial:20 ——》 10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num); <span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number); <span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><clinit>()不同于类的构造器。（关联：构造器是虚拟机视角下的<init>()）</init></clinit></li>
<li>若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕</clinit></clinit></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//加载Father类，其次加载Son类</span></span><br><span class="line">        System.out.println(Son.B); <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁</clinit></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName + <span class="string">"开始"</span>);</span><br><span class="line">            DeadThread dead = <span class="keyword">new</span> DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">"线程1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">"线程2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trur)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread.getName() + <span class="string">"初始化当前类"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h4 id="3，类加载器分类"><a href="#3，类加载器分类" class="headerlink" title="3，类加载器分类"></a>3，类加载器分类</h4><blockquote>
<ul>
<li>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</li>
<li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</li>
</ul>
<p><img src="/2021/04/05/jvm/9.png" alt="image-20210410150004627"></p>
</blockquote>
<p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p>
<blockquote>
<ul>
<li>虚拟机自带的加载器</li>
<li>这个类加载使用C/C++语言实现的，嵌套在JVM内部</li>
<li>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar，resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承java.lang.ClassLoader，没有父类加载器</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java，javax，sun等开头的类</li>
</ul>
</blockquote>
<p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
<blockquote>
<ul>
<li>虚拟机自带的加载器</li>
<li><strong>Java语言编写</strong>，由sun.misc.Launcher$ExtClassLoader实现</li>
<li><strong>派生于ClassLoader类</strong></li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。<strong>如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</strong></li>
</ul>
</blockquote>
<p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p>
<blockquote>
<ul>
<li>虚拟机自带的加载器</li>
<li>Java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性，java.class.path指定路径下的类库</li>
<li><strong>该类加载是程序中默认的类加载器</strong>，一般来说，Java应用的类都是由它来完成加载</li>
<li>通过ClassLoader.getSystemClassLoader()方法考研获取到该类加载器</li>
</ul>
</blockquote>
<p><strong>用户自定义类加载器</strong></p>
<blockquote>
<ul>
<li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式</li>
<li><strong>为什么要自定义类加载器</strong>？<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
</li>
<li><strong>用户自定义类加载器实现步骤</strong>：<ol>
<li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass（）方法以及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="4，ClassLoader的使用说明"><a href="#4，ClassLoader的使用说明" class="headerlink" title="4，ClassLoader的使用说明"></a>4，ClassLoader的使用说明</h4><ul>
<li><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
<p><img src="/2021/04/05/jvm/10.png" alt="image-20210410165605870"></p>
</li>
<li><p><strong>获取ClassLoader的途径</strong>：</p>
<p><img src="/2021/04/05/jvm/11.png" alt="image-20210410165710316"></p>
</li>
</ul>
<h4 id="5，双亲委派机制"><a href="#5，双亲委派机制" class="headerlink" title="5，双亲委派机制"></a>5，双亲委派机制</h4><blockquote>
<p>java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机采用的是<strong>双亲委派模式</strong>，即把请求交由父类处理，它是一种任务委派模式。</p>
</blockquote>
<p><strong>工作原理</strong>：</p>
<p><img src="/2021/04/05/jvm/12.png" alt="image-20210410185025030"></p>
<ol>
<li><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</p>
</li>
<li><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</p>
</li>
<li><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</p>
</li>
</ol>
<p><strong>双亲委派机制例子</strong>：</p>
<p><img src="/2021/04/05/jvm/13.png" alt="image-20210410190704715"></p>
<p><strong>双亲委派机制的优势</strong>：</p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改（<strong>沙箱安全机制</strong>）<ul>
<li>比如自定义类：java.lang.String</li>
<li>再比如自定义类：java.lang.ShkStart</li>
<li>抛出异常：<code>java.lang.SecurityException:Prohibited package name:java.lang</code></li>
</ul>
</li>
</ul>
<p><strong>沙箱安全机制</strong>：</p>
<blockquote>
<p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法就是因为加载的是rt.jar包中的String类，这样可以保证对Java核心源代码的保护，这就是沙箱保护机制</p>
</blockquote>
<h4 id="6，其他"><a href="#6，其他" class="headerlink" title="6，其他"></a>6，其他</h4><ul>
<li>在JVM中表示两个class对象是否为同一类存在两个必要条件：<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</li>
</ul>
</li>
<li>换句话说，在JVM中，即使这两个对象（class对象）来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li>
</ul>
<p><strong>对类加载器的引用</strong>：</p>
<blockquote>
<p>​    JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将<strong>这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析这个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</p>
</blockquote>
<p><strong>类的主动使用和被动使用</strong>：</p>
<blockquote>
<p>Java程序对类的使用方式分为：主动使用和被动使用</p>
<ul>
<li><p>主动使用，又分为七种情况：</p>
<ul>
<li><p>创建类的实例</p>
</li>
<li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p>
</li>
<li><p>调用类的静态方法</p>
</li>
<li><p>反射（比如：Class.forName(“com.atguigu.Test”)）</p>
</li>
<li><p>初始化一个类的子类</p>
</li>
<li><p>Java虚拟机启动时被标明为启动类的类</p>
</li>
<li><p>JDK7开始提供的动态语言支持：</p>
<p>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类没有初始化，则初始化</p>
</li>
</ul>
</li>
<li><p>除了以上七种情况，其他使用Java类的方式都被看作是对<strong>类的被动使用</strong>，都<strong>不会导致类的初始化</strong></p>
</li>
</ul>
</blockquote>
<h3 id="三，运行时数据区概述及线程"><a href="#三，运行时数据区概述及线程" class="headerlink" title="三，运行时数据区概述及线程"></a>三，运行时数据区概述及线程</h3><h4 id="1，运行时数据区概述"><a href="#1，运行时数据区概述" class="headerlink" title="1，运行时数据区概述"></a>1，运行时数据区概述</h4><p><img src="/2021/04/05/jvm/14.png" alt="image-20210410234653449"></p>
<blockquote>
<p>​    内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请，分配，管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一些经典的JVM内存布局。</p>
</blockquote>
<hr>
<hr>
<blockquote>
<p>​    Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁</p>
<p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p>
<ul>
<li>每个线程：独立包括程序计数器，栈，本地栈</li>
<li>线程间共享：堆，堆外内存（永久代或元空间，代码缓存）</li>
</ul>
<p><img src="/2021/04/05/jvm/15.png" alt="image-20210410235106768"></p>
<p><img src="/2021/04/05/jvm/16.png" alt="image-20210410235233378"></p>
</blockquote>
<p>关于线程间共享的说明：</p>
<ul>
<li>每个JVM只有一个Runtime实例，即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</li>
</ul>
<h4 id="2，JVM中的线程说明："><a href="#2，JVM中的线程说明：" class="headerlink" title="2，JVM中的线程说明："></a>2，JVM中的线程说明：</h4><blockquote>
<ul>
<li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li>
<li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li>
</ul>
</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</li>
<li>守护线程，普通线程</li>
</ul>
</blockquote>
<p><strong>JVM系统线程</strong>：</p>
<ul>
<li>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[] args）的main线程以及所有这个main线程自己创建的线程</li>
<li>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：<ul>
<li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li>
<li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li>
<li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li>
<li><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li>
<li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li>
</ul>
</li>
</ul>
<h3 id="四，程序计数器（PC寄存器）"><a href="#四，程序计数器（PC寄存器）" class="headerlink" title="四，程序计数器（PC寄存器）"></a>四，程序计数器（PC寄存器）</h3><p><img src="/2021/04/05/jvm/17.png" alt="image-20210411005206154"></p>
<h4 id="1，程序计数器的概述："><a href="#1，程序计数器的概述：" class="headerlink" title="1，程序计数器的概述："></a>1，程序计数器的概述：</h4><p><img src="/2021/04/05/jvm/18.png" alt="image-20210411005708411"></p>
<blockquote>
<ul>
<li>JVM中的程序计数器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。</li>
<li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</li>
<li><strong>作用</strong>：PC寄存器用来存储指令向一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</li>
<li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li>
<li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址：或者，如果是在执行native方法，则是未指定值（undefined）</li>
<li>它是程序控制流的指示器，分支，循环，跳转，异常处理，线程回复等基础功能都需要依赖这个计数器来完成。</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li>
<li>它是唯一一个在Java虚拟机规范中没有规定任何OutOtMemoryError情况的区域。</li>
</ul>
</blockquote>
<h4 id="2，两个常见问题"><a href="#2，两个常见问题" class="headerlink" title="2，两个常见问题"></a>2，两个常见问题</h4><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？（为什么使用PC寄存器记录当前线程的执行地址呢？）</strong></p>
<blockquote>
<ul>
<li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</li>
<li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</li>
</ul>
</blockquote>
<p><strong>PC寄存器为什么会被设定为线程私有？</strong></p>
<blockquote>
<ul>
<li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？未来能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li>
<li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li>
<li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li>
</ul>
</blockquote>
<h3 id="五，虚拟机栈（Java栈）"><a href="#五，虚拟机栈（Java栈）" class="headerlink" title="五，虚拟机栈（Java栈）"></a>五，虚拟机栈（Java栈）</h3><h4 id="1，虚拟机栈概述："><a href="#1，虚拟机栈概述：" class="headerlink" title="1，虚拟机栈概述："></a>1，虚拟机栈概述：</h4><p><strong>虚拟机栈出现的背景</strong>：</p>
<blockquote>
<p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。</p>
<p>优点：是跨平台，指令集小，编译器容易实现</p>
<p>缺点：是性能下降，实现同样的功能需要更多的指令。</p>
</blockquote>
<p><strong>内存中的栈与堆</strong>：</p>
<blockquote>
<p>栈是运行时的单位，而堆是存储的单位。</p>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</p>
<p>堆解决的是数据存储的问题，即数据怎么放，放在哪儿</p>
</blockquote>
<p><strong>虚拟机栈基本内容</strong>：</p>
<blockquote>
<p>​    Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p>
<ul>
<li>​    是线程私有的，即每个线程都有一个属于自己的虚拟机栈。</li>
</ul>
</blockquote>
<p><strong>生命周期</strong>：</p>
<blockquote>
<p>生命周期和线程一致</p>
</blockquote>
<p><strong>作用</strong>：</p>
<blockquote>
<p>主管Java程序的运行，它保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回。</p>
<ul>
<li>局部变量 VS 成员变量（或属性）</li>
<li>基本数据变量 VS 引用类型变量（类，数组，接口）</li>
</ul>
</blockquote>
<p><strong>栈的优点</strong>：</p>
<blockquote>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li>
<li>JVM直接对Java栈的操作只有两个：<ul>
<li>每个方法执行，伴随着进栈（入栈，压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li>对于栈来说不存在垃圾回收问题</li>
</ul>
</blockquote>
<p><strong>栈中可能出现的异常</strong>：</p>
<blockquote>
<ul>
<li>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常</li>
</ul>
</li>
<li>设置栈内存的大小：<ul>
<li>可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="2，栈的存储单元"><a href="#2，栈的存储单元" class="headerlink" title="2，栈的存储单元"></a>2，栈的存储单元</h4><p><strong>栈中存储的内容</strong>：</p>
<blockquote>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）</strong>的格式存在。</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ul>
</blockquote>
<p><strong>栈的运行原理</strong>：</p>
<blockquote>
<ul>
<li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循<strong>”先进后出“/”后进先出“（”FILO”/“LIFO”)</strong>原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong>。</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li>
<li>Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></li>
</ul>
</blockquote>
<p><strong>栈帧的内部结构</strong>：</p>
<blockquote>
<p>每个栈帧存储着：</p>
<ul>
<li><strong>局部变量表（Local Variables）</strong></li>
<li><strong>操作数栈（Operand Stack）（或表达式）</strong></li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><img src="/2021/04/05/jvm/19.png" alt="image-20210411225604978"></p>
</blockquote>
<h4 id="3，局部变量表"><a href="#3，局部变量表" class="headerlink" title="3，局部变量表"></a>3，局部变量表</h4><blockquote>
<ul>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型，对象引用（reference），以及returnAddress类型。</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译器确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中，在方法运行期间是不会改变局部变量表的大小的。</li>
<li><strong>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。</strong>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
<li><strong>局部变量表的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</strong></li>
</ul>
</blockquote>
<p><strong>关于Slot的理解（局部变量表最基本的存储单元）</strong>：</p>
<blockquote>
<ul>
<li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</li>
<li>局部变量表，<strong>最基本的存储单元时Slot（变量槽）</strong></li>
<li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li>
<li>在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot</strong>。<ul>
<li>byte，short，char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。</li>
<li>long和double则占据两个slot</li>
</ul>
</li>
<li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复</strong>制到局部变量表中的每一个slot上</li>
<li><strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。</strong>（比如：访问long或double类型变量）</li>
<li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。</li>
</ul>
<p><img src="/2021/04/05/jvm/20.png" alt="image-20210412010413931"></p>
</blockquote>
<p><strong>关于slot的重复利用问题</strong>：</p>
<blockquote>
<p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVarl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVar2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时的b就会复用a的槽位</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>静态变量与局部变量的对比</strong>：</p>
<blockquote>
<ul>
<li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配</li>
<li>我们知道类变量表有两次初始化的机会，第一次是在“<strong>准备阶段</strong>”，执行系统初始化，对类变量设置零值，另一次则是在“<strong>初始化</strong>”阶段，赋予程序员在代码中定义的初始值</li>
<li>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样的代码是错误的，没有赋值不能够使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量的分类：</p>
<ul>
<li>​    按照数据类型分：<ul>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ul>
</li>
<li>按照在类中声明的位置分：<ul>
<li>成员变量：在使用前，都经历过默认初始化赋值<ul>
<li>类变量：linking的prepare阶段：给类变量默认赋值 ——》initial阶段：给类变量显示赋值即静态代码块赋值</li>
<li>实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</li>
</ul>
</li>
<li>局部变量：在使用前，必须要进行显式赋值的，否则， 编译不通过</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>补充说明</strong>：</p>
<blockquote>
<ul>
<li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</strong></li>
</ul>
</blockquote>
<h4 id="4，操作数栈"><a href="#4，操作数栈" class="headerlink" title="4，操作数栈"></a>4，操作数栈</h4><blockquote>
<ul>
<li>每一个独立的栈帧总除了包含局部变量表以外，还包含在一个<strong>后进先出（Last-In-First-Out）</strong>的操作数栈，也可以称之为<strong>表达式栈（Expression Stack)</strong></li>
<li><strong>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）。</strong><ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用他们后再把结果压入栈。</li>
<li>比如：执行复制，交换，求和等操作</li>
</ul>
</li>
<li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令</strong>。</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li>
<li>另外，我们说<strong>Java虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</li>
<li>操作数栈，<strong>主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间。</strong></li>
<li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的。</strong></li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。</li>
<li>栈中的任何一个元素都是可以任意的Java数据类型<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>操作数栈<strong>并非采用访问索引的方式来进行数据访问的</strong>，而是只能通过标准的入栈（push）和出栈（pop）操作来完成一次数据访问。</li>
</ul>
</blockquote>
<h4 id="5，栈顶缓存机制"><a href="#5，栈顶缓存机制" class="headerlink" title="5，栈顶缓存机制"></a>5，栈顶缓存机制</h4><blockquote>
<ul>
<li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></li>
</ul>
</blockquote>
<h4 id="6，动态链接（或指向运行时常量池的方法引用）"><a href="#6，动态链接（或指向运行时常量池的方法引用）" class="headerlink" title="6，动态链接（或指向运行时常量池的方法引用）"></a>6，动态链接（或指向运行时常量池的方法引用）</h4><blockquote>
<ul>
<li>每一个栈帧内部都包含一个指向<strong>运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接（Dynamic Linking）</strong>。比如：invokedynamic指令。</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li>
</ul>
</blockquote>
<h4 id="7，方法的调用：解析与分派"><a href="#7，方法的调用：解析与分派" class="headerlink" title="7，方法的调用：解析与分派"></a>7，方法的调用：解析与分派</h4><blockquote>
<p>​    随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装，继承和多态等面向对象特性，既然<strong>这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</strong></p>
<p>​    Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
</blockquote>
<p><strong>静态链接和动态链接</strong>：</p>
<blockquote>
<p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关，</p>
<ul>
<li><strong>静态链接</strong>：<ul>
<li>当一个字节码文件被装载进JVM内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li>
</ul>
</li>
<li><strong>动态链接</strong>：<ul>
<li>如果<strong>被调用的方法在编译器无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li>
</ul>
</li>
</ul>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段，方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</strong></p>
<ul>
<li><strong>早期绑定</strong>：<ul>
<li>早期绑定就是指被调用的<strong>目标方法如果在编译期可知，且运行期保持不变</strong>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
</ul>
</li>
<li><strong>晚期绑定</strong>：<ul>
<li>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>虚方法和非虚方法</strong>：</p>
<blockquote>
<ul>
<li><p><strong>非虚方法</strong></p>
<ul>
<li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法</li>
<li>静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法。</li>
</ul>
</li>
<li><p><strong>虚方法</strong>：</p>
<ul>
<li>除了上面的几种方法外的其他方法称为虚方法。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>方法调用指令</strong>：</p>
<blockquote>
<ul>
<li>普通调用指令：<ul>
<li><strong>invokestatic：调用静态方法，解析阶段确定唯一方法版本</strong></li>
<li><strong>invokespecial：调用<init>方法，私有以及父类方法，解析阶段确定唯一方法版本</init></strong></li>
<li>invokevirtual：调用所有虚方法</li>
</ul>
</li>
<li>动态调用指令：<ul>
<li>invokedynamic：动态解析出来需要调用的方法，然后执行</li>
</ul>
</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法</strong> </p>
</blockquote>
<p><strong>关于invokedynamic指令</strong>：</p>
<blockquote>
<ul>
<li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是<strong>Java为了实现[动态类型语言]支持而做的一种改进。</strong></li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令<strong>。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接生成方式</strong></li>
<li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li>
</ul>
</blockquote>
<p><strong>动态类型语言和静态类型语言</strong>：</p>
<blockquote>
<p>​    动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译器还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>​    说的再直白一点就是，<strong>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，</strong>这是动态语言的一个重要特征。</p>
</blockquote>
<p><strong>方法重写的本质</strong>：</p>
<blockquote>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<p><strong>IllegalAccessError介绍</strong>：</p>
<ul>
<li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。    </li>
</ul>
</blockquote>
<p><strong>虚方法表</strong>：</p>
<blockquote>
<ul>
<li>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<strong>为了提高性能</strong>，JVM采用在类的方法区建立一个<strong>虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</strong></li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</li>
<li>那么虚方法表什么时候被创建<ul>
<li>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="8，方法返回地址"><a href="#8，方法返回地址" class="headerlink" title="8，方法返回地址"></a>8，方法返回地址</h4><blockquote>
<ul>
<li>存放调用该方法的PC寄存器的值</li>
<li>一个方法的结束，有两种方式：<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者会的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存着部分信息</li>
<li>本质上，方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器值等，让调用者方法继续执行下去</li>
<li><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></li>
</ul>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>：<ul>
<li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturen，freturn，dreturn以及areturn，另外还有一个return指令供声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li>
</ul>
</li>
<li>在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口：<ul>
<li>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码、</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="9，一些附加信息"><a href="#9，一些附加信息" class="headerlink" title="9，一些附加信息"></a>9，一些附加信息</h4><blockquote>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p>
</blockquote>
<h4 id="10，栈的相关面试题"><a href="#10，栈的相关面试题" class="headerlink" title="10，栈的相关面试题"></a>10，栈的相关面试题</h4><blockquote>
<ul>
<li>举例栈溢出的情况？</li>
<li>调整栈大小，就能保证不出现溢出吗？</li>
<li>分配的栈内存越大越好吗？</li>
<li>垃圾回收是否会涉及到虚拟机栈？</li>
<li>方法中定义的局部变量是否线程安全？</li>
</ul>
</blockquote>
<h3 id="六，本地方法："><a href="#六，本地方法：" class="headerlink" title="六，本地方法："></a>六，本地方法：</h3><h4 id="1，本地方法接口"><a href="#1，本地方法接口" class="headerlink" title="1，本地方法接口"></a>1，本地方法接口</h4><p><img src="/2021/04/05/jvm/21.png" alt="image-20210413133917801"></p>
<p><strong>什么是本地方法?</strong></p>
<blockquote>
<p>​    简单地讲，<strong>一个Native Method就是一个Java调用非Java代码的接口</strong>。一个Native Method是这样一个方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其他的编程语言都由这一机制，比如在C++中你可以用extern “C”告知C++编译器去调用一个C的函数</p>
<p>​    在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非Java语言在外面实现的。</p>
<p>​    本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IHaveNatives</span></span>&#123;</span><br><span class="line">    <span class="comment">//标识符native可以与所有其它的Java标识符连用，但是abstract除外</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">methodNativel</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">methodNative2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">float</span> <span class="title">methodNative3</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">methodNative4</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>为什么要使用Native Method？</strong></p>
<blockquote>
<p>​    Java使用起来非常方便，然后有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<ul>
<li><strong>与Java环境外交互</strong><ul>
<li><strong>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。</strong>你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li>
</ul>
</li>
<li><strong>与操作系统交互</strong><ul>
<li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然后不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。<strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。</strong>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
</ul>
</li>
<li><strong>Sun’s Java</strong><ul>
<li><strong>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。</strong>jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Window 95的平台上，这个本地方法最终讲调用Win32 SetPriority()API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library)提供，然后被JVM调用。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>本地方法的现状</strong>：</p>
<blockquote>
<p>​    目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等。</p>
</blockquote>
<h4 id="2，本地方法栈："><a href="#2，本地方法栈：" class="headerlink" title="2，本地方法栈："></a>2，本地方法栈：</h4><blockquote>
<ul>
<li><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong></li>
<li>本地方法栈，也是线程私有的。</li>
<li>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。</li>
</ul>
</li>
<li>本地方法是使用C语言实现的</li>
<li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。</li>
<li><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</strong><ul>
<li>本地方法可以通过本地方法接口来<strong>访问虚拟机内部的运行时数据区。</strong></li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
</li>
<li><strong>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言，具体实现方式，数据结构等。</strong>如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li>
<li>在Hotspot JVM中，直接将本地方法栈和虚拟机合二为一。</li>
</ul>
</blockquote>
<h3 id="七，堆"><a href="#七，堆" class="headerlink" title="七，堆"></a>七，堆</h3><h4 id="1，堆的核心概述："><a href="#1，堆的核心概述：" class="headerlink" title="1，堆的核心概述："></a>1，堆的核心概述：</h4><p><img src="/2021/04/05/jvm/22.png" alt="image-20210414183637514"></p>
<blockquote>
<ul>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间<ul>
<li>堆内存的大小是可以调节的</li>
</ul>
</li>
<li>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续</strong>的内存空间中，但在<strong>逻辑上</strong>它应该被视为<strong>连续</strong>的。</li>
<li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</li>
<li>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组应当在运行时分配在堆上。（The heap is hte run-time data area from which memory for all class instances and arrays is allocated <ul>
<li>从实际使用的角度来看，这里应为”几乎“所有的对象实例都在这里分配内存。</li>
</ul>
</li>
<li><strong>数组和对象可能永远不会存储在栈上</strong>，因为<strong>栈帧中保存引用</strong>，这个引用指向对象或者数组在堆中的位置</li>
</ul>
<p><img src="/2021/04/05/jvm/23.png" alt="image-20210414184513930"></p>
<ul>
<li><strong>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</strong>。</li>
<li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li>
</ul>
</blockquote>
<p><strong>堆的内存细分</strong>：</p>
<blockquote>
<p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间分为：</p>
<ul>
<li>Java7及之前堆内存逻辑上分为三部分：<strong>新生区+养老区+永久代</strong><ul>
<li>Young Generation Space     新生区        Young/New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space     养老区        Old/Tenure</li>
<li>Permanent Space                  永久区         Perm</li>
</ul>
</li>
<li>Java 8及之后堆内存逻辑上分为三部分：<strong>新生区+养老区+元空间</strong><ul>
<li>Young Generation Space      新生区           Young/New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation Space      养老区         Old/Tenure</li>
<li>Meta Space                               元空间         Meta</li>
</ul>
</li>
</ul>
<p>约定：新生区 ==  新生代   ==  年轻代         养老区  ==  老年区  ==  老年代      永久区  ==  永久代</p>
</blockquote>
<h4 id="2，设置堆内存大小与OOM"><a href="#2，设置堆内存大小与OOM" class="headerlink" title="2，设置堆内存大小与OOM"></a>2，设置堆内存大小与OOM</h4><p><strong>堆空间大小的设置</strong>：</p>
<blockquote>
<ul>
<li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx“和”-Xms”来进行设置<ul>
<li>“-Xms”用于表示堆区的起始内存，可以使用其来设置堆空间（年轻代+老年代）的初始内存大小。等价于-XX：InitialHeapSize<ul>
<li>-X ：是jvm的运行参数</li>
<li>ms：是memory start</li>
</ul>
</li>
<li>”-Xmx“则用于表示堆区的最大内存，可以使用其来设置堆空间（年轻代+老年代）的最大内存大小。等价于-XX：MaxHeapSize</li>
<li>开发中建议将初始堆内存和最大的堆内存设置成相同的值。</li>
<li>查看设置的参数：方式一：jps   /  jstat -gc 进程id；方式二：-xx:+PrintGCDetails</li>
</ul>
</li>
<li>一旦堆区中的内存大小超过”-Xmx“所指定的最大内存时，将会抛出OutOfMemoryError异常</li>
<li>通常会将-Xms和-Xmx两个参数配置相同的值，其<strong>目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong></li>
<li>默认情况下，初始内存大小：物理电脑内存大小 / 64；最大内存大小：物理电脑内存大小 / 4</li>
</ul>
</blockquote>
<h4 id="3，年轻代与老年代"><a href="#3，年轻代与老年代" class="headerlink" title="3，年轻代与老年代"></a>3，年轻代与老年代</h4><blockquote>
<ul>
<li>存储在JVM中的Java对象可以被划分为两类：<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>
</ul>
</li>
<li>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）</li>
<li>其中年轻代又可以划分为Eden空间，Survivor0空间和Survivor1空间（有时也叫做from区，to区）</li>
</ul>
<p><img src="/2021/04/05/jvm/24.png" alt="image-20210414192141621"></p>
<p>下面这参数开发中一般不会调：</p>
<p><img src="/2021/04/05/jvm/25.png" alt="image-20210414192241498"></p>
<ul>
<li>配置新生代与老年代在堆结构的占比<ul>
<li>默认-XX：NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li>
<li>可以修改-XX：NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li>
</ul>
</li>
<li>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8：1：1</li>
<li>当然开发人员可以通过选项”-XX：SurvivorRatio“调整这个空间比例。比如-XX：SurvivorRatio=8</li>
<li><strong>几乎所有</strong>的Java对象都是在Eden区被new出来的</li>
<li>绝大部分的Java对象的销毁都在新生代进行了。<ul>
<li>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</li>
</ul>
</li>
<li>可以使用选项“-Xmn”设置新生代最大内存大小<ul>
<li>这个参数一般使用默认值就可以了</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="4，图解对象分配过程"><a href="#4，图解对象分配过程" class="headerlink" title="4，图解对象分配过程"></a>4，图解对象分配过程</h4><blockquote>
<p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配，在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完成内存回收后是否会在内存空间中产生内存碎片</p>
<ol>
<li>new的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到伊甸园区。</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区，如果没有回收，就会放到幸存者1区</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区</li>
<li>啥时候能去养老区？可以设置次数。默认是15次。<ul>
<li><strong>可以设置参数：-XX：MaxTenuringThreshold=<N>进行设置</N></strong></li>
</ul>
</li>
</ol>
<p><img src="/2021/04/05/jvm/26.png" alt="image-20210414194629429"></p>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</strong></li>
<li><strong>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。</strong></li>
</ul>
</blockquote>
<p><strong>对象分配的特殊情况</strong>：</p>
<p><img src="/2021/04/05/jvm/27.png" alt="image-20210414194936077"></p>
<h4 id="5，Minor-GC-Major-GC，Full-GC"><a href="#5，Minor-GC-Major-GC，Full-GC" class="headerlink" title="5，Minor GC,Major GC，Full GC"></a>5，Minor GC,Major GC，Full GC</h4><blockquote>
<p>JVM在进行GC时，并非每次都对上面三个内存区域（新生代，老年代，方法区）一起回收的，大部分时候回收的都是指新生代</p>
<p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC)</p>
<ul>
<li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul>
<li>新生代收集（Minor GC/Young GC）：只是新生代（Eden/S0,S1）的垃圾收集</li>
<li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为</li>
<li><strong>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收</strong></li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集<ul>
<li>目前，只有G1  GC会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</li>
</ul>
</blockquote>
<p><strong>年轻代GC（Minor GC）触发机制</strong>：</p>
<blockquote>
<ul>
<li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存）</li>
<li>因为Java对象<strong>大多都是具备朝生夕死</strong>的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解</li>
<li>Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>
</ul>
</blockquote>
<p><strong>老年代GC（Major GC/Full GC）触发机制</strong>：</p>
<blockquote>
<ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或”Full GC“发生了</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</li>
<li>如果Major GC后，内存还不足，就报OOM了</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
</blockquote>
<p><strong>Full GC触发机制</strong>：</p>
<blockquote>
<p>触发Full GC执行的情况有如下五种：</p>
<ul>
<li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区，survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
<p>说明：<strong>Full GC是开发或调优中尽量要避免使用的。这样暂时时间会短一些。</strong></p>
</blockquote>
<h4 id="6，堆空间分代思想"><a href="#6，堆空间分代思想" class="headerlink" title="6，堆空间分代思想"></a>6，堆空间分代思想</h4><p><strong>为什么需要把Java堆分代？不分代就不能正常工作了吗？</strong></p>
<blockquote>
<ul>
<li>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象<ul>
<li>新生代：有Eden，两块大小相同的Survivor（又称为from/to，s0/s1）构成，to总为空。</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象。</li>
</ul>
</li>
<li>其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能。</strong>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一个地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</li>
</ul>
</blockquote>
<h4 id="7，内存分配策略（或对象提升（Promotion）规则）"><a href="#7，内存分配策略（或对象提升（Promotion）规则）" class="headerlink" title="7，内存分配策略（或对象提升（Promotion）规则）"></a>7，内存分配策略（或对象提升（Promotion）规则）</h4><blockquote>
<p>​    如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1.。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM，每个GC都有所不同）时，就会被晋升到老年代中。</p>
<p>​    对象晋升老年代的年龄阈值，可以通过选项：-XX：MaxTenuringThreshold来设置</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li><p>优先分配到Eden</p>
</li>
<li><p>大对象直接分配到老年代</p>
<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li><p>长期存活的对象分配到老年代</p>
</li>
<li><p>动态对象年龄判断</p>
<ul>
<li>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li>
</ul>
</li>
<li><p>空间分配担保：</p>
<ul>
<li>-XX：HandlePromotionFailure</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="8，为对象分配内存：TLAB"><a href="#8，为对象分配内存：TLAB" class="headerlink" title="8，为对象分配内存：TLAB"></a>8，为对象分配内存：TLAB</h4><p><strong>为什么有TLAB（Thread Local Allocation Bufferd）？</strong></p>
<blockquote>
<ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
</blockquote>
<p><strong>什么是TLAB？</strong></p>
<blockquote>
<ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为<strong>每个线程分配了一个私有缓存区域</strong>，它包含在Eden空间内</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题。同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li>
<li>所有OpenJDK衍生出来的JVM都提供了TLAB的设计</li>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选。</strong></li>
<li>在程序中，开发人员可以通过选项“-XX：UserTLAB”设置是否开启TLAB空间</li>
<li>默认情况下，TLAB空间的内存非常小，仅<strong>占有整个Eden空间的1%</strong>，当然我们可以通过选项”-XX：TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配内存。</li>
</ul>
</blockquote>
<p><strong>加入TLAB的分配过程</strong>：</p>
<p><img src="/2021/04/05/jvm/28.png" alt="image-20210414205852808"></p>
<h4 id="9，小结堆空间的参数设置"><a href="#9，小结堆空间的参数设置" class="headerlink" title="9，小结堆空间的参数设置"></a>9，小结堆空间的参数设置</h4><blockquote>
<ul>
<li>官网说明：<a href="https://docs/oracle.com.javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">oracle之Java虚拟机官网</a></li>
<li>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</li>
<li>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）<ul>
<li>具体查看某个参数的指令：jps：查看当前运行中的进程     /      jinfo -flag SurvivorRatio 进程id</li>
</ul>
</li>
<li>-Xms：初始堆空间内存（默认为物理内存的1/64）</li>
<li>-Xmx：最大堆空间内存（默认为物理内存的1/4）</li>
<li>-Xmn：设置新生代的大小。（初始值及最大值）</li>
<li>-XX：NewRatio：配置新生代与老年代在堆结构的占比</li>
<li>-XX：SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</li>
<li>-XX：MaxTenurinaThreshold：设置新生代垃圾的最大年龄</li>
<li>-XX：+PrintGCDetails：输出详细的GC处理日志</li>
<li>打印GC简要信息：1，-XX：+PrintGC          2，-verbose:gc</li>
<li>-XX：HandlePromotionFailure：是否设置空间分配担保</li>
</ul>
</blockquote>
<p><strong>-XX：HandlePromotionFailure：是否设置空间分配担保</strong></p>
<blockquote>
<p><strong>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</strong></p>
<ul>
<li>如果大于，则此次Minor GC是安全的</li>
<li>如果小于，则虚拟机会查看-XX：HandlePromotionFailure设置值是否允许担保失败<ul>
<li>如果HandlePromotionFailure=true，那么会继续<strong>检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong><ul>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的</li>
<li>如果小于，则改为进行一次Full GC</li>
</ul>
</li>
<li>如果HandlePromotionFailure=false，则改为进行一次Full GC</li>
</ul>
</li>
</ul>
<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察OpenJDK中源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6  Update24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小</strong>或者<strong>历次晋升的平均大小就会进行Minor GC，否则将进行Full GC</strong></p>
</blockquote>
<h4 id="10，堆是分配对象的唯一选择吗？"><a href="#10，堆是分配对象的唯一选择吗？" class="headerlink" title="10，堆是分配对象的唯一选择吗？"></a>10，堆是分配对象的唯一选择吗？</h4><blockquote>
<p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>
<ul>
<li>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配，标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</li>
</ul>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</strong>这样就无需在堆上分配内存，也无须进行垃圾回收了，这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于OpendJDk深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
</blockquote>
<p><strong>逃逸分析概述</strong>：</p>
<blockquote>
<ul>
<li><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
</li>
<li><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</p>
</li>
<li><p>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上</p>
</li>
<li><p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my_method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">//user v</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码如果想要StringBuffer sb不逃出方法，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>逃逸分析代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*逃逸分析</span></span><br><span class="line"><span class="comment">*如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span>?<span class="keyword">new</span> EscapeAnalysis():obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">    思考：如果当前的obj引用声明为static？ 仍然会发生逃逸。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx() :同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逃逸分析参数设置</strong>：</p>
<blockquote>
<ul>
<li>在JDK6u23版本之后，HotSpot中默认就已经开启了逃逸分析</li>
<li>如果使用的是较早的版本，开发人员则可以通过：<ul>
<li>选项“-XX：+DoEscapeAnalysis”显示开启逃逸分析</li>
<li>通过选项“-XX：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>结论</strong>：</p>
<blockquote>
<p>开发中能使用局部变量的，就不要使用在方法外定义</p>
</blockquote>
<h4 id="11，逃逸分析之代码优化"><a href="#11，逃逸分析之代码优化" class="headerlink" title="11，逃逸分析之代码优化"></a>11，逃逸分析之代码优化</h4><blockquote>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ul>
<li><strong>一，栈上分配</strong>。<ul>
<li>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</li>
</ul>
</li>
<li><strong>二，同步省略</strong>。<ul>
<li>如果一个对象被发现只能从一个线程被访问到，那对于这个对象的操作可以不考虑同步</li>
</ul>
</li>
<li><strong>三，分离对象或标量替换。</strong><ul>
<li>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>代码优化之栈上分配</strong>：</p>
<blockquote>
<ul>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li>
<li><strong>常见的栈上分配的场景</strong>：<ul>
<li>在逃逸分析中，已经说明了，分别是给成员变量赋值，方法返回值，实例引用传递。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>代码优化之同步省略（消除）</strong></p>
<blockquote>
<ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li>
<li>在动态编译同步块的时候，JIT编译器可以<strong>借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</strong>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<strong>锁消除</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hollis)&#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f（）方法中，并不会被其他线程所访问到，所以在JIT编译阶段就被优化掉。优化成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(hollis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码优化之标量替换</strong></p>
<blockquote>
<p><strong>标量（Scalar）</strong>是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做<strong>聚合量（Aggregate）</strong>，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"point.x="</span>+point.x<span class="string">";point.y="</span>+point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，经过标量替换后，就会变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"point.x="</span>+x+<span class="string">";point.y="</span>+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了，标量替换为栈上分配提供了很好的基础。</p>
<p><strong>标量替换参数设置</strong>：</p>
<ul>
<li>参数-XX：+EliminateAllocations；开启了标量替换（默认打开），允许将对象打散分配在栈上。</li>
</ul>
</blockquote>
<p><strong>使用如下参数运行代码</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里使用参数如下：</p>
<ul>
<li>参数 -server：启动Server模式，因为在Server模式下，才可以启动逃逸分析。</li>
<li>参数 -XX：+DoEscapeAnalysis：启动逃逸分析</li>
<li>参数 -Xmx10m：指定了堆空间最大为10MB</li>
<li>参数 -XX：+PrintGc：将打印GC日志</li>
<li>参数 -XX：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>
</ul>
</blockquote>
<p><strong>逃逸分析小结：逃逸分析并不成熟</strong></p>
<blockquote>
<ul>
<li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li>
<li>其根本原因就是<strong>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换，栈上分配，和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了</li>
<li>虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong></li>
<li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。OraclE Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上</li>
<li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上。</strong></li>
</ul>
</blockquote>
<h4 id="12，常用的调优工具；"><a href="#12，常用的调优工具；" class="headerlink" title="12，常用的调优工具；"></a>12，常用的调优工具；</h4><blockquote>
<ul>
<li>JDK命令行</li>
<li>Eclipse:Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>VisualVM</li>
<li>Jprofiler</li>
<li>Java Flight Recorder</li>
<li>GCViewer</li>
<li>GC Easy</li>
</ul>
</blockquote>
<h4 id="13，本章小结"><a href="#13，本章小结" class="headerlink" title="13，本章小结"></a>13，本章小结</h4><blockquote>
<ul>
<li>年轻代是对象的诞生，成长，消亡的区域，一个对象在这里产生，应用，最后被垃圾回收器收集，结束生命。</li>
<li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li>
<li>当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者FullGC。一般的，MinorGC的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代</li>
</ul>
</blockquote>
<h3 id="八，方法区"><a href="#八，方法区" class="headerlink" title="八，方法区"></a>八，方法区</h3><p><img src="/2021/04/05/jvm/29.png" alt="image-20210416005402606"></p>
<h4 id="1，栈，堆，方法区的交互关系"><a href="#1，栈，堆，方法区的交互关系" class="headerlink" title="1，栈，堆，方法区的交互关系"></a>1，栈，堆，方法区的交互关系</h4><p><img src="/2021/04/05/jvm/30.png" alt="image-20210416005651447"></p>
<p><img src="/2021/04/05/jvm/31.png" alt="image-20210416005735103"></p>
<h4 id="2，方法区的理解"><a href="#2，方法区的理解" class="headerlink" title="2，方法区的理解"></a>2，方法区的理解</h4><p><strong>方法区在哪里？</strong></p>
<blockquote>
<p>​    《Java虚拟机》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对HotSpot JVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p>
<p>所以，<strong>方法区看作是一块独立于Java堆的内存空间。</strong></p>
<p><img src="/2021/04/05/jvm/32.png" alt="image-20210416010130465"></p>
<ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError：<strong>PermGen spac</strong>e或者java.lang.OutOfMemoryError：<strong>Metaspace</strong><ul>
<li>加载大量的第三方的jar包；Tomcat部署的工程过多（30-50个）；大量动态的生成反射类</li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
</blockquote>
<p><strong>Hotspot方法区的演进</strong>：</p>
<blockquote>
<ul>
<li>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代</li>
<li>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9中不存在永久代的概念<ul>
<li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过-XX：MaxPermSizes上限）</li>
</ul>
</li>
<li>而到了JDK 8 ，终于完全废弃了永久代的概念，改用与JRockit ，J9一样在本地内存中实现的元空间（Metaspace）来代替</li>
</ul>
<p><img src="/2021/04/05/jvm/33.png" alt="image-20210416011209737"></p>
<ul>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用了本地内存。</strong></li>
<li>永久代，元空间二者并不只是名字改变了，内部结构也调整了</li>
<li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。</li>
</ul>
</blockquote>
<h4 id="3，设置方法区大小与OOM"><a href="#3，设置方法区大小与OOM" class="headerlink" title="3，设置方法区大小与OOM"></a>3，设置方法区大小与OOM</h4><blockquote>
<ul>
<li>方法区的大小不必是固定的，jvm可以根据应用的需要动态调整</li>
<li><strong>JDK 7以前</strong>：<ul>
<li><strong>通过-XX：PermSize来设置永久代初始分配空间，默认值是20.75M</strong></li>
<li><strong>-XX：MaxPermSize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</strong></li>
<li>当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError：PermGenspace</li>
</ul>
</li>
<li><strong>JDK 8以后</strong>：<ul>
<li>元数据区大小可以使用参数:XX：MetaspaceSize和-XX：MaxMetaspaceSize指定，替代上述原有的两个参数</li>
<li>默认值依赖于平台，<strong>window下，-XX：MetaspaceSize是21M，-XX：MaxMetaspaceSize的值是-1，即没有限制</strong></li>
<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError：Metaspace</li>
<li>-XX：MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX：MetaspaceSize值为21MB，这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少的元空间，如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值，如果释放空间过多，则适当降低该值。</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用，为了避免频繁地GC，建议将-XX：MetaspaceSize设置为一个相对较高的值。 </li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>如何解决这些OOM</strong>？</p>
<blockquote>
<p><strong>使方法区出现内存溢出异常</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*jdk8中：</span></span><br><span class="line"><span class="comment">*-XX：MetaspaceSize=10m  -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment">*jdk6中：</span></span><br><span class="line"><span class="comment">*-XX：PermSize=10m  -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            OOMTest test = <span class="keyword">new</span> OOMTest();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，public，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_6,Opcodes.ACC_PUBLIC,<span class="string">"Class"</span>+i,<span class="keyword">null</span>,<span class="string">"java/lang/Object"</span>,<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">"Class"</span>+i,code,<span class="number">0</span>,code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）</li>
<li>如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链，于是就能找到泄露对象是通过怎么的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们的。掌握了泄露对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置</li>
<li>如果不存在内存泄露，换句话说就是内存中的对象却是都还必须存活着，那就应当检查虚拟机的堆参数（-Xms与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长，持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
</blockquote>
<h4 id="4，方法区的内部结构"><a href="#4，方法区的内部结构" class="headerlink" title="4，方法区的内部结构"></a>4，方法区的内部结构</h4><p><img src="/2021/04/05/jvm/34.png" alt="image-20210416014214540"></p>
<p><strong>方法区（Method Area存储什么）</strong>？</p>
<blockquote>
<p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息，常量，静态变量，即时编译器编译后的代码缓存</strong>等。</p>
<p><img src="/2021/04/05/jvm/35.png" alt="image-20210416014434999"></p>
</blockquote>
<p><strong>类型信息</strong>：</p>
<blockquote>
<p>对每个加载的类型（类class，接口interface，枚举enum，注解annotation），JVM必须在方法区中存储以下类型信息：</p>
<ul>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public ，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
</blockquote>
<p><strong>域（Field）信息</strong></p>
<blockquote>
<ul>
<li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li>
<li>域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li>
</ul>
</blockquote>
<p><strong>方法（Method）信息</strong></p>
<blockquote>
<p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li>方法的字节码（bytecodes），操作数栈，局部变量表以及大小（abstract和native方法除外）</li>
<li>异常表（abstract和native方法除外）<ul>
<li>每个异常处理的开始位置，结束位置，代码处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>non-final的类常量</strong>：</p>
<blockquote>
<ul>
<li>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。</li>
<li>类变量被类的所有实例共享，即使没有类实例时你也可以访问它。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Order order = <span class="keyword">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充说明：全局变量：static final</p>
<ul>
<li>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</li>
</ul>
</blockquote>
<h4 id="5，运行时常量池"><a href="#5，运行时常量池" class="headerlink" title="5，运行时常量池"></a>5，运行时常量池</h4><p><img src="/2021/04/05/jvm/36.png" alt="image-20210416020315727"></p>
<p><strong>运行时常量池 VS 常量池</strong></p>
<blockquote>
<ul>
<li>方法区，内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池</li>
<li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池</li>
</ul>
</blockquote>
<p><strong>常量池</strong>：</p>
<blockquote>
<p><img src="/2021/04/05/jvm/37.png" alt="image-20210416021043683"></p>
<ul>
<li>一个有效的字节码文件中除了包含类的版本信息，字段，方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型，域和方法的<strong>符号引用</strong>。</li>
</ul>
</blockquote>
<p><strong>为什么需要常量池？</strong></p>
<blockquote>
<p>一个Java源文件中的类，接口，编译后产生一个字节码文件，而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池。</p>
<p>比如如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里代码量其实已经很小了，如果代码多，引用到的结构会更多！这里就需要常量池了！</p>
<p>几种在常量池内存储的数据类型包括：</p>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<p>例如下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object foo = new Object();</p>
<p>将会被编译成如下字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0：new #2				 &#x2F;&#x2F;Class java&#x2F;lang&#x2F;Object</span><br><span class="line">1：dup			</span><br><span class="line">2：invokespecial #3   	 &#x2F;&#x2F;Method java&#x2F;lang&#x2F;Object &quot;&lt;init&gt;&quot;() V</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong>：</p>
<ul>
<li>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等类型。</li>
</ul>
</blockquote>
<p><strong>运行时常量池</strong>：</p>
<blockquote>
<ul>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分</li>
<li>常量池表（Constant Pool Table）是Class文件的一部分<strong>，用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法去的运行时常量池中。</strong></li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li>JVM为每个已加载的类型（类或接口）都维护一个常量池，池中的数据项像数组项一样，是通过索引访问的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用，此时不再是常量池中的符号地址了，这里换为真实地址<ul>
<li>运行时常量池，相对于Class文件常量池的另一重要特征：<strong>具备动态性</strong></li>
</ul>
</li>
<li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛出OutOfMemoryErrory异常。</li>
</ul>
</blockquote>
<h4 id="6，方法区的演进细节"><a href="#6，方法区的演进细节" class="headerlink" title="6，方法区的演进细节"></a>6，方法区的演进细节</h4><blockquote>
<ul>
<li><p>首先明确：只有Hotspot才有永久代。BEA JRockit 、IBM J9等来说，是不存在永久代的概念的，原则上是如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p>
</li>
<li><p>Hotspot中方法区的变化：</p>
<ul>
<li><p>JDK 1.6及之前：<strong>有永久代（permanentgeneration），静态变量存放在永久代上</strong></p>
</li>
<li><p>JDK 1.7：<strong>有永久代，但已经逐步“去永久代”，字符常量池，静态变量移除，保存在堆中</strong></p>
</li>
<li><p>JDK 1.8及之后：<strong>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池，静态变量仍在堆</strong></p>
<p><img src="/2021/04/05/jvm/38.png" alt="image-20210416023834320"></p>
<p><img src="/2021/04/05/jvm/39.png" alt="image-20210416023903980"></p>
<p><img src="/2021/04/05/jvm/40.png" alt="image-20210416023929495"></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>永久代为什么要被元空间替换？</strong></p>
<blockquote>
<ul>
<li>随着Java8的到来，Hotspot VM中再也见不到永久代了，但是这并不意味着类的元数据信息也消失了，这些数据被移到了一个<strong>与堆不相连的本地内存区域，这个区域叫做元空间（Metespace）</strong></li>
<li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间</li>
<li>这项改动是很有必要的，原因有；<ul>
<li><strong>为永久代设置空间大小是很难确定的</strong>。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Weg工程中，因为功能点比较多，在运行程序中，要不断动态加载很多类，经常出现致命错误：<code>java.lang.OutOfMemoryError：PermGenspace</code>，而<strong>元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制</strong></li>
<li><strong>对永久代进行调优是很困难的。</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>StringTable为什么要调整？</strong></p>
<blockquote>
<p>JDK 7中将StringTable放到了堆空间中，因为永久代的回收效率很低，在Full GC的时候才会触发。而Full GC是老年代的空间不足，永久代不足时才会触发。这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建。回收效率低，导致永久代内存不足。放到堆中，能及时回收内存。</p>
</blockquote>
<p><strong>静态变量存放在哪里？</strong></p>
<blockquote>
<p>静态变量的引用实体始终都存在堆空间中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment">*staticObh，instanceObj,localObj存放在哪里？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObjTest</span></span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">     <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">     ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">         ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">         System.out.println(<span class="string">"done"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> class <span class="title">ObjectHolder</span><span class="params">()</span></span>&#123;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">     Test test = <span class="keyword">new</span> StaticObjeTest.Test();</span><br><span class="line">     test.foo();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>staticObj随着Test的类型信息存放在方法区，instanceObj随着Test的对象实例存放在Java堆，localObject则时存放在foo（）方法栈帧的局部变量表中。</p>
<p>测试发现：<strong>三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要时对象实例必然会在Java堆中分配。</strong></p>
<p>接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Clss的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这个确实是一个java.lang.Class类型的对象实例，里面有一个名为staticObj的实例字段。</p>
<p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。<strong>JDK 7极其以后版本的Hotspot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，存储与Java堆之中</strong>，从我们的实验中也明确验证了这一点。</p>
</blockquote>
<h4 id="7，方法区的垃圾回收"><a href="#7，方法区的垃圾回收" class="headerlink" title="7，方法区的垃圾回收"></a>7，方法区的垃圾回收</h4><blockquote>
<p>​    有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）</p>
<p>​    一般来说<strong>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的</strong>，以前Sun公司的Bug列表中，曾出现过的若干个严重的bug就是由于低版本的Hotspot虚拟机对此区域未完全回收而导致内存泄露</p>
<p><strong>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</strong></p>
</blockquote>
<blockquote>
<ul>
<li>方法区内常量池之中主要存放的两大类常量：字面量和符号引用。<ul>
<li>字面量比较接近Java语言层次的常量概念，如文本字符串，被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
</li>
<li>Hotspot虚拟机堆常量池的回收策略是明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收。</strong></li>
<li>回收废弃常量与回收Java堆中的对象非常类似。</li>
<li>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
<li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是<strong>“被允许”</strong>，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息</li>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，<strong>通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</strong></li>
</ul>
</blockquote>
<h4 id="8，总结"><a href="#8，总结" class="headerlink" title="8，总结"></a>8，总结</h4><p><img src="/2021/04/05/jvm/41.png" alt="image-20210416091448825"></p>
<p><strong>常见面试题：</strong></p>
<blockquote>
<p><strong>百度</strong>：</p>
<ul>
<li>三面：说一下JVM内存模型吧，有哪些分区？分别是干什么的？</li>
</ul>
<p><strong>蚂蚁金服</strong>：</p>
<ul>
<li>Java8的内存分代改进</li>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
<li>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区</li>
<li>二面：Eden和Survivor的比例分配</li>
</ul>
<p><strong>小米</strong>：</p>
<ul>
<li>JVM内存分区，为什么要有新生代和老年代</li>
</ul>
<p><strong>字节跳动</strong>：</p>
<ul>
<li>二面：Java的内存分区</li>
<li>二面：讲讲jvm运行时数据库区</li>
<li>什么时候对象会进入老年代</li>
</ul>
<p><strong>京东</strong>：</p>
<ul>
<li>JVM的内存结构，Eden和Survivo比例</li>
<li>JVM内存为什么要分成新生代，老年代，持久代。新生代为什么要分为Eden和Survivor</li>
</ul>
<p><strong>天猫</strong>：</p>
<ul>
<li>一面：JVM内存模型以及分区，需要详细到每个区放什么</li>
<li>一面：JVM的内存模型，Java8做了什么修改</li>
</ul>
<p><strong>拼多多</strong></p>
<ul>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
</ul>
<p><strong>美团</strong>：</p>
<ul>
<li>Java内存分配</li>
<li>JVM的永久代中会发生垃圾回收吗？</li>
<li>一面：JVM内存分区，为什么要有新生代和老年代？</li>
</ul>
</blockquote>
<h3 id="九，对象的实例化，内存布局与访问定位"><a href="#九，对象的实例化，内存布局与访问定位" class="headerlink" title="九，对象的实例化，内存布局与访问定位"></a>九，对象的实例化，内存布局与访问定位</h3><h4 id="1，对象的实例化"><a href="#1，对象的实例化" class="headerlink" title="1，对象的实例化"></a>1，对象的实例化</h4><p><img src="/2021/04/05/jvm/42.png" alt="image-20210416165458138"></p>
<p><strong>创建对象的步骤</strong>：</p>
<blockquote>
<ol>
<li><strong>判断对象对应的类是否加载，链接，初始化</strong><ul>
<li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模型下，使用当前类加载器以及ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象。</li>
</ul>
</li>
<li><strong>为对象分配内存</strong>：首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。<ul>
<li>如果内存规整：<ul>
<li>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。</li>
<li>意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial，ParNew这种基于压缩算法的，虚拟机采用这种分配方式，一般使用带有compact（整理）过程的收集器时，使用指针碰撞。</li>
</ul>
</li>
<li>如果内存不规整<ul>
<li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存</li>
<li>意思是虚拟机维护一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表”（Free List）</li>
</ul>
</li>
<li><strong>说明</strong>：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li>
</ul>
</li>
<li>处理并发安全问题：<ul>
<li>采用CAS失败重试，区域加锁保证更新的原子性</li>
<li>每个线程先分配一块TLAB——通过–XX:+/- UseTLAB参数来设定</li>
</ul>
</li>
<li>初始化分配到的空间——所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用<ul>
<li>给对象的属性赋值的操作：<ul>
<li>属性的默认初始化</li>
<li>显式初始化</li>
<li>代码块中初始化</li>
<li>构造器中初始化</li>
</ul>
</li>
</ul>
</li>
<li>设置对象的对象头<ul>
<li>将对象的所属类（即类的元数据信息），对象的HashCode和对象的GC信息，锁信息等数据存储在对象的对象头中，这个过程的具体设置方式取决于JVM实现。</li>
</ul>
</li>
<li>执行init方法进行初始化<ul>
<li>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</li>
<li>因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="2，对象的内存布局"><a href="#2，对象的内存布局" class="headerlink" title="2，对象的内存布局"></a>2，对象的内存布局</h4><p><img src="/2021/04/05/jvm/43.png" alt="image-20210416191141504"></p>
<p><img src="/2021/04/05/jvm/44.png" alt="image-20210416191709256"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">"匿名客户"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> Account();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">CustomerTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Customer cust = <span class="keyword">new</span> Customer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3，对象的访问定位"><a href="#3，对象的访问定位" class="headerlink" title="3，对象的访问定位"></a>3，对象的访问定位</h4><p><img src="/2021/04/05/jvm/45.png" alt="image-20210416192521968"></p>
<p><strong>对象访问方式主要有两种</strong>：</p>
<blockquote>
<ul>
<li>句柄访问<ul>
<li><img src="/2021/04/05/jvm/46.png" alt="image-20210416192641211"></li>
</ul>
</li>
<li>直接指针（HotSpot采用）<ul>
<li><img src="/2021/04/05/jvm/47.png" alt="image-20210416192854678"></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="十，直接内存"><a href="#十，直接内存" class="headerlink" title="十，直接内存"></a>十，直接内存</h3><p><strong>直接内存概述</strong>：</p>
<blockquote>
<ul>
<li><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</p>
</li>
<li><p>直接内存是在Java堆外的，直接向系统申请的内存空间</p>
</li>
<li><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p>
</li>
<li><p>通常，访问直接内存的速度会优于Java堆，即读写性能高</p>
<ul>
<li><img src="/2021/04/05/jvm/48.png" alt="image-20210416201051974"></li>
<li><img src="/2021/04/05/jvm/49.png" alt="image-20210416201130747"></li>
<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li>
</ul>
</li>
<li><table>
<thead>
<tr>
<th align="center">IO</th>
<th align="center">NIO（New IO / Non-Blocking IO</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte[] / char[]</td>
<td align="center">Buffer</td>
</tr>
<tr>
<td align="center">Stream</td>
<td align="center">Channel</td>
</tr>
</tbody></table>
</li>
<li><p>也可能导致OutOfMemoryError异常</p>
</li>
<li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
</li>
<li><p>直接内存大小可用通过MaxDirectMemorySize设置</p>
</li>
<li><p>如果不指定，默认与堆的最大值-Xmx参数值一致</p>
</li>
<li><p><img src="/2021/04/05/jvm/50.png" alt="image-20210416201542439"></p>
</li>
</ul>
</blockquote>
<h3 id="十一，执行引擎"><a href="#十一，执行引擎" class="headerlink" title="十一，执行引擎"></a>十一，执行引擎</h3><p><img src="/2021/04/05/jvm/56.png" alt="image-20210417102652557"></p>
<h4 id="1，执行引擎概述："><a href="#1，执行引擎概述：" class="headerlink" title="1，执行引擎概述："></a>1，执行引擎概述：</h4><p><img src="/2021/04/05/jvm/51.png" alt="image-20210417100457446"></p>
<blockquote>
<ul>
<li>执行引擎是Java虚拟机核心的组成部分之一</li>
<li>“虚拟机”是一个相对于”物理机“的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器，缓存，指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以<strong>不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式</strong></li>
<li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令，符号表，以及其他辅助信息，那么如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li>
<li>从外观来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。</li>
</ul>
</blockquote>
<p><strong>执行引擎的工作过程</strong>：</p>
<p><img src="/2021/04/05/jvm/52.png" alt="image-20210417101326654"></p>
<h4 id="2，Java代码编译和执行过程"><a href="#2，Java代码编译和执行过程" class="headerlink" title="2，Java代码编译和执行过程"></a>2，Java代码编译和执行过程</h4><p><img src="/2021/04/05/jvm/53.png" alt="image-20210417101823229"></p>
<p><img src="/2021/04/05/jvm/54.png" alt="image-20210417102014717"></p>
<p><img src="/2021/04/05/jvm/55.png" alt="image-20210417102043403"></p>
<p><strong>什么是解释器（Interpreter），什么是JIT编译器？</strong></p>
<blockquote>
<ul>
<li>解释器：当Java虚拟机启动时会根据预定义的规范<strong>对字节码采用逐行解释的方式执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行</li>
<li>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</li>
</ul>
</blockquote>
<p><strong>为什么说Java是半编译半解释型语言？</strong></p>
<blockquote>
<ul>
<li>JDK1.0时代，将Java语言定位位“解释执行”还是比较准确的，再后来Java也发展出可以直接本地生成代码的编译器</li>
<li>现在JVM在执行Java代码的时候，通常都会将<strong>解释器执行和编译执行二者结合起来</strong>进行</li>
</ul>
</blockquote>
<h4 id="3，机器码，指令，汇编语言"><a href="#3，机器码，指令，汇编语言" class="headerlink" title="3，机器码，指令，汇编语言"></a>3，机器码，指令，汇编语言</h4><p><strong>机器码</strong>：</p>
<blockquote>
<ul>
<li>各种用二进制编码方式表示的指令，叫做<strong>机器指令码</strong>。开始，人们就用它采编写程序，这就是机器语言。</li>
<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li>
<li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li>
<li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li>
</ul>
</blockquote>
<p><strong>指令</strong>；</p>
<blockquote>
<ul>
<li>由于机器码是有o和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li>
<li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov,inc等），可读性稍好</li>
<li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令(比如mov)，对应的机器码也可能不同。</li>
</ul>
</blockquote>
<p><strong>指令集</strong>；</p>
<blockquote>
<ul>
<li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</li>
<li>如常见的：<ul>
<li>x86指令集，对应的是x86架构的平台</li>
<li>ARM指令集，对应的是ARM架构的平台</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>汇编语言</strong>：</p>
<blockquote>
<ul>
<li>由于指令的可读性还是太差，于是人们又发明了汇编语言</li>
<li>在汇编语言中，用<strong>助记符(Mnemonics）</strong>代替<strong>机器指令的操作码</strong>，用<strong>地址符号(Symbo1)</strong>或<strong>标号(Label)</strong>代替<strong>指令或操作数的地址。</strong></li>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。<ul>
<li>由于计算机只认识指令码，所以用<strong>汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>高级语言</strong>：</p>
<blockquote>
<ul>
<li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言<strong>更接近人的语言</strong></li>
<li>当计算机执行高级语言编写的程序时，<strong>仍然需要把程序解释和编译成机器的指令码。</strong>完成这个过程的程序就叫做解释程序或编译程序。</li>
</ul>
</blockquote>
<p><strong>字节码</strong>：</p>
<blockquote>
<ul>
<li>字节码是一种<strong>中间状态（中间码）的二进制代码（文件）</strong>，它比机器码更抽象，需要直译器转译后才能成为机器码</li>
<li>字节码主要为了实现特定软件运行和软件环境、<strong>与硬件环境无关</strong>。</li>
<li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码,特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<ul>
<li>字节码的典型应用为Java bytecode。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/04/05/jvm/57.png" alt="image-20210417104532494"></p>
<h4 id="4，解释器"><a href="#4，解释器" class="headerlink" title="4，解释器"></a>4，解释器</h4><blockquote>
<p>JVM设计者们的初衷仅仅只是单纯地<strong>为了满足Java程序实现跨平台特性</strong>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时米用逐行解释子下码执行程序的想法。</p>
<p><img src="/2021/04/05/jvm/58.png" alt="image-20210417104716863"></p>
</blockquote>
<p><strong>解释器工作机制（或工作任务）</strong></p>
<blockquote>
<ul>
<li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li>
</ul>
</blockquote>
<p><strong>解释器分类</strong></p>
<blockquote>
<p>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。</p>
<ul>
<li>字节码解释器在执行时通过<strong>纯软件代码</strong>模拟字节码的执行，效率非常低下。</li>
<li>而模板解释器将<strong>每一条字节码和一个模板函数相关联</strong>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。<ul>
<li>在HotSpot VM中，解释器主要由Interpreter模块和code模块构成。<ul>
<li>Interpreter模块:实现了解释器的核心功能</li>
<li>Code模块:用于管理HotSpot VM在运行时生成的本地机器指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>解释器现状</strong>：</p>
<blockquote>
<ul>
<li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，<strong>基于解释器执行已经沦落为低效的代名词</strong>，并且时常被一些C/C++程序员所调侃。</li>
<li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是<strong>将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可</strong>，这种方式可以使执行效率大幅度提升。</li>
<li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li>
</ul>
</blockquote>
<h4 id="5，JIT编译器"><a href="#5，JIT编译器" class="headerlink" title="5，JIT编译器"></a>5，JIT编译器</h4><p><strong>Java代码执行分类</strong>：</p>
<blockquote>
<ul>
<li>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</li>
<li>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</li>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用<strong>解释器与即时编译器并存的架构</strong>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</li>
</ul>
</blockquote>
<p><strong>问题：有些开发人员会感觉到诧异，==既然Hotspot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢?==比如JRockit VM内部就不包含解释器,字节码全部都依靠即时编译器编译后执行。</strong></p>
<blockquote>
<p>首先明确:</p>
<p>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>所以：</p>
<p>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<strong>当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</strong></p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
</blockquote>
<p><strong>HotSpot JVM的执行方式</strong>：</p>
<blockquote>
<p>当虚拟机启动的时候，<strong>解释器可以首先发挥作用</strong>，而不必等待即时编译器全部编译完成再执行，这样可以<strong>省去许多不必要的编译时间</strong>。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据<strong>热点探测</strong>功能，<strong>将有价值的字节码编译为本地机器指令</strong>，以换取更高的程序执行效率。</p>
</blockquote>
<p><strong>说明解释器与编译器并存重要性的案例</strong>：</p>
<blockquote>
<p>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态可以承受的负载要大于冷机状态</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。<br>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例:某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在的重要性。        ——阿里团队</p>
</blockquote>
<p><strong>JIT编译器</strong>：</p>
<blockquote>
<ul>
<li>Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译期（其实叫“编译期的前端”更准确一些）把.java文件转变成.class文件的过程</li>
<li>也可能是指虚拟机的<strong>后端运行期编译器</strong>（JIT编译器）把字节码转变成机器码的过程</li>
<li>还可能是指使用<strong>静态提前编译器</strong>（AOT编译器）直接把.java文件编译成本地机器代码的过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前端编译器：Sun的javac，Eclipse JDT中的增量式编译器（ECJ）</span><br><span class="line">JIT编译器：Hotspot VM的c1,c2编译器</span><br><span class="line">AOT编译器：GNU Compiler for the Java(GCJ)，Excelsior JET</span><br></pre></td></tr></table></figure>
</blockquote>
<p>热点代码及探测方式</p>
<blockquote>
<ul>
<li><p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令,则需要根据代码被调用<strong>执行的频率</strong>而定。关于那些需要被编译为本地代码的字节码，也被称之为“<strong>热点代码</strong>”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p>
</li>
<li><p><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On Stack Replacement）编译。</p>
</li>
<li><p>一个方法究竟要<strong>被调用多少次</strong>，或者一个循环体究竟需要执行多少次循环才可以达到这个标准?必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<strong>热点探测功能。</strong></p>
</li>
<li><p>目前HotSpot VM所采用的<strong>热点探测方式</strong>是<strong>基于计数器的热点探测</strong>。</p>
</li>
<li><p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为<strong>方法调用计数器(Invocation Counter）</strong>和<strong>回边计数器(Back Edge Counter）</strong>。</p>
<ul>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>方法调用计数器</strong>：</p>
<blockquote>
<ul>
<li>这个计数器就用于统计方法被调用的次数，它的默认阈值<strong>在 client模式下是1500 次</strong>，<strong>在 Server模式下是10000次</strong>。超过这个阈值，就会触发JIT编译。</li>
<li>这个阈值可以通过虚拟机参数<code>-XX:CompileThreshold</code>来人为设定。</li>
<li>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断<strong>方法调用计数器与回边计数器值之和</strong>是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li>
<li><img src="/2021/04/05/jvm/59.png" alt="image-20210417131805476"></li>
</ul>
</blockquote>
<p><strong>热度衰减</strong>：</p>
<blockquote>
<ul>
<li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过<strong>一定的时间限度</strong>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被<strong>减少一半</strong>，这个过程称为<strong>方法调用计数器热度的衰减(Counter Decay)</strong>，而这段时间就称为此<strong>方法统计的半衰周期(Counter Half Life Time)。</strong></li>
<li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<strong>-XX:-UseCounterDecay</strong>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li>
<li>另外，可以使用<strong>-XX:CounterHalfLifeTime</strong>参数设置半衰周期的时间，单位是秒。</li>
</ul>
</blockquote>
<p><strong>回边计数器</strong>：</p>
<blockquote>
<p>它的作用是<strong>统计一个方法中循环体代码执行的次数</strong>，在字节码中遇到控制流向后跳转的指令称为“回边”(Back Edge）。显然，建立回边计数器统计的目的就是为了触发 OSR编译。</p>
<p><img src="/2021/04/05/jvm/60.png" alt="image-20210417132221582"></p>
</blockquote>
<p><strong>HotSpot VM可以设置程序执行方式</strong>：</p>
<blockquote>
<p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是<strong>完全采用解释器执行</strong>，还是<strong>完全采用即时编译器执行</strong>。如下所示:</p>
<ul>
<li><strong>-Xint</strong>：完全采用解释器模式执行程序</li>
<li><strong>-Xcomp</strong>：完全采用即使编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>
<li><strong>-Xmixed</strong>：采用解释器+即时编译器的混合模式共同执行程序</li>
</ul>
</blockquote>
<p><strong>HotSpot VM中JIT分类</strong>：</p>
<blockquote>
<p>在HotSpot VM中内嵌有两个JIT编译器，分别为client Compiler和server Compiler，但大多数情况下我们简称为c1编译器和c2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示:</p>
<ul>
<li><strong>-client</strong>：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul>
<li>C1编译器会对字节码进行<strong>简单和可靠的优化，耗时短</strong>。以达到更快的编译速度</li>
</ul>
</li>
<li><strong>-server</strong>：指定Java虚拟机运行在Server模式下，并使用C2编译器。<ul>
<li>C2进行<strong>耗时较长的优化，以及激进优化。</strong>但优化的代码执行效率更高。</li>
</ul>
</li>
<li><strong>C1和C2编译器不同的优化策略</strong>：<ul>
<li>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化，冗余消除：<ul>
<li><strong>方法内联</strong>：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li><strong>去虚拟化</strong>：对唯一的实现类进行内联</li>
<li><strong>冗余消除</strong>：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
</li>
<li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul>
<li><strong>标量替换</strong>：用标量值代替聚合对象的属性值</li>
<li><strong>栈上分配</strong>：对于未逃逸的对象分配对象在栈而不是堆</li>
<li><strong>同步消除</strong>：清除同步操作，通常指synchronized。</li>
</ul>
</li>
</ul>
</li>
<li><strong>分层编译(Tiered compilation）策略</strong>:程序解释执行（不开启性能监控）可以触发c1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</li>
<li>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由cl编译器和c2编译器相互协作共同来执行编译任务。</li>
</ul>
</blockquote>
<p><strong>关于Graal编译器</strong></p>
<blockquote>
<ul>
<li>自JDK10起，HotSpot又加入一个全新的即时编译器: Graal编译器。编译效果短短几年时间就追评了cα编译器。未来可期。</li>
<li>目前，带着“实验状态”标签，需要使用开关参数</li>
<li><strong>-XX :+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</strong>去激活，才可以使用。</li>
</ul>
</blockquote>
<p><strong>关于AOT编译器</strong>：</p>
<blockquote>
<ul>
<li>jdk9引入了AoT编译器(静态提前编译器，Ahead of Time Compiler)</li>
<li>Java 9 引入了实验性AOT编译工具jaotc。它借助了Graal 编译器，将所输入的 Java类文件转换为机器码，并存放至生成的动态共享库之中。</li>
<li>所谓AOT 编译，是与即时编译相对立的一个概念。我们知道，<strong>即时编译指的是在程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而<strong>AOT 编译指的则是，在程序运行之前</strong>，便将字节码转换为机器码的过程。</li>
<li>.java ——》.class ——》.so</li>
<li>最大好处:Java虚拟机加载已经预编译成二进制库，可以直接执行。不必待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的丕良体验。</li>
<li>缺点：<ul>
<li>破坏了java”一次编译，到处运行”，必须为每个不同硬件、os编译对应的发行包。</li>
<li>降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知</li>
<li>还需要继续优化中，最初只支持Linux x64 java base</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="十二，StringTable"><a href="#十二，StringTable" class="headerlink" title="十二，StringTable"></a>十二，StringTable</h3><h4 id="1，String的基本特性"><a href="#1，String的基本特性" class="headerlink" title="1，String的基本特性"></a>1，String的基本特性</h4><blockquote>
<ul>
<li>String：字符串，使用一对“”引起来表示<ul>
<li>String s1 = “aaa”;   //字面量的定义方式</li>
<li>String s2 = new String（“hello”）;</li>
</ul>
</li>
<li>String声明为final的，不可被继承</li>
<li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</li>
<li><strong>String在JDK8及以前内部定义了final char[] value用于存储字符串数据。jdk9时改为byte[]</strong></li>
<li>string:代表不可变的字符序列。简称:不可变性。<ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</li>
<li>当调用String的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
</ul>
</li>
<li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中</li>
<li><strong>字符串常量池中是不会存储相同内容的字符串的</strong><ul>
<li>String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降</li>
<li>使用<strong>-XX:StringTableSize</strong>可设置StringTable的长度</li>
<li>在jdk6中StringTable是固定的，就是<strong>1009</strong>的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设置没有</li>
<li>在jdk7中，StringTable的长度<strong>默认值是60013</strong></li>
<li>在jdk8开始，设置StringTable的长度的话，<strong>1009是可设置的最小值</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">"abc"</span>;  	<span class="comment">//字面量定义的方式,"abc"存储在字符串常量池中</span></span><br><span class="line">    String s2 = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(s1 == s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">'abc'</span>;</span><br><span class="line">    String s2 = <span class="string">"abc"</span>;</span><br><span class="line">    s2 += <span class="string">"def"</span>;</span><br><span class="line">    System.out.println(s2)<span class="comment">//abcdef   目前字符串常量池存放着"abc","def","abcdef"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">"abc"</span>;</span><br><span class="line">    String s2 = s1.replace(<span class="string">'a'</span>,<span class="string">'m'</span>);</span><br><span class="line">    System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">    System.out.println(s2);<span class="comment">//mbc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer</span></span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">"good"</span>);</span><br><span class="line">    <span class="keyword">char</span>[] ch = &#123;<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str,<span class="keyword">char</span> ch[])</span></span>&#123;</span><br><span class="line">        str = <span class="string">"test ok"</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StringExer ex = <span class="keyword">new</span> StringExer();</span><br><span class="line">        ex.change(ex.str,ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best    目前字符串中只有"good","test ok"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2，String的内存分配"><a href="#2，String的内存分配" class="headerlink" title="2，String的内存分配"></a>2，String的内存分配</h4><blockquote>
<ul>
<li>在Java语言中有8种基本数据类型和一种比较特殊的类型string。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</li>
<li>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，<strong>String类型的常量池比较特殊。它的主要使用方法有两种。</strong><ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中。<ul>
<li>比如：String info = “aaa”;</li>
</ul>
</li>
<li>如果不是用双引号声明的String对象，可以使用String提供的intern()方法</li>
</ul>
</li>
<li>Java 6及以前，字符串常量池存放在永久代</li>
<li>Java 7 中Oracle的工程师对字符串池的逻辑做了很大的改变，即<strong>将字符串常量池的位置调整到Java内</strong><ul>
<li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了</li>
<li>字符串常量池 概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java7中使用String.intern()</li>
</ul>
</li>
<li>Java8元空间，字符串常量在堆</li>
<li>StringTable为什么要调整？<ul>
<li>permSize默认比较小</li>
<li>永久代垃圾回收频率低</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3，String的基本操作"><a href="#3，String的基本操作" class="headerlink" title="3，String的基本操作"></a>3，String的基本操作</h4><p><img src="/2021/04/05/jvm/61.png" alt="image-20210419003735991"></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;<span class="comment">//line 1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();<span class="comment">// line 3</span></span><br><span class="line">        Memory men = <span class="keyword">new</span> Memory();<span class="comment">// line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">// line 5</span></span><br><span class="line">    &#125;<span class="comment">// line 9</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span></span>&#123;<span class="comment">//line 6</span></span><br><span class="line">        String str = param.toString();<span class="comment">// line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/05/jvm/62.png" alt="image-20210419004112731"></p>
</blockquote>
<h4 id="4，字符串拼接操作"><a href="#4，字符串拼接操作" class="headerlink" title="4，字符串拼接操作"></a>4，字符串拼接操作</h4><blockquote>
<ul>
<li>常量与常量的拼接结果在常量池，原理是编译器优化</li>
<li>常量池中不会存在相同内容的常量</li>
<li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li>
<li>如果拼接的结构调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>;<span class="comment">//等同于"abc"</span></span><br><span class="line">    String s2 = <span class="string">"abc"</span>;  <span class="comment">//"abc"一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 最终.java编译成.class，再执行.class</span></span><br><span class="line"><span class="comment">    * String s1 = "abc";</span></span><br><span class="line"><span class="comment">    * String s2 = "abc";  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s1.equals(s2));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">"javaEE"</span>;</span><br><span class="line">    String s2 = <span class="string">"hadoop"</span>;</span><br><span class="line">    String s3 = <span class="string">"javaEEhadoop"</span>;</span><br><span class="line">    String s4 = <span class="string">"javaEE"</span> + <span class="string">"hadoop"</span>;<span class="comment">//编译期优化</span></span><br><span class="line">    <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String(),具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">    String s6 = s1 + <span class="string">"hadoop"</span>;</span><br><span class="line">    String s7 = s1 + s2;</span><br><span class="line">    </span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	intern():判断字符串常量池是否存在javaEEhadoop值</span></span><br><span class="line"><span class="comment">    * 				- 如果存在,则返回常量池中javaEEhadoop的地址;</span></span><br><span class="line"><span class="comment">    *				- 如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份	</span></span><br><span class="line"><span class="comment">    					javaEEhadoop，并返回次对象的地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String s8 = s6.intern();</span><br><span class="line">    System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">"a"</span>;</span><br><span class="line">    String s2 = <span class="string">"b"</span>;</span><br><span class="line">    String s3 = <span class="string">"ab"</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 如下的s1 + s2 的执行细节：</span></span><br><span class="line"><span class="comment">    * StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">    * 1, s.append("a");</span></span><br><span class="line"><span class="comment">    * 2, s.append("b");</span></span><br><span class="line"><span class="comment">    * 3, s.toString() ——》 约等于new String("ab")</span></span><br><span class="line"><span class="comment">    * 补充：在jdk5.0之后使用的是StringBuilder，在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String s4 = s1 + s2;<span class="comment">//</span></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1, 字符串拼接操作不一定使用的是StringBuilder！！！</span></span><br><span class="line"><span class="comment">* 	 如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder方式</span></span><br><span class="line"><span class="comment">* 2, 对于final修饰类，方法，基本数据类型，引用数据类型的量的结构时，能使用上final的时候建议用上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String s1 = <span class="string">"a"</span>;</span><br><span class="line">    <span class="keyword">final</span> String s2 = <span class="string">"b"</span>;</span><br><span class="line">    String s3 = <span class="string">"ab"</span>;</span><br><span class="line">    String s4 = s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">"javaEEhadoop"</span>;</span><br><span class="line">    String s2 = <span class="string">"javaEE"</span>;</span><br><span class="line">    String s3 = s2 + <span class="string">"hadoop"</span>;</span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">    <span class="keyword">final</span> String s4 = <span class="string">"javaEE"</span>; <span class="comment">//s4:常量</span></span><br><span class="line">    String s5 = s4 + <span class="string">"hadoop"</span>;</span><br><span class="line">    System.out.println(s1 == s5); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 体会执行效率: 通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</span></span><br><span class="line"><span class="comment">* 详情：① StringBuilder的append方式：自始至终只创建一个StringBuilder的对象</span></span><br><span class="line"><span class="comment">*		 使用String的字符串拼接方式：创建过多个StringBuilder和String的对象</span></span><br><span class="line"><span class="comment">*	   ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存*		占用更大；如果进行GC，需要花费额外的时间。</span></span><br><span class="line"><span class="comment">* 改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情</span></span><br><span class="line"><span class="comment">*				况下建议使用构造器实例化</span></span><br><span class="line"><span class="comment">*		StringBuilder s = new StringBuilder(highLever);//new char[highlever]  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//method1(100000);  //4014</span></span><br><span class="line">    method2(<span class="number">100000</span>);   <span class="comment">//7</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMills();</span><br><span class="line">    System.out.println(<span class="string">"花费的时间为"</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span></span>&#123;</span><br><span class="line">    String src = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; highLevel; i++)&#123;</span><br><span class="line">        src = src + <span class="string">"a"</span>; <span class="comment">//每次循环都会创建一个StringBuilder,String</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(src);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span></span>&#123;</span><br><span class="line">    StringBuilder src = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; highLevel; i++)&#123;</span><br><span class="line">        src.append(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="5，intern-的使用"><a href="#5，intern-的使用" class="headerlink" title="5，intern()的使用"></a>5，intern()的使用</h4><blockquote>
<ul>
<li><p>如果不是用双引号声明的string对象，可以使用String提供的intern方法: intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p>
<ul>
<li>比如：String myInfo = new String(“hello world”).intern();</li>
</ul>
</li>
<li><p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true:</p>
<ul>
<li>(“a”+”b”+”c”).intern() == “abc”</li>
</ul>
</li>
<li><p>通俗来讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p>
</li>
<li><p>如何保证变量s指向的是字符串常量池中的数据呢？有两种方式：</p>
<ul>
<li>方式一：String s = “shkstart”; // 字面量定义的方式</li>
<li>方式二：调用intern()<ul>
<li>String s = new String(“shkstart”).intern();</li>
<li>String s = new StringBuilder(“shkstart”).toString.intern;</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>new String(“ab”)会创建几个对象？</strong></p>
<ul>
<li>一个对象是：new关键字在堆空间创建的</li>
<li>另一个对象是：字符串常量池中的对象</li>
</ul>
</li>
<li><p><strong>new String(“a”) + new String(“b”)会创建几个对象呢？</strong></p>
<ul>
<li>对象1：new StirngBuilder()</li>
<li>对象2：new String(“a”)</li>
<li>对象3：常量池中的“a”</li>
<li>对象4：new String(“b”)</li>
<li>对象5：常量池中的“b”</li>
<li>深入剖析：StringBuilder的toString()：<ul>
<li>对象6；new String(“ab”)</li>
<li>强调一下，toString()的调用，在字符串常量池中，没有生成“ab”，因为toString中new String传入的是字符数组</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​                </p>
</blockquote>
<p><strong>intern()的使用：jdk6 VS jdk 7/8</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">        s.intern();<span class="comment">//调用此方法之前那，字符串常量池中已经存在了"1"</span></span><br><span class="line">        String s2 = <span class="string">"1"</span>;</span><br><span class="line">        System.out.println(s == s2);	<span class="comment">//jdk6：false	jdk7/8：false</span></span><br><span class="line">        </span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">//由于为拼接字符串，s3变量记录的地址为为StringBuilder拼接后toString调用的new String("11")在堆空间中创建的对象的地址，所以执行完上一行代码后,字符串常量池中没有存在“11”</span></span><br><span class="line">        s3.intern();<span class="comment">//在字符串常量中生成“11”,但是由于堆空间中已经存在“11”字符串，所以字符串常量池中存放了指向堆空间的“11”的引用地址</span></span><br><span class="line">        String s4 = <span class="string">"11"</span>;<span class="comment">//s4变量指向的是字符串常量池中指向堆空间中“11”的引用地址，所以s3和s4所指向的都是堆空间中“11”的地址，所以返回true</span></span><br><span class="line">        <span class="comment">//而对于jdk6，则直接在字符串常量池中创建了新的“11”对象，所以s4指向了新的地址，所以返回了false</span></span><br><span class="line">        System.out.println(s3 == s4);	<span class="comment">//jdk6：false	jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/05/jvm/63.png" alt="image-20210419015151333"></p>
<p><img src="/2021/04/05/jvm/64.png" alt="image-20210419015224492"></p>
</blockquote>
<p><strong>总结String的intern（）的使用：</strong></p>
<blockquote>
<ul>
<li>jdk1.6中，将这个字符串对象尝试放入字符串常量池<ul>
<li>如果字符串常量池中有，则并不会放入。返回已有的字符串常量池中的对象的地址</li>
<li>如果没有，会把<strong>此对象复制一份</strong>，放入字符串常量池，并返回字符串常量池中的对象地址</li>
</ul>
</li>
<li>JDK1.7起，将这个字符串对象尝试放入字符串常量池<ul>
<li>如果字符串常量池中有，并不会放入。返回已有的字符串常量池中的对象的地址</li>
<li>如果没有，则会把<strong>对象的引用地址复制一份</strong>，放入字符串常量池，并返回字符串常量池中的引用地址</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>intern()的效率测试：空间效率</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用intern()测试执行效率：空间使用上：</span></span><br><span class="line"><span class="comment">//结论：对于程序中大量存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = <span class="number">1000</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> String[MAX_COUNT];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] data = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>:i &lt; MAX_COUNT;i++)&#123;</span><br><span class="line">            <span class="comment">//arr[i] = new String(String.valueOf(data[i%data.length)]));</span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i%data.length])).intern();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"花费的时间为"</span>+(end - start));</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市，海定区等信息，这时候如果字符串都调用intern()方法，就会冥想降低内存的大小。</li>
</ul>
</blockquote>
<h4 id="6，G1中的String去重操作"><a href="#6，G1中的String去重操作" class="headerlink" title="6，G1中的String去重操作"></a>6，G1中的String去重操作</h4><blockquote>
<ul>
<li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul>
<li>堆存活数据集合里面String对象占了25%</li>
<li>堆存活数据集合里面重复的String对象有13.5%</li>
<li>String对象的平均长度是45</li>
</ul>
</li>
<li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<strong>Java堆中存活的数据集合差不多25%是String对象</strong>，更进一步，这里面差不多一半String对象是重复的，重复的意思是说：String1.equals(string2)==true。<strong>堆上存在重复的String对象必然是一种内存的浪费</strong>。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li>
<li><strong>实现</strong>：<ol>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。<strong>对每一个访问的对象都会检查是否是候选的要去重的string对象。</strong></li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。</li>
<li>使用一个hashtable来记录所有的被string对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，string对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li>
</ol>
</li>
<li><strong>命令行相关参数</strong>：<ul>
<li>UseStringDeduplication(bool)：开启String去重，<strong>默认是不开启的，需要手动开启</strong></li>
<li>PrintStringDeduplicationStatisticd(bool)：打印详细的去重统计信息</li>
<li>StringDeduplicationAgeThreshold(uintx)：达到这个年龄的String对象被认为是去重的候选对象</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="十三，垃圾回收概念"><a href="#十三，垃圾回收概念" class="headerlink" title="十三，垃圾回收概念"></a>十三，垃圾回收概念</h3><h4 id="1，什么是垃圾"><a href="#1，什么是垃圾" class="headerlink" title="1，什么是垃圾"></a>1，什么是垃圾</h4><blockquote>
<ul>
<li>垃圾收集，不是Java语言的伴生产物，早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生</li>
<li>关于垃圾收集有三个经典问题：<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
</li>
<li>垃圾收集机制是Java的招牌能力，<strong>极大地提高了开发效率</strong>。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备，不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是<strong>面试的热点</strong></li>
</ul>
</blockquote>
<p><strong>大厂面试题</strong>：</p>
<blockquote>
<p><strong>蚂蚁金服</strong>：</p>
<ul>
<li>你知道哪几个垃圾回收器，各自的优缺点，重点讲一下CMS和G1</li>
<li>一面：JVM GC算法有哪些，目前的JDK版本采用什么回收算法</li>
<li>一面：G1回收器讲下回收过程，GC是什么？为什么要有GC？</li>
<li>一面：GC的两种判定方法？CMS收集器与G1收集器的特点</li>
</ul>
<p><strong>百度</strong>：</p>
<ul>
<li>说一下GC算法，分代回收说下</li>
<li>垃圾收集策略和算法</li>
</ul>
<p><strong>天猫</strong>：</p>
<ul>
<li>一面：JVM GC原理，JVM怎么回收内存</li>
<li>一面：CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
</ul>
<p><strong>滴滴</strong>：</p>
<ul>
<li>一面：Java的垃圾回收器有哪些，说下G1的应用场景，平时你是怎如何搭配使用垃圾回收器的</li>
</ul>
<p><strong>京东</strong></p>
<ul>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。垃圾回收算法的实现原理。</li>
</ul>
<p><strong>阿里</strong>：</p>
<ul>
<li>讲一讲垃圾回收算法</li>
<li>什么情况下触发垃圾回收</li>
<li>如何选择合适的垃圾收集算法</li>
<li>JVM有哪三种垃圾回收器</li>
</ul>
<p><strong>字节跳动</strong>：</p>
<ul>
<li>常见的垃圾回收器算法有哪些，各有什么优劣</li>
<li>system.gc()和runtime.gc()会做什么事情</li>
<li>一面：Java GC机制？GC Roots有哪些</li>
<li>二面：Java对象的回收方式，回收算法</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的问题</li>
<li>CMS回收停顿几次，为什么要停顿两次</li>
</ul>
</blockquote>
<p><strong>什么是垃圾？</strong></p>
<blockquote>
<p>什么是垃圾（Garbage）呢？</p>
<ul>
<li>垃圾是指在<strong>运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾</li>
<li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占有的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象所使用，甚至可能<strong>导致内存溢出</strong></li>
</ul>
</blockquote>
<h4 id="2，为什么需要GC"><a href="#2，为什么需要GC" class="headerlink" title="2，为什么需要GC"></a>2，为什么需要GC</h4><blockquote>
<ul>
<li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>,因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫—样。</li>
<li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便<strong>JVM将整理出的内存分配给新的对象</strong>。</li>
<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
</ul>
</blockquote>
<h4 id="3，早期垃圾回收"><a href="#3，早期垃圾回收" class="headerlink" title="3，早期垃圾回收"></a>3，早期垃圾回收</h4><blockquote>
<ul>
<li><p>在早期C/C++时代，垃圾回收基本上是手工进行的，开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放，比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span>(pBridge-&gt;Register(kDestroy) != NO_ERROR)</span><br><span class="line">    <span class="keyword">delete</span> pBridge;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p>
</li>
<li><p>在有了垃圾回收机制后，上述代码块极有可能变成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line">pBridge-&gt;Register(kDestroy);</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。</p>
</li>
</ul>
</blockquote>
<h4 id="4，Java垃圾回收机制"><a href="#4，Java垃圾回收机制" class="headerlink" title="4，Java垃圾回收机制"></a>4，Java垃圾回收机制</h4><blockquote>
<ul>
<li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样<strong>降低内存泄露和内存溢出的风险</strong><ul>
<li>没有垃圾回收器，Java也会想cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已</li>
</ul>
</li>
<li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更<strong>专心地专注于业务开发</strong></li>
<li>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收<ul>
<li>其中，<strong>Java堆是垃圾收集器的工作重点</strong></li>
</ul>
</li>
<li>从次数上讲：<ul>
<li><strong>频繁收集Young区</strong></li>
<li><strong>较少收集Old区</strong></li>
<li><strong>基本不动Perm区（元空间）</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>对垃圾回收机制出现的担忧</strong></p>
<blockquote>
<ul>
<li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</strong></li>
<li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li>
<li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li>
</ul>
</blockquote>
<h3 id="十四，垃圾回收相关算法"><a href="#十四，垃圾回收相关算法" class="headerlink" title="十四，垃圾回收相关算法"></a>十四，垃圾回收相关算法</h3><h4 id="1，标记阶段：引用计数算法"><a href="#1，标记阶段：引用计数算法" class="headerlink" title="1，标记阶段：引用计数算法"></a>1，标记阶段：引用计数算法</h4><p><strong>标记阶段：判断对象存活</strong></p>
<blockquote>
<ul>
<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，<strong>首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被标记为经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢?简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li>
<li>判断对象存活一般有两种方式:<strong>引用计数算法和可达性分析算法。</strong></li>
</ul>
</blockquote>
<p><strong>标记算法：引用计数算法</strong>：</p>
<blockquote>
<ul>
<li><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<strong>引用计数器属性，用于记录对象被引用的情况</strong></p>
</li>
<li><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就会加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
</li>
<li><p>优点：<strong>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性</strong></p>
</li>
<li><p>缺点；</p>
<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong></li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong></li>
<li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况，这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法</li>
</ul>
<p><img src="/2021/04/05/jvm/65.png" alt="image-20210421012229827"></p>
</li>
</ul>
</blockquote>
<p><strong>小结</strong>：</p>
<blockquote>
<ul>
<li>引用计数算，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾回收机制</li>
<li>具体哪种最优是要看场景的，业界有大规模实践汇总仅保留引用计数机制，以提高吞吐量的尝试</li>
<li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系</li>
<li>Python如何解决循环引用？<ul>
<li>手动解除：很好理解，就是在合适的时机，解除引用关系</li>
<li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="2，标记阶段：可达性分析算法"><a href="#2，标记阶段：可达性分析算法" class="headerlink" title="2，标记阶段：可达性分析算法"></a>2，标记阶段：可达性分析算法</h4><p><strong>标记阶段：可达性分析（或根搜索算法，追踪性垃圾收集）</strong></p>
<blockquote>
<ul>
<li><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以<strong>有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</strong></p>
</li>
<li><p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</p>
</li>
<li><p>所谓“GC Roots”根集合就是一组必须活跃的引用</p>
</li>
<li><p>基本思路：</p>
<ul>
<li>可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong></li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链（Reference Chain）</strong></li>
<li>如果目标对象没有任何引用链相连，则是不可达，就意味着该对象已经死亡，可以标记为垃圾对象</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象</li>
</ul>
<p><img src="/2021/04/05/jvm/66.png" alt="image-20210421013345227"></p>
</li>
<li><p>相对于引用计数算反而言，可达性分析算不仅同样具有实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中==循环引用==的问题，防止内存泄露的发生</strong></p>
</li>
<li><p>相较于引用计数算法，这里的可达性分析就是Java，C#选择的，这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p>
</li>
</ul>
</blockquote>
<p><strong>GC Roots包含以下几类元素</strong>：</p>
<blockquote>
<ul>
<li>虚拟机栈中引用对象<ul>
<li>比如：各个线程被调用的方法中使用到的参数，局部变量等</li>
</ul>
</li>
<li>本地方法栈内JNI（通常说的是本地方法）引用的对象</li>
<li>方法区中类静态属性引用的对象<ul>
<li>比如：Java类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中常量引用的对象<ul>
<li>比如：字符串常量池（String Table）里的引用</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException，OutOfMemoryError）,系统类加载器</li>
</ul>
</li>
<li>反映Java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等</li>
<li>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合，比如：分代收集和局部回收（Partial GC）<ul>
<li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性</li>
</ul>
</li>
<li><strong>小技巧</strong>：<ul>
<li>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那他就是一个Root</li>
</ul>
</li>
<li><strong>注意</strong>：<ul>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行，这点不满足的话分析结果的准确性就无法保证。</li>
<li>这点也是导致GC进行时必须“Stop The World”的一个重要原因。<ul>
<li>即使是号称几乎不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/05/jvm/C:%5CUsers%5C92540%5CDesktop%5CmyselfBlog%5Chexo%5Csource_posts%5Cjvm%5C67.png" alt="image-20210421014139228"></p>
</blockquote>
<h4 id="3，对象的finalization机制"><a href="#3，对象的finalization机制" class="headerlink" title="3，对象的finalization机制"></a>3，对象的finalization机制</h4><blockquote>
<ul>
<li>Java语言提供了对象终止（finalization）机制来允许开发人员提供 <strong>对象被销毁之前的自定义处理逻辑</strong></li>
<li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法</li>
<li>finalize（）方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作。比如关闭文件，套接字和数据库连接等</li>
<li>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：<ul>
<li>在finalize()时可能会导致对象复活</li>
<li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会</li>
<li>一个糟糕的finalize()会严重影响GC的性能</li>
</ul>
</li>
<li>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数</li>
<li>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong></li>
</ul>
</blockquote>
<p><strong>生存还是死亡</strong>？</p>
<blockquote>
<ul>
<li>如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了，一般来说，此对象需要被回收，但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某个条件下“复活”自己</strong>，如果这样，那么对它的回收就不合理的，为此，定义虚拟机中的对象可能的三种状态，如下：<ul>
<li><strong>可触及的：</strong>从根节点开始，可以到达这个对象</li>
<li><strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在finalize()中复活</li>
<li>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因为<strong>finalize()只会被调用一次</strong></li>
</ul>
</li>
<li>以上三种状态中，是由于finalize()方法的存在，进行的区分，只有在对象不可触及时才可以被回收</li>
</ul>
</blockquote>
<p><strong>具体过程</strong>：</p>
<blockquote>
<ul>
<li>判定一个对象objA是否可回收，至少要经历两次标记过程:<ol>
<li>如果对象objA到GC Roots没有引用链，则进行第一次标记</li>
<li>进行筛选，判断此对象是否有必要执行finalize()方法<ul>
<li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过,则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li>
<li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个<strong>虚拟机自动创建的、低优先级的Finalizer线程</strong>触发其finalize()方法执行。</li>
<li><strong>finalize()方法是对象逃脱死亡的最后机会</strong>，稍后cc会对F-Queue队列中的对象进行第二次标记。<strong>如果objA在finalize()方法中与引用链上的任何一个对象建立了联系</strong>，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li>
</ul>
</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="4，MAT与JProfiler的GC-Roots溯源"><a href="#4，MAT与JProfiler的GC-Roots溯源" class="headerlink" title="4，MAT与JProfiler的GC Roots溯源"></a>4，MAT与JProfiler的GC Roots溯源</h4><blockquote>
<ul>
<li><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器，用于查找内存泄漏以及查看内存消耗情况。</p>
</li>
<li><p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p>
</li>
</ul>
</blockquote>
<p><strong>获取dump文件</strong>：</p>
<blockquote>
<p><strong>方式一</strong>：命令行使用jmap</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root&gt;jps</span><br><span class="line"><span class="number">12752</span> Jps</span><br><span class="line"><span class="number">14036</span> GCRootsTest</span><br><span class="line">root&gt;jmap -dump:<span class="built_in">format</span>=b,live,file=test1.bin <span class="number">14036</span></span><br></pre></td></tr></table></figure>

<p><strong>方式二</strong>：使用JVisualVM导出</p>
<ul>
<li>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件</li>
<li>可通过以下方法捕获heap dump:<ul>
<li>在左侧“application”（应用程序）子窗口中右击相应的应用程序，选择Heap Dump（堆Dump）</li>
<li>在Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮</li>
</ul>
</li>
<li>本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开，同时，heap dump在左侧的application（应用程序）栏中对应一个含有时间戳的节点。右击这个节点选择save as（另存为）即可将heap dump保存到本地</li>
</ul>
</blockquote>
<h4 id="5，清除阶段：标记-清除算法（-Mark-Sweep-）"><a href="#5，清除阶段：标记-清除算法（-Mark-Sweep-）" class="headerlink" title="5，清除阶段：标记-清除算法（ Mark-Sweep ）"></a>5，清除阶段：标记-清除算法（ Mark-Sweep ）</h4><blockquote>
<ul>
<li>当成功区分出内存中存活对象和死亡对象后,GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</li>
<li>目前在JVM中比较常见的三种垃圾收集算法是<strong>标记-清除算法（Mark-Sweep )</strong>、<strong>复制算法（ Copying )</strong>、<strong>标记–压缩算法（ Mark-compact )</strong> 。</li>
</ul>
</blockquote>
<p><strong>清除阶段：标记-清除算法</strong>：</p>
<blockquote>
<p><strong>背景</strong>：</p>
<ul>
<li>标记–清除算法（ Mark-Sweep ）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</li>
</ul>
<p><strong>执行过程</strong>：</p>
<ul>
<li>当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world)，然后进行两项工作，第一项则是标记，第二项则是清除。<ul>
<li><strong>标记</strong>：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是<strong>在对象的Header中记录为可达对象</strong></li>
<li><strong>清除</strong>：Collector对堆内存从头到尾进行<strong>线性遍历</strong>，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/05/jvm/68.png" alt="image-20210421094306615"></p>
<p><strong>缺点</strong>：</p>
<ul>
<li>效率不算高</li>
<li>在进行GC的时候，需要停止整个应用程序，导致用户体验差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲列表</li>
</ul>
<p><strong>注意：何为清除？</strong></p>
<ul>
<li>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。</li>
</ul>
</blockquote>
<h4 id="6，清除阶段：复制算法（Copying）"><a href="#6，清除阶段：复制算法（Copying）" class="headerlink" title="6，清除阶段：复制算法（Copying）"></a>6，清除阶段：复制算法（Copying）</h4><p><strong>清除阶段：复制算法</strong>：</p>
<blockquote>
<p><strong>背景</strong>：</p>
<ul>
<li>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，<strong>“使用双存储区</strong>的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Ssing Serial Secondary Storage ).”。M.L.Minsky在该论文中描述的算法被人们称为复制(Copying）算法，它也被M.L.Minsky 本人成功地引入到了Lisp语言的一个实现版本中。</li>
</ul>
<p><strong>核心思想</strong>：</p>
<ul>
<li>将活着的内存空间<strong>分为两块</strong>，每次<strong>只使用其中一块</strong>，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</li>
</ul>
<p><img src="/2021/04/05/jvm/69.png" alt="image-20210421095138092"></p>
<p><strong>优点</strong>：</p>
<ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><p>此算法的缺点也是很明显的，就是需要两倍的内存空间</p>
</li>
<li><p>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管事内存占用或者时间开销也不小</p>
</li>
<li><p><strong>特别的</strong>：</p>
<ul>
<li>如果系统中的存活对象很多，复制算法需要复制的存活对象数量太多，则会导致效率低下</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>在新生代，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</li>
</ul>
<p><img src="/2021/04/05/jvm/70.png" alt="image-20210421095755336"></p>
</blockquote>
<h4 id="7，清除阶段：标记-压缩算法（Mark-Compact）"><a href="#7，清除阶段：标记-压缩算法（Mark-Compact）" class="headerlink" title="7，清除阶段：标记-压缩算法（Mark-Compact）"></a>7，清除阶段：标记-压缩算法（Mark-Compact）</h4><blockquote>
<p><strong>背景</strong>：</p>
<ul>
<li><strong>复制算法</strong>的高效性是建立在<strong>存活对象少、垃圾对象多</strong>的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他算法</strong></li>
<li>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记–压缩（Mark - Compact）算法由此诞生。</li>
<li>1970年前后，G. L. Steele 、 C. J. Chene和D.S. Wise 等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</li>
</ul>
<p><strong>执行过程</strong>：</p>
<ul>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有的存活对象压缩到内存的一段，按顺序排放，之后清理边界外所有的空间</li>
</ul>
<p><img src="/2021/04/05/jvm/71.png" alt="image-20210421100320118"></p>
<ul>
<li>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<strong>标记-清除-压缩(Mark-SweepCompact)</strong>算法。</li>
<li>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</li>
<li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可</li>
<li>消除了复制算法当中，内存减半的高额代价</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>从效率上来说，标记-整理算法要低于复制算法</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要整理引用的地址</li>
<li>移动过程中，需要全程暂时用户应用程序。即：STW</li>
</ul>
</blockquote>
<p><strong>指针碰撞（Bump The Pointer）</strong></p>
<blockquote>
<p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump The Pointer) 。</p>
</blockquote>
<h4 id="8，小结："><a href="#8，小结：" class="headerlink" title="8，小结："></a>8，小结：</h4><p><img src="/2021/04/05/jvm/72.png" alt="image-20210421110323838"></p>
<blockquote>
<p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存</p>
<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段</p>
</blockquote>
<h4 id="9，分代收集算法"><a href="#9，分代收集算法" class="headerlink" title="9，分代收集算法"></a>9，分代收集算法</h4><blockquote>
<ul>
<li>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</li>
<li>分代收集算法，是基于这样一个事实:不同的对象的生命周期是不一样的。因此，<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</strong>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</li>
<li>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<strong>Http请求中的Session对象、线程、Socket连接</strong>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如: <strong>String对象</strong>，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li>
</ul>
</blockquote>
<p><strong>分代收集算法</strong></p>
<blockquote>
<ul>
<li><p><strong>目前几乎所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的</strong></p>
</li>
<li><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点</p>
<ul>
<li><strong>年轻代（Young Gen）</strong><ul>
<li>年轻代特点：区域相对老年代较小，对象生命周期短，存活率低，回收频繁</li>
<li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题。通过Hotspot中的两个survivor的设计得到缓解</li>
</ul>
</li>
<li><strong>老年代（Tenured Gen）</strong><ul>
<li>老年代特点：区域较大，对象生命周期长，存活率高，回收不及年轻代频繁</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适，一般是由标记-清除或者标记-清除与标记-整理的混合实现<ul>
<li>Mark阶段的开销与存活对象的数量成正比</li>
<li>Sweep阶段的开销与所管理区域的大小成正相关</li>
<li>Compact阶段的开销与存活对象的数据成正比</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<ul>
<li>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施:当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</li>
<li>分代的思想被现有的虚拟机广泛使用，几乎所有的垃圾回收器都区分新生代和老年代</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="10，增量收集算法，分区算法"><a href="#10，增量收集算法，分区算法" class="headerlink" title="10，增量收集算法，分区算法"></a>10，增量收集算法，分区算法</h4><p><strong>增量收集算法</strong>：</p>
<blockquote>
<p><strong>背景</strong>：</p>
<ul>
<li>上述现有的算法，在垃圾回收过程中，应用软件将处于一种<strong>Stop The World</strong>的状态。在Stop The World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序将会被挂起很久，<strong>将严重影响用户体验或者系统的稳定性</strong>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生</li>
</ul>
<p><strong>基本思想</strong></p>
<ul>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></li>
<li>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</strong></li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降。</strong></li>
</ul>
</blockquote>
<p><strong>分区算法</strong>：</p>
<blockquote>
<ul>
<li>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li>
<li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</li>
<li>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li>
</ul>
<p><img src="/2021/04/05/jvm/73.png" alt="image-20210421113024237"></p>
</blockquote>
<h3 id="十五，垃圾回收的相关概述"><a href="#十五，垃圾回收的相关概述" class="headerlink" title="十五，垃圾回收的相关概述"></a>十五，垃圾回收的相关概述</h3><h4 id="1，System-gc-理解"><a href="#1，System-gc-理解" class="headerlink" title="1，System.gc()理解"></a>1，System.gc()理解</h4><blockquote>
<ul>
<li>​    在默认情况下，通过System.gc ()或者Runtime.getRuntime ( ).gc ( )的调用，<strong>会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</li>
<li>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。</li>
<li>JVM实现者可以通过System.gc ()调用来决定JVM的GC行为。而一般情况下，<strong>垃圾回收应该是自动进行的，无须手动触发</strong>，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc ( )。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>]; <span class="comment">// 10MB</span></span><br><span class="line">    System.gc();<span class="comment">//buffer所指向的对象不会被回收</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    buffer = full;</span><br><span class="line">    System.gc();<span class="comment">//buffer所指向的对象直接被回收</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    System.gc();<span class="comment">//buffer所指向的对象没有被回收掉，因为对于局部变量中的buffer只是一个被假删除的状态，还继续在slot槽中，所以垃圾回收器仍然判断有引用指向buffer所指向的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">    System.gc();<span class="comment">//buffer所指向的对象被回收，因为对于局部变量表中的slot槽已经被value所覆盖，这时buffer已经被真正删除了，所以垃圾回收器判断没有引用指向buffer所指向的对象了，直接进行垃圾回收</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    localvarGC1();</span><br><span class="line">    System.gc();<span class="comment">//将GC1方法中存在老年代的中的对象进行垃圾回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2，内存溢出与内存泄露"><a href="#2，内存溢出与内存泄露" class="headerlink" title="2，内存溢出与内存泄露"></a>2，内存溢出与内存泄露</h4><p><strong>内存溢出（OOM）</strong></p>
<blockquote>
<ul>
<li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li>
<li>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</li>
<li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</li>
<li>javadoc中对OutOfMemoryError的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存。</strong></li>
<li>首先说没有空闲内存的情况:说明Java虚拟机的堆内存不够。原因有二:<ol>
<li><strong>Java虚拟机的堆内存设置不够。</strong><ul>
<li>比如：可能存在内存泄露问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms，-Xmx来调整</li>
</ul>
</li>
<li><strong>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用)</strong><ul>
<li>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收(如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合：类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关:“<code>java.lang.OutOfMemoryError: PermGen space</code>“。</li>
<li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的ooM有所改观，出现OOM，异常信息则变成了:“<code>java.lang.OutOfMemoryError: Metaspace</code>“”。直接内存不足，也会导致OOM。</li>
</ul>
</li>
</ol>
</li>
<li>这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理空间<ul>
<li>例如：在引用机制分析中，涉及到JVM会去尝试回收<strong>软引用指向的对象等。</strong></li>
<li>在java.nio.BIts.reserveMemory（）方法中，我们能清除的看到，System.gc（）会被调用，以清理空间</li>
</ul>
</li>
<li>当然，也不是在任何情况下垃圾收集器都会被触发的<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数据超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>内存泄漏（Memory Leak）</strong></p>
<blockquote>
<ul>
<li>也称作“存储渗漏”。<strong>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</strong></li>
<li>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做<strong>宽泛意义上的“内存泄漏”。</strong></li>
<li>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。</li>
<li>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</li>
<li>举例：<ul>
<li>单例模式：<ul>
<li>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生</li>
</ul>
</li>
<li>一些提供close的资源未关闭导致内存泄漏<ul>
<li>数据库连接（dataSource.getConnection()），网络连接（socket）和io连接必须手动close，否则是不能被回收的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3，Stop-The-World"><a href="#3，Stop-The-World" class="headerlink" title="3，Stop The World"></a>3，Stop The World</h4><blockquote>
<ul>
<li>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW<ul>
<li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。</strong></li>
</ul>
</li>
</ul>
</li>
<li>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户柑橘像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</li>
<li>STW事件和采用哪款GC无关，所有的GC都有这个事件</li>
<li>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</li>
<li>STW是JVM在<strong>后台自动发起和自动完成</strong>的，在用户不可见的情况下，把用户正常的工作线程全部停掉</li>
<li>开发中不要用System.gc（）；会导致Stop-The-World的发生</li>
</ul>
</blockquote>
<h4 id="4，垃圾回收的并行与并发"><a href="#4，垃圾回收的并行与并发" class="headerlink" title="4，垃圾回收的并行与并发"></a>4，垃圾回收的并行与并发</h4><blockquote>
<ul>
<li>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：<ul>
<li>并行（Parallel）：<strong>指多条垃圾收集线程并行工作</strong>，但此时用户仍处于等待状态。<ul>
<li>如ParNew，Parallel Scavenge，Parallel Old；</li>
</ul>
</li>
<li>串行（Serial）<ul>
<li>相较于并行的概念，单线程执行</li>
<li>如果内存不够，则程序暂时，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>
</ul>
</li>
<li>并发（Concurrent）：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行<ul>
<li>用户程序在继续运行，而垃圾收集程序线程运行另一个CPU上</li>
<li>如CMS，G1</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="5，安全点与安全区域"><a href="#5，安全点与安全区域" class="headerlink" title="5，安全点与安全区域"></a>5，安全点与安全区域</h4><p><strong>安全点（Safe Point）</strong>：</p>
<blockquote>
<ul>
<li>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始Gc，这些位置称为“安全点(Safepoint) ”。</li>
<li>Safe Point的选择很重要，<strong>如果太少可能导致Gc等待的时间太长，如果太频繁可能导致运行时的性能问题。</strong>大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征”</strong>为标准。比如:选择一些执行时间较长的指令作为Safe Point，如<strong>方法调用、循环跳转和异常跳转等。</strong></li>
<li>如何在GC发生时，检查所有线程都跑到最近安全点停顿下来呢？<ul>
<li><strong>抢先式中断：（目前没有虚拟机采用了）</strong><ul>
<li>首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点</li>
</ul>
</li>
<li><strong>主动式中断</strong>：<ul>
<li>设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>安全区域（Safe Region）</strong></p>
<blockquote>
<ul>
<li>safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢?例如线程处于sleep 状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region）来解决。</li>
<li><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的</strong>。我们也可以把 safe Region看做是被扩展了的safepoint。</li>
<li><strong>实际执行时</strong>：<ul>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程；</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="6，强引用——不可回收"><a href="#6，强引用——不可回收" class="headerlink" title="6，强引用——不可回收"></a>6，强引用——不可回收</h4><blockquote>
<ul>
<li>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public,可以在应用程序中直接使用</li>
<li><strong>强引用(StrongReference)</strong> ：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似<code>object obj=new object()</code>这种引用关系。<strong>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</strong></li>
<li><strong>软引用(SoftReference)</strong>：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li>
<li><strong>弱引用(leakReference)</strong>：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>
<li><strong>虚引用(PhantomReference)</strong>：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。</li>
</ul>
</blockquote>
<p><strong>强引用</strong></p>
<blockquote>
<ul>
<li><p>在Java程序中，最常见的引用类型是强引用（<strong>普通系统99%以上都是强引用</strong>），也就是我们最常见的普通对象引用，也是<strong>默认的引用类型</strong>。</p>
</li>
<li><p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
</li>
<li><p><strong>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong></p>
</li>
<li><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
</li>
<li><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<strong>强引用是造成Java内存泄漏的主要原因之一</strong></p>
</li>
<li><p><strong>强引用的例子</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>

<p>局部变量str指向StringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是StringBuffer实例的强引用</p>
</li>
<li><p>强引用具备以下特点：</p>
<ul>
<li>强引用可以直接访问目标对象</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象</li>
<li>强引用可能导致内存泄露</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="7，软引用（Soft-Reference）——内存不足即回收"><a href="#7，软引用（Soft-Reference）——内存不足即回收" class="headerlink" title="7，软引用（Soft Reference）——内存不足即回收"></a>7，软引用（Soft Reference）——内存不足即回收</h4><blockquote>
<ul>
<li><p>软引用是用来描述一些还有用，但非必需的对象。<strong>只被软引用关联着的对象,在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
</li>
<li><p>软引用通常用来实现内存敏感的缓存。比如:<strong>高速缓存</strong>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
</li>
<li><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列(Reference Queue) 。</p>
</li>
<li><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
</li>
<li><p>软引用例子：</p>
<p>在JDK1.2之后提供了java.lang.ref.SoftReference类来实现引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();<span class="comment">//声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;<span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</blockquote>
<h4 id="8，弱引用（Weak-Reference）——发现即回收"><a href="#8，弱引用（Weak-Reference）——发现即回收" class="headerlink" title="8，弱引用（Weak Reference）——发现即回收"></a>8，弱引用（Weak Reference）——发现即回收</h4><blockquote>
<ul>
<li><p>弱引用也是用来描述那些非必需对象，被<strong>弱引用关联的对象只能生存到下一次垃圾收集发生为止。</strong>在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
</li>
<li><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<strong>弱引用对象可以存在较长的时间。</strong></p>
</li>
<li><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
</li>
<li><p><strong>软引用、弱引用都非常适合来保存那些可有可无的==缓存==数据</strong>。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<p>在JDK1.2版之后提供了java.langg.ref.WeakReference类来实现弱引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj &#x3D; new Object(); &#x2F;&#x2F;声明强引用</span><br><span class="line">WeakReference&lt;Object&gt; wr &#x3D; new WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj &#x3D; null;&#x2F;&#x2F;销毁强引用</span><br></pre></td></tr></table></figure>

<p><strong>弱引用对象与软引用对象的最大不同</strong>就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收，<strong>弱引用对象更容易，更快被GC回收</strong></p>
</li>
</ul>
</blockquote>
<h4 id="9，虚引用（Phantom-Reference）——对象回收跟踪"><a href="#9，虚引用（Phantom-Reference）——对象回收跟踪" class="headerlink" title="9，虚引用（Phantom Reference）——对象回收跟踪"></a>9，虚引用（Phantom Reference）——对象回收跟踪</h4><blockquote>
<ul>
<li><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p>
</li>
<li><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
</li>
<li><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。</p>
</li>
<li><p>为一个对象设置虚引用关联的<strong>唯一目的在于跟踪垃圾回收过程</strong>。比如:能在这个对象被收集器回收时收到一个系统通知。</p>
</li>
<li><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
</li>
<li><p><strong>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue phantomQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReferenc&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj,phantomQueue);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</blockquote>
<h4 id="10，终结器引用（Final-Reference）"><a href="#10，终结器引用（Final-Reference）" class="headerlink" title="10，终结器引用（Final Reference）"></a>10，终结器引用（Final Reference）</h4><blockquote>
<ul>
<li>他用以实现对象的finalize()方法，也可以称为终结器引用</li>
<li>无需手动编码，其内部配合引用队列使用</li>
<li>在GC时，终结器引用入队，由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize（）方法，第二次GC时才能回收被引用对象</li>
</ul>
</blockquote>
<h3 id="十六，垃圾回收器"><a href="#十六，垃圾回收器" class="headerlink" title="十六，垃圾回收器"></a>十六，垃圾回收器</h3><h4 id="1，GC分类与性能指标"><a href="#1，GC分类与性能指标" class="headerlink" title="1，GC分类与性能指标"></a>1，GC分类与性能指标</h4><p><strong>垃圾回收器概述</strong>：</p>
<blockquote>
<ul>
<li><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商，不同版本的JVM实现</p>
</li>
<li><p>由于JDK的版本处于高速迭代的过程中，因此Java发展至今已经衍生了众多的GC版本</p>
</li>
<li><p>从不同角度分析垃圾收集器，可以将GC分为不同的类型</p>
</li>
<li><p>Java不同版本的新特性：</p>
<ul>
<li>语法层面：Lambda表达式，switch，自动装箱，自动拆箱，enum，&lt;&gt; ….</li>
<li>API层面：Stream API，新的日期时间，Optional，String，集合框架 …</li>
<li>底层优化：JVM的优化，GC的变化，元空间，静态域，字符串常量池等</li>
</ul>
</li>
<li><p>按<strong>线程数</strong>分：可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong></p>
<p><img src="/2021/04/05/jvm/74.png" alt="image-20210423180913180"></p>
<ul>
<li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ul>
<li>在诸如单CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<strong>串行回收默认被应用在客户端的Client模式下的JVM中</strong></li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器</li>
</ul>
</li>
<li>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-The-World”机制。</li>
</ul>
</li>
<li><p>按照<strong>工作模式</strong>分，可以分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong></p>
<ul>
<li><p>并发垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</p>
</li>
<li><p>独占式垃圾回收器（Stop-The-World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾会收过程完全结束。</p>
<p><img src="/2021/04/05/jvm/75.png" alt="image-20210423181444916"></p>
</li>
</ul>
</li>
<li><p>按照<strong>碎片处理方式</strong>分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong></p>
<ul>
<li>压缩式垃圾回收器会在回收完成中，对存活对象进行压缩整理，消除回收后的碎片。</li>
<li>非压缩的垃圾回收器不进行这步操作</li>
</ul>
</li>
<li><p>按<strong>工作的内存区间</strong>分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong></p>
</li>
</ul>
</blockquote>
<p><strong>评估GC的性能指标</strong>：</p>
<blockquote>
<ul>
<li><strong>吞吐量：运行用户代码的时间占总运行时间的比例</strong><ul>
<li>（总运行时间：程序的运行时间+内存回收的时间）</li>
</ul>
</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</strong></li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率</li>
<li><strong>内存占用：Java堆区所占的内存大小</strong></li>
<li>快速：一个对象从诞生到被回收所经历的时间</li>
<li>吞吐量，暂停时间，内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li>
<li>吞吐量，暂停时间，内存占用这三项里，<strong>暂停时间的重要性日益凸显</strong>。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li>
<li>简单来说，主要抓住两点：<ul>
<li>吞吐量</li>
<li>暂停时间</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>评估GC的性能指标：吞吐量（throughput）</strong></p>
<blockquote>
<ul>
<li><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）</p>
<ul>
<li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%</li>
</ul>
</li>
<li><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>
</li>
<li><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4</p>
<p><img src="/2021/04/05/jvm/76.png" alt="image-20210423213033626"></p>
</li>
</ul>
</blockquote>
<p><strong>评估GC的性能指标：暂停时间（pause time）</strong></p>
<blockquote>
<ul>
<li><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态</p>
<ul>
<li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的</li>
</ul>
</li>
<li><p>暂停时间优先，意味着尽可能让单位STW的时间最短：0.1 + 0.1 + 0.1 + 0.1  + 0.1 = 0.5</p>
<p><img src="/2021/04/05/jvm/77.png" alt="image-20210423213344985"></p>
</li>
</ul>
</blockquote>
<p><strong>评估GC的性能指标：吞吐量 VS 暂停时间</strong></p>
<blockquote>
<ul>
<li>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作，直觉上，吞吐量越高程序运行越快</li>
<li>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是Gc还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有<strong>时候甚至短暂的200毫秒暂停都可能打断终端用户体验。</strong>因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</li>
<li>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）<ul>
<li>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也<strong>只能频繁地执行内存回收</strong>，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li>
</ul>
</li>
<li>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折中</li>
<li>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></li>
</ul>
</blockquote>
<h4 id="2，不同的垃圾回收器概述"><a href="#2，不同的垃圾回收器概述" class="headerlink" title="2，不同的垃圾回收器概述"></a>2，不同的垃圾回收器概述</h4><p><strong>7种经典的垃圾收集器</strong>：</p>
<blockquote>
<ul>
<li><p>串行回收器：Serial，Serial Old</p>
</li>
<li><p>并行回收器：ParNew，Parallel Scavenge，Parallel Old</p>
</li>
<li><p>并发回收器：CMS，G1</p>
<p><img src="/2021/04/05/jvm/79.png" alt="image-20210423215431171"></p>
</li>
</ul>
</blockquote>
<p><strong>7款经典收集器与垃圾分代之间的关系</strong></p>
<blockquote>
<p><img src="/2021/04/05/jvm/80.png" alt="image-20210423215528124"></p>
<ul>
<li>新生代收集器：Serial，ParNew，Parallel Scavenge</li>
<li>老年代收集器：Serial Old，Parallel Old，CMS</li>
<li>整堆收集器：G1</li>
</ul>
</blockquote>
<p><strong>垃圾回收器组合关系</strong>：</p>
<blockquote>
<p><img src="/2021/04/05/jvm/78.png" alt="image-20210423214231958"></p>
<ul>
<li>两个收集器间有连线，表明它们可以搭配使用：<ul>
<li>Serial / Serial Old、Serial / CMC、ParNew / Serial Old、ParNew / CMS、Parallel Scavenge / Serial Old、Parallel Scavenge / Parallel Old，G1</li>
</ul>
</li>
<li><strong>其中Serial Old作为CMS出现<code>“Concurrent Mode Failure”</code>失败的后备预案</strong></li>
<li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial + CMS、ParNew + Serial Old这两个组合声明为废弃（JER 173），并在JDK 9中完全取消了这些组合的支持（JEP 214），即：移除</li>
<li>（绿色虚线）JDK 14中：弃用Parallel Scavenge和SerialOld GC组合（JEP 336）</li>
<li>（青色虚线）JDK 14中：删除CMS垃圾回收器（JEP 363）</li>
</ul>
</blockquote>
<p><strong>为什么需要很多收集器？</strong></p>
<blockquote>
<ul>
<li>因为Java的使用场景很多，移动端，服务端等，所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能</li>
<li>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来，没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器，所以我们选择的只是<strong>对具体应用最合适的收集器</strong></li>
</ul>
</blockquote>
<p><strong>如何查看默认的垃圾收集器</strong>：</p>
<blockquote>
<ul>
<li><strong>-XX：+PrintCommandLineFlags</strong>：查看命令行相关参数（包含使用的垃圾收集器）</li>
<li>使用命令行指令：<strong>jinfo -flag 相关垃圾回收器参数 进程ID</strong></li>
</ul>
</blockquote>
<h4 id="3，Serial回收器：串行回收"><a href="#3，Serial回收器：串行回收" class="headerlink" title="3，Serial回收器：串行回收"></a>3，Serial回收器：串行回收</h4><blockquote>
<ul>
<li>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</li>
<li>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。<strong>Serial 收集器采用复制算法、串行回收和”Stop-The-World”机制的方式执行内存回收。</strong></li>
<li>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。<strong>Serial Old收集器同样也采用了串行回收和”Stop-The-World”机制，只不过内存回收算法使用的是==标记-压缩==算法。</strong><ul>
<li>Serial Old是运行在Client模式下默认的老年代的垃圾回收器</li>
<li>Serial Old在Server模式下主要有两个用途：① 与新生代的Parallel Scavenge配合使用 ② 作为老年代CMS收集器的后备垃圾收集方案</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/05/jvm/81.png" alt="image-20210424004912012"></p>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明他<strong>只会使用一个CPU或一条收集线程去完成垃圾收集工作</strong>，更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程</strong>，直到它收集结束（Stop-The-World）</p>
<ul>
<li>优势：<strong>简单而高效</strong>（与其他收集器的单线程比），对于限定单个CPU 的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。<ul>
<li>运行在Client模式下的虚拟机是个不错的选择。</li>
</ul>
</li>
<li>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</li>
<li>在HotSpot虚拟机中，使用<code>-XX：+UseserialGC</code>参数可以指定年轻代和老年代都使用串行收集器。<ul>
<li>等价于新生代用Serial GC，且老年代用Serial Old GC</li>
</ul>
</li>
<li><strong>总结</strong>：<ul>
<li>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</li>
<li>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Javaweb应用程序中是不会采用串行垃圾收集器的。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="4，ParNew回收器：并行回收"><a href="#4，ParNew回收器：并行回收" class="headerlink" title="4，ParNew回收器：并行回收"></a>4，ParNew回收器：并行回收</h4><blockquote>
<ul>
<li>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。<ul>
<li>Par是Parallel的缩写，New：只能处理的是新生代</li>
</ul>
</li>
<li>ParNew收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是<strong>采用复制算法</strong>、<strong>“Stop-The-World”</strong>机制。</li>
<li>ParNew是很多JVM运行在Server模式下<strong>新生代</strong>的默认垃圾收集器。</li>
</ul>
<p><img src="/2021/04/05/jvm/82.png" alt="image-20210424005741468"></p>
<ul>
<li><p>这个收集器是一个单线程的收集器，但它的“单线程” 的意义并不仅仅说明它<strong>只会使用一个CPU或一条收集线程去完成垃圾收集工作</strong>，更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程</strong>，直到它收集结束（Stop-The-World）</p>
</li>
<li><p>对于新生代，回收次数频繁，使用并行方式高效</p>
</li>
<li><p>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</p>
</li>
<li><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场影下都会比Serial收集器更高效?</p>
<ul>
<li>ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是<strong>在单个CPU的环境下，ParNew收集器不比Serial 收集器更高效</strong>。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
</ul>
</li>
<li><p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p>
</li>
<li><p>在程序中，开发人员可以通过选项<code>“-XX：+UserParNewGC”</code>手动指定使用ParNew收集器执行内存回收任务，它表示年轻代使用并行收集器，不影响老年代</p>
</li>
<li><p><code>“-XX：ParallelGCThreads”</code>限制线程数量，默认开启和CPU数据相同的线程数</p>
</li>
</ul>
</blockquote>
<h4 id="5，Parallel-Scavenge回收器：吞吐量优先"><a href="#5，Parallel-Scavenge回收器：吞吐量优先" class="headerlink" title="5，Parallel Scavenge回收器：吞吐量优先"></a>5，Parallel Scavenge回收器：吞吐量优先</h4><blockquote>
<ul>
<li>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了<strong>复制算法</strong>、<strong>并行回收**</strong>和<strong>“Stop-The-World”机制。</strong></li>
<li>那么Parallel收集器的出现是否多此一举？<ul>
<li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器</li>
<li>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。</li>
</ul>
</li>
<li>高吞吐量则可以高效率地利用CPU时间尽快完成程序的运算任务，主要<strong>适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用。例如，那些<strong>执行批量处理、订单处理、工资支付、科学计算的应用程序。</strong></li>
<li>Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。</li>
<li>Parallel Old收集器采用了<strong>标记-压缩算法</strong>，但同样也是基于<strong>并行回收和”Stop-The-World”机制</strong>。</li>
</ul>
<p><img src="/2021/04/05/jvm/83.png" alt="image-20210424011132187"></p>
<ul>
<li>在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器组合，在Server模式下的内存回收性能很是不错</li>
<li>在Java8中，默认是此垃圾收集器</li>
<li><strong>参数配置</strong>：<ul>
<li><code>&quot;-XX：+UseParallelGC&quot;</code>：手动指定年轻代使用Parallel并行收集器执行内存回收任务</li>
<li><code>“-XX：+UseParallelOldGC”</code>：手动指定老年代都是使用并行回收收集器。<ul>
<li>分别适用于新生代和老年代，默认JDK8是开启的</li>
<li>上面两个参数，默认开启一个，另一个也会被开启<strong>（互相激活）</strong></li>
</ul>
</li>
<li><code>“-XX：ParallelGCThreads”</code>：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能<ul>
<li>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量</li>
<li>当CPU数量大于8个，ParallelGCThreads的值等于 3 + [ 5 * CPU_COUNT ] / 8</li>
</ul>
</li>
<li><code>&quot;-XX：MaxGCPauseMillis&quot;</code>：设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒<ul>
<li>为了尽可能地把停顿时间控制在MaxGCPauseMillis以内，收集器在工作时会调整Java堆大小或者其他一些参数</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务端，我们注重高并发，整体的吞吐量，所以服务器适合Parallel，进而控制</li>
<li><strong>该参数使用需谨慎</strong></li>
</ul>
</li>
<li><code>&quot;-XX：GCTimeRatio&quot;</code>：垃圾收集时间占总时间的比例（ = 1 / （N + 1））用于衡量吞吐量的大小<ul>
<li>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1%</li>
<li>与前一个<code>&quot;-XX：MaxGCPauseMillis&quot;</code>参数有一定矛盾性，暂停时间越长，Radio参数就容易超过设定的比例</li>
</ul>
</li>
<li><code>&quot;-XX:+UseAdaptiveSizePolicy&quot;</code>设置Parallel Scavenge收集器具有自适应调节策略<ul>
<li>在这种模式下，年轻代的大小，Eden和Survivor的比例，晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小，吞吐量和停顿时间之间的平衡点</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆，目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="6，CMS回收器：低延迟"><a href="#6，CMS回收器：低延迟" class="headerlink" title="6，CMS回收器：低延迟"></a>6，CMS回收器：低延迟</h4><blockquote>
<ul>
<li>在JDK 1.5时期，HotSpot推出了一款在<strong>强交互应用</strong>中几乎可认为有划时代意义的垃圾收集器:CMS (concurrent-Mark-Sweep)收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的<strong>并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</strong></li>
<li>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。<ul>
<li><strong>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</strong>，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li>
</ul>
</li>
<li>CMS的垃圾收集算法采用<strong>标记-清除</strong>算法，并且也会”Stop-The-World”</li>
<li>不幸的是，CMS 作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge 配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</li>
<li>在G1出现之前，CMS使用还是非常广泛的，一直到今天，仍然有很多系统使用CMS GC</li>
</ul>
<p><img src="/2021/04/05/jvm/84.png" alt="image-20210424021242488"></p>
<p>CMS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段，即<strong>初始标记阶段</strong>、<strong>并发标记阶段</strong>、<strong>重新标记阶段</strong>和<strong>并发清除阶段</strong>。|</p>
<ul>
<li><strong>初始标记（Initial-Mark)阶段</strong>：在这个阶段中，程序中所有的工作线程都将会因为“Stop-The-World”机制而出现短暂的暂停，这个阶段的主要任务<strong>仅仅只是标记出GC Roots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快。</strong></li>
<li><strong>并发标记（Concurrent-Mark)阶段</strong>：从GC Roots的<strong>直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长但是不需要停顿用户线程</strong>，可以与垃圾收集线程一起<strong>并发运行</strong>。</li>
<li><strong>重新标记（Remark）阶段</strong>：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会<strong>比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</strong>。</li>
<li><strong>并发清除(Concurrent-Sweep）阶段</strong>：此阶段<strong>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</strong>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程<strong>同时并发</strong>的</li>
</ul>
</blockquote>
<p><strong>为什么CMS垃圾回收器是低延迟的？怎么实现的？</strong></p>
<blockquote>
<ul>
<li><p>尽管CMS收集器采用的是并发回收（非独占式)，但是在其<strong>初始化标记和再次标记</strong>这两个阶段中仍然需要<strong>执行“Stop-The-World”机制</strong>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-The-World”，只是尽可能地缩短暂停时间。</p>
</li>
<li><p><strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</strong></p>
</li>
<li><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<strong>当堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“<strong>Concurrent Mode Failure</strong>”失败，这时虚拟机将启动后备预案：临时启用Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
</li>
</ul>
</blockquote>
<p><strong>CMS弊端</strong>：</p>
<blockquote>
<p>CMS收集器的垃圾收集算法采用的是<strong>标记-清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer)技术，而只能够选择空闲列表（Free List）执行内存分配。</p>
</blockquote>
<p><strong>有人会觉得既然Mark Sweep会造成内存碎片,那么为什么个把算法换成Mark Compact呢?</strong></p>
<blockquote>
<p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢?要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“Stop The World”这种场景下使用</p>
</blockquote>
<p><strong>总结</strong>：</p>
<blockquote>
<ul>
<li><strong>CMS的优点</strong>：<ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
</li>
<li><strong>CMS的弊端</strong>：<ul>
<li><strong>会产生内存碎片，</strong>导致并发清除后，用户线程可用的空间不足，在无法分配大对象的情况下，不得不提前触发Full GC</li>
<li><strong>CMS收集器对CPU资源非常敏感</strong>，在并发阶段，他虽然不会导致用户停顿但是会因为占用了一个部分线程而导致应用程序变慢，总吞吐量减低</li>
<li><strong>CMS收集器无法处理浮动垃圾</strong>，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生，在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<strong>在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终导致这些新产生的垃圾对象没有被及时回收</strong>，从而只能在下一次执行GC时释放这些之前未被回收的内存空间</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>参数设置</strong>：</p>
<blockquote>
<ul>
<li><code>-XX:+UseConcMarkSweepGC</code>：手动指定使用CMS收集器执行内存回收任务。<ul>
<li>开启该参数后会自动将<code>-XX:+UseParNewGC</code>打开。即: ParNew (Young区用)+CMS (old区用)+Serial Old的组合。</li>
</ul>
</li>
<li><code>-XX:CMSlnitiatingOccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。<ul>
<li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68号时，会执行一次CMS回收。<strong>JDK6及以上版本默认值为92%</strong></li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此<strong>通过该选项便可以有效降低Full GC的执行次数。</strong></li>
</ul>
</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定在执行完FullGC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了</li>
<li><code>-XX:CMSFullGCsBeforeCompaction</code>：设置在执行多少次Full GC后对内存空间进行压缩整理。</li>
<li><code>-XX: ParallelCMSThreads</code>：设置CMS的线程数量。<ul>
<li>CMS 默认启动的线程数是（ ParallelGCThreads + 3 ) / 4，ParallelGcThreads 是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到cMs收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>小结</strong>：</p>
<blockquote>
<p>​    HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</p>
<p>​    请记住以下口令：</p>
<ul>
<li>如果你想要<strong>最小化地使用内存和并行开销</strong>，请选<strong>Serial GC</strong></li>
<li>如果你想要<strong>最大化应用程序的吞吐量</strong>，请选<strong>Parallel GC</strong></li>
<li>如果你想要<strong>最小化GC的中断或停顿时间</strong>，请选<strong>CMS GC</strong></li>
</ul>
</blockquote>
<p><strong>JDK后续版本中CMS的变化</strong>：</p>
<blockquote>
<ul>
<li>JDK9新特性：CMS被标记为Deprecate（JEP291）<ul>
<li>如果对JDK 9及以上版本的HotSpot虚拟机使用参数<code>-XX:UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃</li>
</ul>
</li>
<li>JDK 14新特性：删除CMS垃圾回收器（JEP363）<ul>
<li>移除了CMS垃圾收集器，如果在JDK 14中使用<code>-XX:+UseConcMarkSweepGC</code>的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="7，G1回收器：区域化分代式"><a href="#7，G1回收器：区域化分代式" class="headerlink" title="7，G1回收器：区域化分代式"></a>7，G1回收器：区域化分代式</h4><p><strong>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First (G1)GC?</strong></p>
<blockquote>
<ul>
<li>原因就在于应用程序所应对的<strong>业务越来越庞大、复杂，用户越来越多</strong>，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 (Garbage-First）垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</li>
<li>与此同时，为了适应现在<strong>不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间(pause time），同时兼顾良好的吞吐量。</li>
<li>官方给G1设定的目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量</strong>，所以才担当起“全功能收集器”的重任与期望。</li>
</ul>
</blockquote>
<p><strong>为什么名字叫做Garbage First（G1）？</strong></p>
<blockquote>
<ul>
<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域(Region)（物理上不连续的）。使用不同的Region来表示Eden、幸存者o区，幸存者1区，老年代等。</li>
<li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong></li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region)，所以我们给G1一个名字:<strong>垃圾优先（Garbage First) 。</strong></li>
</ul>
</blockquote>
<p><strong>G1概述</strong>：</p>
<blockquote>
<ul>
<li>G1 (Garbage-First）是一款面向服务端应用的垃圾收集器，<strong>主要针对配备多核cPU及大容量内存的机器</strong>，以极高概率满足cc停顿时间的同时,还兼具高吞吐量的性能特征。</li>
<li>在JDK1.7版本正式启用，移除了Experimental的标识，是<strong>JDK 9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel + Parallel old组合。被oracle官方称为“<strong>全功能的垃圾收集器</strong>”。</li>
<li>与此同时，CMS已经在JDK 9中被标记为废弃（deprecated)。在jdk8中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</li>
</ul>
</blockquote>
<p><strong>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</strong></p>
<blockquote>
<ul>
<li><p><strong>并行与并发</strong>：</p>
<ul>
<li>并行性:G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
<li>并发性: G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li><p><strong>分代收集</strong>：</p>
<p><img src="/2021/04/05/jvm/85.png" alt="image-20210424110314823"></p>
<ul>
<li>从分代上看，<strong>G1依然属于分代型垃圾回收器</strong>，它会<strong>区分年轻代和老年代</strong>，年轻代依然有Eden区和survivor区，但从堆的结构上看，它<strong>不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</strong></li>
<li>将堆空间分为<strong>若干个区域(Region)</strong>,这些区域中<strong>包含了逻辑上的年轻代和老年代</strong>。和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代;</li>
</ul>
</li>
<li><p><strong>空间整合</strong>：</p>
<ul>
<li>CMS：“标记-清除”算法，内存碎片，若干次GC后进行一次碎片整理</li>
<li>G1将内存划分为一个个的region，内存的回收是以region作为基本单位的，<strong>Region之间是复制算法</strong>，但<strong>整体上实际可看作是标记-压缩算法（Mark-Compact）</strong>，两种算法都可以避免内存碎片，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC，尤其是当Java堆非常大的时候，G1的优势更加明显</li>
</ul>
</li>
<li><p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong></p>
<ul>
<li>这是 G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong>。保证了G1收集器在有限的时间内可以<strong>获取尽可能高的收集效率</strong>。</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>G1收集器的缺点</strong>：</p>
<blockquote>
<ul>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用(Footprint）还是程序运行时的额外执行负载(Overload）都要比CMS要高。</li>
<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</li>
</ul>
</blockquote>
<p><strong>G1的参数设置</strong>：</p>
<blockquote>
<ul>
<li><code>-XX:+UseG1GC</code>：手动指定使用G1收集器执行内存回收任务</li>
<li><code>-XX:G1HeapRegionSize</code>：设置每个Region的大小，值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1 / 2000</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li>
<li><code>-XX:ParallelGCThread</code>：设置STW工作线程数的值，最多设置为8</li>
<li><code>-XX:ConcGCThreads</code>：设置并发标记的线程数，将n设置为并行垃圾回收线程数（ParallelGCThreads）的1 / 4左右</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置触发并发GC周期的Java堆占用率阈值，超过此值，就触发GC。默认值是45</li>
</ul>
</blockquote>
<p><strong>G1回收器的常见操作步骤</strong>：</p>
<blockquote>
<ul>
<li>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：<ul>
<li>第一步：开启G1垃圾收集器</li>
<li>第二 步：设置堆的最大内存</li>
<li>第三步：设置最大的停顿时间</li>
</ul>
</li>
<li>G1中提供了三种垃圾回收模式：YoungGC，Mixed GC和Full GC，在不同的条件下被触发</li>
</ul>
</blockquote>
<p><strong>G1垃圾回收器的适用场景</strong>：</p>
<blockquote>
<ul>
<li>面向服务端应用，针对具有<strong>大内存、多处理器</strong>的机器。(在普通大小的堆里表现并不惊喜)</li>
<li>最主要的应用是<strong>需要低GC延迟，并具有大堆的应用程序</strong>提供解决方案;</li>
<li>如:在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；(G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）</li>
<li>用来替换掉JDK1.5中的CMS收集器：在下面的情况时，使用G1可能比CMS好：<ul>
<li>超过50%的Java堆被活动数据占用</li>
<li>对象分配频率或年代提升频率变化很大</li>
<li>GC停顿时间过长（长于0.5至1秒）</li>
</ul>
</li>
<li>HotSpot垃圾收集器里，除了G1以外，<strong>其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作</strong>，而<strong>G1 GC可以采用应用线程承担后台运行的GC工作</strong>，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li>
</ul>
</blockquote>
<p><strong>分区Region：化整为零</strong></p>
<blockquote>
<ul>
<li>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB,16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定，<strong>所有的Region大小相同，且在JVM生命周期内不会被改变</strong></li>
<li>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region(不需要连续）的集合。<strong>通过Region的动态分配方式</strong>实现逻辑上的连续。</li>
<li><img src="/2021/04/05/jvm/86.png" alt="image-20210424112850335"></li>
<li>一个region 有可能属于Eden，Survivor或者Old / Tenured内存区域。但是<strong>一个region只可能属于一个角色</strong>。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，o表示属于Old内存区域。图中空白的表示未使用的内存空间。</li>
<li>G1垃圾收集器还增加了一种新的内存区域，叫做 Humongous内存区域，如图中的H块。<strong>主要用于存储大对象，如果超过0.5个region，就放到H。</strong></li>
<li>设置H的原因：<ul>
<li>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。<strong>如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到连续的H区，有时候不得不启动Full Gc。G1的大多数行为都把<strong>H区作为老年代的一部分来看待</strong>。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>G1回收器垃圾回收的过程</strong>：</p>
<blockquote>
<ul>
<li><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>年轻代GC（Young GC）</li>
<li>老年代并发标记过程（Concurrent Marking）</li>
<li>混合回收（Mixed GC）</li>
<li>（如果需要，单线程，独占式，高强度的Full GC还是继续存在的，它针对GC的评估失败提供了一种失败保护机制，即强力回收）</li>
</ul>
<p><img src="/2021/04/05/jvm/87.png" alt="image-20210424113545502"></p>
<p>顺时针，Young GC –&gt; Young GC + Concurrent Mark  –&gt; Mixed GC顺序，进行垃圾回收</p>
<ul>
<li>应用程序分配内存，<strong>当年轻代的Eden区用尽时开始年轻代回收过程</strong>；G1的年轻代收集阶段是一个<strong>并行的独占式收集器</strong>。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后<strong>从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</strong></li>
<li>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</li>
<li><strong>标记完成马上开始混合回收过程</strong>。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了</strong>。同时，这个老年代Region是和年轻代一起被回收的。</li>
<li>举个例子:一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>G1回收器垃圾回收过程：Remembered Set（记忆集）</strong></p>
<blockquote>
<ul>
<li>一个对象被不同区域引用的问题</li>
<li>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确?</li>
<li>在其他的分代收集器，也存在这样的问题（而G1更突出)回收新生代也不得不同时扫描老年代?这样的话会降低Minor GC的效率</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>无论G1还是其他分代收集器，JVM都是使用Remembered set来避免全局扫描：<strong>每个Region都有一个对应的Remembered Set;</strong></li>
<li><strong>每次Reference类型数据写操作时，都会产生一个Write Barrier（写屏障）暂时中断操作</strong></li>
<li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集器：检查老年代对象是否引用了新生代对象）;</li>
<li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中</li>
<li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set就可以保证不进行全局扫描，也不会有遗漏。</li>
</ul>
<p><img src="/2021/04/05/jvm/89.png" alt="image-20210424115058212"></p>
</blockquote>
<p><strong>G1回收过程一：年轻代GC</strong></p>
<blockquote>
<p><img src="/2021/04/05/jvm/88.png" alt="image-20210424115010552"></p>
<ul>
<li>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，<strong>当Eden空间耗尽时</strong>，G1会启动一次年轻代垃圾回收过程。</li>
<li><strong>年轻代垃圾回收只会回收Eden区和Survivor区</strong>。</li>
<li>YGC时，首先G1停止应用程序的执行(Stop-The-world)，G1创建回收集(Collection Set)，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和survivor区所有的内存分段。</li>
</ul>
<p><strong>年轻代GC回收过程：</strong></p>
<ul>
<li><strong>第一阶段，扫描根</strong><ul>
<li>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。<strong>根引用连同RSet记录的外部引用</strong>作为扫描存活对象的入口。</li>
</ul>
</li>
<li><strong>第二阶段，更新RSet</strong><ul>
<li>处理dirty card queue(见备注)中的card，更新RSet。此阶段完成后，<strong>RSet可以准确的反映老年代对所在的内存分段中对象的引用。</strong><ul>
<li><strong>dirty card queue（脏卡表队列）</strong>：对于应用程序的引用赋值语句<code>object.field = object</code>，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对dirty card queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系</li>
<li>那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销很大，使用队列性能会好很多</li>
</ul>
</li>
</ul>
</li>
<li><strong>第三阶段，处理RSet</strong><ul>
<li>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li>
</ul>
</li>
<li><strong>第四阶段，复制对象</strong><ul>
<li>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li>
</ul>
</li>
<li><strong>第五阶段，处理引用</strong><ul>
<li>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>G1回收过程二，并发标记过程</strong></p>
<blockquote>
<ul>
<li><strong>第一阶段，初始标记阶段</strong> <ul>
<li>标记从根节点直接可达的对象，这个阶段是STW的，并且会触发一次年轻代GC</li>
</ul>
</li>
<li><strong>第二阶段，根区域扫描（Root Region Scanning）：</strong><ul>
<li>G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象，这一过程必须在young GC之前完成</li>
</ul>
</li>
<li><strong>第三阶段，并发标记（Concurrent Marking）</strong><ul>
<li>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断，在并发标记阶段中，<strong>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</strong>，同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）</li>
</ul>
</li>
<li><strong>第四阶段，再次标记（Remark）</strong><ul>
<li>由于应用程序持续进行，需要修正上一次的标记结果，是STW的，G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）</li>
</ul>
</li>
<li><strong>第五阶段，独占清理（cleanup，STW）</strong><ul>
<li>计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域，为下阶段做铺垫，是STW的</li>
<li>这个阶段并不会实际上去做垃圾的收集</li>
</ul>
</li>
<li><strong>第六阶段，并发清理阶段</strong><ul>
<li>识别并清理完全空闲的区域</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>G1回收过程三：混合回收</strong></p>
<blockquote>
<p>​    当越来越多的对象晋升到老年代oldregion时，为了避免堆内存被耗尽,虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个OldGC，除了回收整个Young Region,还会回收一部分的old Region。这里需要注意:<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed cc并不是Full GC。</p>
<p><img src="/2021/04/05/jvm/90.png" alt="image-20210424131050267"></p>
<ul>
<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收。</li>
<li>混合回收的回收集（Collection Set)包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li>
<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li>
<li>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li>
</ul>
</blockquote>
<p><strong>G1回收可选过程四：Full GC</strong></p>
<blockquote>
<ul>
<li>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会<strong>停止应用程序的执行（Stop-The-World）</strong>，使用<strong>单线程</strong>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</li>
<li>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢?比如<strong>堆内存太小</strong>，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</li>
<li>导致G1Full GC的原因可能有两个：<ul>
<li>Evacuation的时候没有足够的to-space来存放晋升的对象</li>
<li>并发处理过程完成之前空间耗尽</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>G1回收过程：补充</strong></p>
<blockquote>
<p>​    从oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而<strong>选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）</strong>中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
</blockquote>
<p><strong>G1回收器优化建议：</strong></p>
<blockquote>
<ul>
<li><strong>年轻代大小：</strong><ul>
<li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖暂停时间目标</li>
</ul>
</li>
<li><strong>暂停时间目标不要太过严苛</strong><ul>
<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>
<li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛，目标太过严苛表示你愿意承受更多的垃圾回收的开销，而这些会直接影响到吞吐量</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="8，垃圾回收器总结"><a href="#8，垃圾回收器总结" class="headerlink" title="8，垃圾回收器总结"></a>8，垃圾回收器总结</h4><p><img src="/2021/04/05/jvm/91.png" alt="image-20210424133711594"></p>
<p><img src="/2021/04/05/jvm/78.png" alt="image-20210423214231958"></p>
<p><strong>GC的发展阶段：</strong></p>
<p><code>Serial ==&gt; Parallel（并行） ==&gt; CMS（并发） ==&gt; G1 ==&gt; ZGC</code></p>
<p><strong>怎么选择垃圾回收器？</strong></p>
<blockquote>
<ul>
<li>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升</li>
<li>怎么选择垃圾收集器<ul>
<li>优先调整堆的大小让JVM自适应完成</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核，单机程序，并且没有停顿时间的要求，串行收集器</li>
<li>如果是多CPU，需要高吞吐量，允许停顿时间超过1秒，选择并行或者JVM自己选择</li>
<li>如果是多CPU，追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li>
<li>官方推荐G1，性能高，现在互联网的项目，基本都是使用G1</li>
</ul>
</li>
<li>最后需要明确的一点：<ul>
<li>没有最好的收集器，更没有万能的收集器</li>
<li>调优永远是针对特定场景，特定需求，不存在一劳永逸的收集器</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="9，GC日志分析"><a href="#9，GC日志分析" class="headerlink" title="9，GC日志分析"></a>9，GC日志分析</h4><p><strong>内存分配与垃圾回收的参数列表：</strong></p>
<blockquote>
<ul>
<li><p><code>-XX:+PrintGC</code>：输出GC日志。类似：<code>-verbose:gc</code></p>
<p><img src="/2021/04/05/jvm/92.png" alt="image-20210424135725991"></p>
</li>
<li><p><code>-XX:+PrintGCDetails</code>：输出GC的详细日志</p>
<p><img src="/2021/04/05/jvm/93.png" alt="image-20210424135819734"></p>
</li>
<li><p><code>-XX:+PrintGCTimeStamps</code>：输出GC的时间戳（以基准时间的形似）</p>
</li>
<li><p><code>-XX:+PrintGCDateStamps</code>：输出GC的时间戳（以日期的形式，如2021-04-24T13:55:12.234+0800）</p>
<p><img src="/2021/04/05/jvm/94.png" alt="image-20210424135857363"></p>
</li>
<li><p><code>-XX:+PrintHeapAtGC</code>：在进行GC的前后打印出堆的信息</p>
</li>
<li><p><code>-Xloggc:../logs/gc.log</code>：日志文件的输出路径</p>
</li>
</ul>
</blockquote>
<p><strong>日志补充说明</strong>：</p>
<blockquote>
<ul>
<li>“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，如果有“Full”则说明GC发生了“Stop-The-World”</li>
<li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</li>
<li>使用ParNew收集器在新生代的名字会变成“[ParNew”，意思是“Parallel New Generation”</li>
<li>使用Parallel Scavenge收集器在新生代的名字是“[PSYoungGen”</li>
<li>老年代的收集和新生代道理一样，名字也是收集器决定的</li>
<li>使用G1收集器的话，会显示“garbage-first heap”</li>
<li><strong>Allocation Failture</strong>：表名本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了</li>
<li><strong>[PSYoungGen：5986K——》696K（8704K）]5986K——》704K（9216K）</strong><ul>
<li>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li>
<li>括号外：GC回收前年轻代和老年代大小，回收后大小（年轻代和老年代总大小）</li>
</ul>
</li>
<li>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时，由于多核的原因，时间总和可能会超过real时间</li>
</ul>
<p><img src="/2021/04/05/jvm/95.png" alt="image-20210424141016603"></p>
</blockquote>
<p><strong>Monitor GC日志分析：</strong></p>
<p><img src="/2021/04/05/jvm/96.png" alt="image-20210424141119962"></p>
<p><strong>Full GC日志分析</strong>：</p>
<p><img src="/2021/04/05/jvm/97.png" alt="image-20210424141223770"></p>
<p><strong>日志分析工具</strong>：</p>
<blockquote>
<ul>
<li><strong>GCViewer</strong></li>
<li><strong>GCEasy</strong></li>
<li>GCHisto</li>
<li>GCLogViewer</li>
<li>Hpjmeter</li>
<li>garbagecat</li>
</ul>
</blockquote>
<h4 id="10，垃圾回收器的新发展"><a href="#10，垃圾回收器的新发展" class="headerlink" title="10，垃圾回收器的新发展"></a>10，垃圾回收器的新发展</h4><blockquote>
<ul>
<li>GC仍然处于飞速发展之中，目前的默认选项<strong>G1 GC在不断的进行改进</strong>，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK 10以后，Full GC已经是并行运行，在很多场景下，其表现还略优于Parallel GC的并行Full GC实现。</li>
<li>即使是Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以<strong>随着云计算的兴起，在Serverless等新的应用场景下，Serial GC找到了新的舞台。</strong></li>
<li>比较不幸的是CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除。</li>
</ul>
</blockquote>
<p><img src="/2021/04/05/jvm/98.png" alt="image-20210424142032282"></p>
<p><img src="/2021/04/05/jvm/99.png" alt="image-20210424142158787"></p>
<h2 id="JVM中篇——字节码与类加载篇"><a href="#JVM中篇——字节码与类加载篇" class="headerlink" title="JVM中篇——字节码与类加载篇"></a>JVM中篇——字节码与类加载篇</h2><h3 id="一，Class文件结构"><a href="#一，Class文件结构" class="headerlink" title="一，Class文件结构"></a>一，Class文件结构</h3><h4 id="1，概述："><a href="#1，概述：" class="headerlink" title="1，概述："></a>1，概述：</h4><ul>
<li><p><strong>字节码文件的跨平台性</strong></p>
<ul>
<li><strong>Java语言：跨平台的语言（write once，run anywhere）</strong><ul>
<li>当Java源代码成功编译成字节码后，如果想在不同的平台上面运行，则无须再次编译</li>
<li>跨平台似乎已经快成为一门语言必选的特性</li>
</ul>
</li>
<li><strong>Java虚拟机：跨语言的平台</strong><ul>
<li>Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联。无论使用何种语言进行软件开发，只要能将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行。可以说，统一而强大的Class文件结构，就是Java虚拟机的基石，桥梁</li>
<li><img src="/2021/04/05/jvm/100.png" alt="image-20210518211703146"></li>
<li>所有的JVM全部遵守Java虚拟机规范，也就是说所有的JVM环境都是一样的，这样一来字节码文件可以在各种JVM上运行</li>
</ul>
</li>
<li><strong>想要让一个Java程序正确地运行在JVM中，Java源码就必须要被编译为符合JVM规范的字节码</strong><ul>
<li><strong>前端编译器的主要任务</strong>就是负责将符合Java语法规范的Java代码转换为符合JVM规范的字节码文件</li>
<li>javac是一种能够将Java源码编译为字节码的前端编译器</li>
<li>javac编译器在将Java源码编译为一个有效的字节码文件过程中经历了4个步骤，分别是<strong>词法解析，语法解析，语义解析以及生成字节码</strong></li>
<li><img src="/2021/04/05/jvm/101.png" alt="image-20210518212255322"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Java的前端编译器</strong></p>
<ul>
<li><p>Java源代码的编译结果是字节码，那么肯定需要有一种编译器能够将Java源码编译为字节码，承担这个重要责任的就是配置在path环境变量中的<strong>javac编译器</strong>，javac是一种能够将Java源码编译为字节码的<strong>前端编译器</strong></p>
</li>
<li><p>除了javac之外，还有一种内置在Eclipse中的ECJ（Eclipse Compiler for Java）编译器。和Javac的全量式编译不同，ECJ是一种增量式编译器</p>
<ul>
<li>在Eclipse中，当开发人员编写完代码中，使用“Ctrl+S”快捷键时，ECJ编译器所采取的的编译方案是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此ECJ的编译效率会比javac更加迅速和高效，当然编译质量和javac相比大致还是一样的</li>
<li>ECJ不仅是Eclipse的默认内置前端编译器，在Tomcat中同样也是使用ECJ编译器来编译JSP文件，由于ECJ编译器是采用GPLv2的开源协议进行源代码公开，所以，大家可以登录eclipse官网下载ECJ编译器的源码进行二次开发。</li>
<li>默认情况下，IntelliJ IDEA使用javac编译器（还可以自己设置为AspectJ编译器ajc）</li>
<li>前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责</li>
</ul>
</li>
</ul>
</li>
<li><p>透过字节码指令看代码细节</p>
<ul>
<li><p>示例一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Integer x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">    System.out.println(x == y);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    Integer i1 = <span class="number">10</span>;</span><br><span class="line">    Integer i2 = <span class="number">10</span>;</span><br><span class="line">    System.out.println(i1 == i2);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    Integer i3 = <span class="number">128</span>;</span><br><span class="line">    Integer i4 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i3 == i4);<span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例二</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">"hello"</span>) + <span class="keyword">new</span> String(<span class="string">"world"</span>);</span><br><span class="line">    String str = <span class="string">"helloworld"</span>;</span><br><span class="line">    System.out.println(str == str1);<span class="comment">//false</span></span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">"helloworld"</span>);</span><br><span class="line">    System.out.println(str == str2);<span class="comment">//false </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例三</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员变量（非静态的）的赋值过程：1️⃣ 默认初始化 2️⃣ 显示初始化 / 代码块中初始化 3️⃣ 构造器中初始化 4️⃣ 有了对象之后，可以“对象.属性”或“对象.方法”的方式对成员变量进行赋值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        x = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father.x = "</span>+ x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        x = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son.x = "</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sontest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Father f = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(f.x);</span><br><span class="line">        <span class="comment">//Son.x = 0</span></span><br><span class="line">        <span class="comment">//Son.x = 30</span></span><br><span class="line">        <span class="comment">//20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
<h4 id="2，Class文件"><a href="#2，Class文件" class="headerlink" title="2，Class文件"></a>2，Class文件</h4><ul>
<li>字节码文件里是什么？<ul>
<li>源代码经过编译器编译之后便会生成一个字节码文件，字节码是一种二进制的类文件，它的内容是JVM的指令，而不像C，C++经由编译器直接生成机械码</li>
</ul>
</li>
<li>什么是字节码指令（byte code）？<ul>
<li>Java虚拟机的指令由一个字节长度的，代表着某种特定操作含义的操作码（opcode）以及跟随其后的零至多个代表此操作所需参数的操作数（operand）所构成。虚拟机中许多指令并不包括操作数，只有一个操作码</li>
</ul>
</li>
<li>如何解读供虚拟机解释执行的二进制字节码？<ul>
<li>方式一：一个一个二进制的看。这里用的Notepad++，需要安装一个HEX-Editor插件，或者使用Binary Viewer</li>
<li>方式二：使用javap指令：jdk自带的反解析工具</li>
<li>方式三：使用IDEA插件，jclasslib或jclasslib bytecode viewer客户端工具（可视化更好）</li>
</ul>
</li>
</ul>
<h4 id="3，Class文件结构"><a href="#3，Class文件结构" class="headerlink" title="3，Class文件结构"></a>3，Class文件结构</h4><blockquote>
<ul>
<li><p>Class类的本质：</p>
<ul>
<li>任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，Class文件实际上它并不一定以磁盘文件的形式存在。Class文件是一组以8位字节为基础单温的二进制流。</li>
</ul>
</li>
<li><p>Class文件格式：</p>
<ul>
<li>Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在其中的数据项，无论是字节顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</li>
</ul>
</li>
<li><p>Class文件格式采用一种类似于C语言结构体的方式进行数据存储，这汇总结构中只有两种数据类型：无符号数和表</p>
<ul>
<li>无符号数属于基本的数据类型，以u1，u2，u4，u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数，无符号数可以用来描述数字，索引引用，数量值或者按照UTF-8编码构成字符串值。</li>
<li>表是由多个无符号或者其他表作为数据项构造的复合数据类型，所有表都习惯性地以“_info”结尾，表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明</li>
</ul>
</li>
<li><p>Class文件结构总体如下：</p>
<ul>
<li><p>魔数</p>
</li>
<li><p>Class文件版本</p>
</li>
<li><p>常量池</p>
</li>
<li><p>访问标志</p>
</li>
<li><p>类索引，父类索引，接口索引集合</p>
</li>
<li><p>字段表集合</p>
</li>
<li><p>方法表集合</p>
</li>
<li><p>属性表集合</p>
</li>
<li><pre><code class="java">ClassFile{
    u4                 magic;
    u2                minor_version;
    u2                major_version;
    u2                constant_pool_count;
    cp_info            constant_pool[constant_pool_count-<span class="number">1</span>];
    u2                access_flags;
    u2                 this_class;
    u2                super_class;
    u2                interfaces_count;
    u2                interfaces[interfaces_count];
    u2                fields_count;
    field_info        fields[fields_count];
    u2                methods_count;
    method_info        methods[methods_count];
    u2                attributes_count;
    attribute_info    attributes[attributes_count];
}
&lt;!--￼<span class="number">47</span>--&gt;
Error：A JNI error has occurred,please check your installation and <span class="keyword">try</span> again
Exception in thread <span class="string">"main"</span> java.lang.ClassFormatError:Incompatible magic value <span class="number">1885430635</span> in <span class="class"><span class="keyword">class</span> <span class="title">file</span> <span class="title">StringTest</span></span>
<span class="class"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意改动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### b，Class文件版本号</span><br><span class="line"></span><br><span class="line">- 紧接着魔数的4个字节存储的是Class文件的版本号，同样也是4个字节。第5个和第6个字节所代表的含义就是编译的副版本号minor_version，而第7个和第8个字节就是编译的主版本号major_version</span><br><span class="line"></span><br><span class="line">- 他们共同构成了class文件的格式版本号。譬如某个Class文件的主版本号为M，副版本号为m，那么这个Class文件的格式版本号就确定为M.m</span><br><span class="line"></span><br><span class="line">- 版本号和Java编译器的对应关系如下表：</span><br><span class="line"></span><br><span class="line">  | 主版本（十进制） | 副版本（十进制） | 编译器版本 |</span><br><span class="line">  | ---------------- | ---------------- | ---------- |</span><br><span class="line">  | 45               | 3                | 1.1        |</span><br><span class="line">  | 46               | 0                | 1.2        |</span><br><span class="line">  | 47               | 0                | 1.3        |</span><br><span class="line">  | 48               | 0                | 1.4        |</span><br><span class="line">  | 49               | 0                | 1.5        |</span><br><span class="line">  | 50               | 0                | 1.6        |</span><br><span class="line">  | 51               | 0                | 1.7        |</span><br><span class="line">  | 52               | 0                | 1.8        |</span><br><span class="line">  | 53               | 0                | 1.9        |</span><br><span class="line">  | 54               | 0                | 1.10       |</span><br><span class="line">  | 55               | 0                | 1.11       |</span><br><span class="line"></span><br><span class="line">- Java的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1</span><br><span class="line"></span><br><span class="line">- **不同版本的Java编译器的Class文件对应的版本是不一样的，目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件，否则JVM会抛出&#96;java.lang.UnsupportedClassVersionError&#96;异常（向下兼容）**</span><br><span class="line"></span><br><span class="line">- 在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生，因此，需要我们在开发时，特别注意开发编译的JDK版本和生产环境中JDK版本是否一致。</span><br><span class="line"></span><br><span class="line">  - 虚拟机JDK版本为1.k（k &gt;&#x3D; 2）时，对应的Class文件格式版本号的范围45.0 ~ 44+k.0（含两端）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### c，常量池：存放所有常量</span><br><span class="line"></span><br><span class="line">&gt; - 常量池是Class文件中内容最为丰富的区域之一，常量池对于Class文件中字段和方法解析也有着至关重要的作用</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 随着Java虚拟机的不断发展，常量池的内容也日渐丰富，可以说，常量池是整个Class文件的基石。</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></span>
<span class="class"><span class="title">cp_info</span></span>{
  u1        tag;
  u1        info[];
}
&lt;!--￼<span class="number">49</span>--&gt;</code></pre>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="g，方法表集合"><a href="#g，方法表集合" class="headerlink" title="g，方法表集合"></a>g，方法表集合</h5><blockquote>
<p>methods：指向常量池索引集合，它完整描述了每个方法的签名</p>
<ul>
<li>在字节码文件中，<strong>每一个method_info项都对应着一个类或者接口中的方法信息</strong>，比如方法的访问修饰符（public，private或protected）,方法的返回值类型以及方法的参数信息等</li>
<li>如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来</li>
<li>一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现有编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如；类（接口）初始化方法<code>&lt;clinit&gt;()</code>和实例初始化方法<code>&lt;init&gt;()</code>）</li>
<li>使用注意事项：<ul>
<li>在Java语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名值中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中</li>
<li>也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p><strong>methods_count（方法计数器）</strong></p>
<blockquote>
<ul>
<li>methods_count的值表示当前class文件methods表的成员个数，使用两个字节来表示</li>
<li>methods表中每个成员都是method_info结构</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>methods[]（方法表）</strong></p>
<blockquote>
<ul>
<li><p>methods表中的每个成员都必须是一个method_info结构，用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access__flags项既没有设置ACC_NATIVE标志也没有设置ACC_ABSTRACT标志，那么该结构中也对应包含实现这个方法所用的Java虚拟机指令。</p>
</li>
<li><p>method_info结构可以表示类和接口中定义的所有方法，包括实例方法，类方法，实例初始化方法和类或接口初始化方法</p>
</li>
<li><p>方法表的而机构实际跟字段表是一样的，方法表结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>方法名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>方法表访问标志</strong></p>
<blockquote>
<p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p>
<table>
<thead>
<tr>
<th>标记名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，方法可以从包外访问</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，方法只能本类中访问</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态方法</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>final，方法不能被重写（覆盖）</td>
</tr>
<tr>
<td>ACC_SYNCHRONIZED</td>
<td>0x0020</td>
<td>synchronized，方法由管程同步</td>
</tr>
<tr>
<td>ACC_BRIDGE</td>
<td>0x0040</td>
<td>bridge，方法由编译器产生</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<h5 id="h，属性表集合（attributes）"><a href="#h，属性表集合（attributes）" class="headerlink" title="h，属性表集合（attributes）"></a>h，属性表集合（attributes）</h5><blockquote>
<ul>
<li>方法表集合之后的属性表集合，<strong>指的是class文件所携带的辅助信息</strong>，比如该class文件的源文件的名称，以及任何带有RetentionPolicy.CLASS或者RetentionPolicy.RUNTIME的注解，这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，<strong>一般无需深入了解</strong></li>
<li>此外，字段表，方法表都可以有自己的属性表，用于描述某些场景专业的信息</li>
<li>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性细腻，但Java虚拟机它运行时会忽略掉他不认识的属性</li>
</ul>
</blockquote>
<ul>
<li><strong>attributes_count（属性计数器）</strong><ul>
<li>attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是一个attribute_info结构</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>attributes[]（属性表）</strong></p>
<blockquote>
<p>属性表的每个项的值必须是attribute_info结构，属性表的结构比较灵活，各种不同的属性只要满足以下结构即可</p>
</blockquote>
<ul>
<li><p><strong>属性的通用格式：</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
<td>属性表</td>
</tr>
</tbody></table>
<ul>
<li>即只需要说明属性的名称以及占用位数的长度即可，属性表具体的结构可以去自定义。</li>
</ul>
</li>
<li><p><strong>属性类型</strong></p>
<ul>
<li><p>属性表实际上可以有很多类型，上面看到的Code属性只是其中一种，java8里面定义了23种属性；下面这些是虚拟机中预定义的属性</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>方法表</td>
<td>Java代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final关键字定义的常量池</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类、方法、字段表</td>
<td>被声明为deprecated的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EnclosingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td>InnerClass</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code属性</td>
<td>Java源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code属性</td>
<td>方法的局部变量描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code属性</td>
<td>JDK1.6中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配</td>
</tr>
<tr>
<td>Signature</td>
<td>类，方法表，字段表</td>
<td>用于支持泛型情况下的方法签名</td>
</tr>
<tr>
<td>SourceFile</td>
<td>类文件</td>
<td>记录源文件名称</td>
</tr>
<tr>
<td>SourceDebugExtension</td>
<td>类文件</td>
<td>用于存储额外的调试信息</td>
</tr>
<tr>
<td>Syothetic</td>
<td>类，方法表，字段表</td>
<td>标志方法或字段为编泽器自动生成的</td>
</tr>
<tr>
<td>LocalVariableTypeTable</td>
<td>类</td>
<td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations</td>
<td>类，方法表，字段表</td>
<td>为动态注解提供支持</td>
</tr>
<tr>
<td>RuntimelnvisibleAnnotations</td>
<td>类，方法表，字段表</td>
<td>用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td>RuntimeVisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法</td>
</tr>
<tr>
<td>RuntirmelnvisibleParameterAnniotation</td>
<td>方法表</td>
<td>作用与RuntimelnvisibleAnnotations属性类似，作用对象哪个为方法参数</td>
</tr>
<tr>
<td>AnnotationDefauit</td>
<td>方法表</td>
<td>用于记录注解类元素的默认值</td>
</tr>
<tr>
<td>BootstrapMethods</td>
<td>类文件</td>
<td>用于保存invokeddynanic指令引用的引导方式限定符</td>
</tr>
</tbody></table>
</li>
<li><p><strong>部分属性详解：</strong></p>
<blockquote>
<p>1️⃣<strong>ConstantValue属性</strong></p>
<p>ConstantValue属性表示一个常量字段的值，位于field_info结构的属性表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line"> u2 attribute_name_index；</span><br><span class="line"> u4 attribute_length；</span><br><span class="line"> u2 constantvalue_index；</span><br><span class="line"> <span class="comment">//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。</span></span><br><span class="line"> <span class="comment">//（例如，值是long型的，在常量池中便是CONSTANT_Long）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2️⃣<strong>Deprecated 属性</strong></p>
<p>Deprecated 属性是在JDK1.1为了支持注释中的关键词@deprecated而引入的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deprecated_ attribute&#123;</span><br><span class="line"> u2 attribute_name_ index; </span><br><span class="line"> u4 attribute_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3️⃣<strong>Code属性</strong></p>
<p>Code属性就是存放方法体里面的代码，但是，并非所有方法表都有Code属性，像接口或者抽象方法，他们没有具体的方法体，因此也就不会有Code属性了，Code属性表的结构，如下图：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>1</td>
<td>操作数栈深度的最大值</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>1</td>
<td>局部变量表所需的存续空间</td>
</tr>
<tr>
<td>u4</td>
<td>code_length</td>
<td>1</td>
<td>字节码指令的长度</td>
</tr>
<tr>
<td>u1</td>
<td>code</td>
<td>code_length</td>
<td>存储字节码指令</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>1</td>
<td>异常表长度</td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td>exception_length</td>
<td>异常表</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
<td>属性集合计数器</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
<td>属性集合</td>
</tr>
</tbody></table>
<p>可以看到：Code属性表的前两项跟属性表是一致的，即Code属性表遵循属性表的结构，后面那些则是他自定义的结构</p>
<p>4️⃣InnerClasses属性</p>
<p>为了方便说明特别定义一个表示类或接口的Class格式为C，如果C的常量池中包含某个CONSTANT_Class_info成员，且这个成员所表示的类或接口不属于任何一个包，那么C的ClassFile结构的属性表中就必须含有对应的InnerClasses属性，InnerClasses属性是在JDK1.1中为了支持内部类和内部接口而引入的，位于ClassFile结构的属性表</p>
<p>5️⃣LineNumberTable属性</p>
<ul>
<li><p>LineNumberTalbe属性是可选变长属性，位于Code结构的属性表</p>
</li>
<li><p>LineNumberTable属性是用来描述Java源码行号与字节码行号之间的对应关系，这个属性可以用来在调试的时候定位代码执行的行数</p>
<ul>
<li>start_pc：即字节码行号</li>
<li>line_number：即Java源代码行号</li>
</ul>
</li>
<li><p>在Code属性的属性表中，LineNumberTable属性可以按照任意顺序出现，此外，多个LineNumberTable属性可以共同表示一个行号在源文件中表示的内容，即LineNumberTable属性不需要与源文件的行一一对应</p>
</li>
<li><p>LineNumberTable属性表结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index:</span><br><span class="line">    u4 attribute_length:</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">    	u2 start_pc:</span><br><span class="line">        u2 line_number:</span><br><span class="line">    &#125; line_number_table[line_number_table_length]:</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>6️⃣LocalVariableTable属性</p>
<p>LocalVariableTable是可选变长属性，位于Code属性的属性表中，它被调试器用于确定方法在执行过程中局部变量的信息</p>
<ul>
<li><p>在Code属性的属性表中，LocalVariableTable属性可以按照任意顺序出现。Code属性中的每个局部变量最多只能有一个LocalVariableTable属性</p>
<ul>
<li>start pc + length表示这个变量在字节码中的生命周期起始和结束的偏移位置（this生命周期从头0到结尾10）</li>
<li>index就是这个变量在局部变量表中的槽位（槽位可复用）</li>
<li>name就是变量名称</li>
<li>Descriptor表示局部变量类型描述</li>
</ul>
</li>
<li><p>LocalVariableTable属性表结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index:</span><br><span class="line">    u4 attribute_length:</span><br><span class="line">    u2 local_variable_table_length:</span><br><span class="line">    &#123;</span><br><span class="line">    	u2 start_pc:</span><br><span class="line">        u2 length:</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length]:</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>7️⃣Signature属性</p>
<p>Signature属性是可选的定长属性，位于ClassFile，field_info或method_info结构的属性表中。在Java语言中，任何类，接口，初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息</p>
<p>8️⃣SourceFile属性</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
<td>属性表</td>
</tr>
<tr>
<td>可以看到，其总长度总是固定的8个字节</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>9️⃣其他属性</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="i，最终Class文件解析结果"><a href="#i，最终Class文件解析结果" class="headerlink" title="i，最终Class文件解析结果"></a>i，最终Class文件解析结果</h5><p><img src="/2021/04/05/jvm/104.png" alt="img"></p>
<h4 id="4，使用javap指令解析class文件"><a href="#4，使用javap指令解析class文件" class="headerlink" title="4，使用javap指令解析class文件"></a>4，使用javap指令解析class文件</h4><h5 id="a，解析字节码中的作用："><a href="#a，解析字节码中的作用：" class="headerlink" title="a，解析字节码中的作用："></a>a，解析字节码中的作用：</h5><blockquote>
<ul>
<li>通过反编译生成的字节码文件，我们可以深入的了解Java代码的工作机制，但是，自己分析类文件结构太麻烦了！除了使用第三方的jclasslib工具之外，oracle官方也提供了工具javap</li>
<li>javap是JDK自带的反解析工具，它的作用就是根据class字节码文件，反解析出当前类对应的code区（字节码指令），局部变量表，异常表和代码行偏移量映射表，常量池等信息</li>
<li>通过局部变量表，我们可以查看局部变量表的作用域范围，所在槽位等信息，甚至可以看到槽位复用等信息。</li>
</ul>
</blockquote>
<h5 id="b，javac-g操作"><a href="#b，javac-g操作" class="headerlink" title="b，javac -g操作"></a>b，javac -g操作</h5><blockquote>
<ul>
<li>解析字节码文件得到的信息中，有些信息（如局部变量表，指令和代码行偏移量映射表，常量池中方法的参数名称等等）需要在使用javac编译成class文件时，指定参数才能输出。</li>
<li>比如，你直接javac xx.java，就不会在生成对应的局部变量表等信息，如果你使用javac -g xx.java就可以生成所有相关信息，如果你使用的eclipse或IDEA，则默认情况下，eclipse，IDEA在编译时会帮你生成局部变量表，指令和代码行偏移量映射表等信息的。</li>
</ul>
</blockquote>
<h5 id="c，javap的用法"><a href="#c，javap的用法" class="headerlink" title="c，javap的用法"></a>c，javap的用法</h5><ul>
<li><p>javap的用法格式：<code>javap &lt;options&gt; &lt;classes&gt;</code>：其中，classes就是你要反编译的class文件</p>
</li>
<li><p>Javap的命令参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-help --help -?			输出此用法消息</span><br><span class="line">-version				版本信息，其实是当前javap所在jdk的版本信息，不是class在哪个jdk下生成的</span><br><span class="line">——————————————————————————————————————————————————————————————————————</span><br><span class="line">-public					仅显示公共类和成员</span><br><span class="line">-protected				显示受保护的&#x2F;公共类和成员</span><br><span class="line">-p -private				显示所有类和成员</span><br><span class="line">-package				显示程序包&#x2F;受保护的&#x2F;公共类和成员（默认）</span><br><span class="line">-sysinfo				显示正在处理的类的系统信息（路径，大小，日期，MD5散列，源文件名）</span><br><span class="line">-constants				显示静态最终常量</span><br><span class="line">————————————————————————————————————————————————————————————————————————</span><br><span class="line">-s						输出内部类型签名</span><br><span class="line">-l						输出行号和本地变量表		&#x2F;&#x2F;一般常用的三个选项之一</span><br><span class="line">-c						对代码进行反汇编			&#x2F;&#x2F;一般常用的三个选项之一</span><br><span class="line">-v -verbose				输出附加信息（包括行号，本地变量表，反汇编等详细信息）	&#x2F;&#x2F;一般常用的三个选项之一</span><br><span class="line">—————————————————————————————————————————————————————————————————————————</span><br><span class="line">-classpaht &lt;path&gt;		指定查找用户类文件的位置</span><br><span class="line">-cp &lt;path&gt;				指定查找用户类文件的位置</span><br></pre></td></tr></table></figure>
</li>
<li><p>javap使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">public</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        String url = <span class="string">"www.atguigu.com"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        info = <span class="string">"java"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JavapTest</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        System.out.println(info + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>javap -public JavapTest.class 显示公共信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"JavapTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.JavapTest();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>javap -protected JavapTest.class 显示受保护的/公共类和成员</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"JavapTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.JavapTest();</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>javap -p(或-private)JavapTest.class 显示所有类和成员（大于private的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"JavapTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">boolean</span> flag;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.JavapTest();</span><br><span class="line">  <span class="keyword">private</span> com.atguigu.java1.JavapTest(<span class="keyword">boolean</span>);</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>javap -package JavapTest.class 显示程序包/受保护的/公共类和成员（默认）,非私有的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"JavapTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> flag;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.JavapTest();</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>javap -sysinfo JavapTest.class 显示正在处理的类的系统信息（路径，大小，日期，MD5 散列，源文件名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/<span class="number">925404</span>/JavaProjects/JVM_study/src/com/dsh/jvmp2/chapter01/java1/JavapTest<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2020-9-21</span>; size <span class="number">1358</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">526</span>b4a845e4d98180438e4c5781b7e88</span><br><span class="line">  Compiled from <span class="string">"JavapTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> flag;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.JavapTest();</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>javap -constants JavapTest.class     与前面命令的主要区别，常量值会显示出来<code>COUNTS = 1;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"JavapTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> flag;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.JavapTest();</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>-s 输出内部类型签名(描述符)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"JavapTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> flag;</span><br><span class="line">    descriptor: Z</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">    descriptor: C</span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS;</span><br><span class="line">    descriptor: I</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.JavapTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()C</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>-l 输出行号和本地变量表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"JavapTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> flag;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.JavapTest();</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">18</span>: <span class="number">4</span></span><br><span class="line">      line <span class="number">22</span>: <span class="number">10</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">30</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line">          <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     i   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>;</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">33</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">36</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">37</span>: <span class="number">3</span></span><br><span class="line">      line <span class="number">38</span>: <span class="number">30</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line">          <span class="number">3</span>      <span class="number">28</span>     <span class="number">1</span>     i   I</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">16</span>: <span class="number">3</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>-c 对代码进行反汇编</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"JavapTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.JavapTest();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       5: ldc           #2                  // String java</span><br><span class="line">       7: putfield      #3                  // Field info:Ljava/lang/String;</span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: getfield      #5                  // Field num:I</span><br><span class="line">       <span class="number">4</span>: iload_1</span><br><span class="line">       <span class="number">5</span>: iadd</span><br><span class="line">       <span class="number">6</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: getfield      #6                  // Field gender:C</span><br><span class="line">       <span class="number">4</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">2</span>: istore_1</span><br><span class="line">       3: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       6: new           #8                  // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">9</span>: dup</span><br><span class="line">      10: invokespecial #9                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      <span class="number">13</span>: aload_0</span><br><span class="line">      14: getfield      #3                  // Field info:Ljava/lang/String;</span><br><span class="line">      17: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      <span class="number">20</span>: iload_1</span><br><span class="line">      21: invokevirtual #11                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #12                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      27: invokevirtual #13                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #14                 // String www.atguigu.com</span><br><span class="line">       <span class="number">2</span>: astore_0</span><br><span class="line">       <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>-v -verbose 输出附加信息（包括行号、本地变量表、反汇编等详细信息），<strong>-v是最全的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/dongshuhuan/JavaProjects/JVM_study/src/com/dsh/jvmp2/chapter01/java1/JavapTest<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2020-9-21</span>; size <span class="number">1358</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">526</span>b4a845e4d98180438e4c5781b7e88</span><br><span class="line">  Compiled from <span class="string">"JavapTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">JavapTest</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #16.#46        // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = String             #47            // java</span><br><span class="line">   #3 = Fieldref           #15.#48        // com/atguigu/java1/JavapTest.info:Ljava/lang/String;</span><br><span class="line">   #4 = Fieldref           #15.#49        // com/atguigu/java1/JavapTest.flag:Z</span><br><span class="line">   #5 = Fieldref           #15.#50        // com/atguigu/java1/JavapTest.num:I</span><br><span class="line">   #6 = Fieldref           #15.#51        // com/atguigu/java1/JavapTest.gender:C</span><br><span class="line">   #7 = Fieldref           #52.#53        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #8 = Class              #54            // java/lang/StringBuilder</span><br><span class="line">   #9 = Methodref          #8.#46         // java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">  #10 = Methodref          #8.#55         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #11 = Methodref          #8.#56         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">  #12 = Methodref          #8.#57         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">  #13 = Methodref          #58.#59        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #14 = String             #60            // www.atguigu.com</span><br><span class="line">  #15 = Class              #61            // com/atguigu/java1/JavapTest</span><br><span class="line">  #16 = Class              #62            // java/lang/Object</span><br><span class="line">  #17 = Utf8               num</span><br><span class="line">  #18 = Utf8               I</span><br><span class="line">  #19 = Utf8               flag</span><br><span class="line">  #20 = Utf8               Z</span><br><span class="line">  #21 = Utf8               gender</span><br><span class="line">  #22 = Utf8               C</span><br><span class="line">  #23 = Utf8               info</span><br><span class="line">  #24 = Utf8               Ljava/lang/String;</span><br><span class="line">  #25 = Utf8               COUNTS</span><br><span class="line">  #26 = Utf8               ConstantValue</span><br><span class="line">  #27 = Integer            1</span><br><span class="line">  #28 = Utf8               &lt;init&gt;</span><br><span class="line">  #29 = Utf8               ()V</span><br><span class="line">  #30 = Utf8               Code</span><br><span class="line">  #31 = Utf8               LineNumberTable</span><br><span class="line">  #32 = Utf8               LocalVariableTable</span><br><span class="line">  #33 = Utf8               this</span><br><span class="line">  #34 = Utf8               Lcom/atguigu/java1/JavapTest;</span><br><span class="line">  #35 = Utf8               (Z)V</span><br><span class="line">  #36 = Utf8               methodPrivate</span><br><span class="line">  #37 = Utf8               getNum</span><br><span class="line">  #38 = Utf8               (I)I</span><br><span class="line">  #39 = Utf8               i</span><br><span class="line">  #40 = Utf8               showGender</span><br><span class="line">  #41 = Utf8               ()C</span><br><span class="line">  #42 = Utf8               showInfo</span><br><span class="line">  #43 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #44 = Utf8               SourceFile</span><br><span class="line">  #45 = Utf8               JavapTest.java</span><br><span class="line">  #46 = NameAndType        #28:#29        // "&lt;init&gt;":()V</span><br><span class="line">  #47 = Utf8               java</span><br><span class="line">  #48 = NameAndType        #23:#24        // info:Ljava/lang/String;</span><br><span class="line">  #49 = NameAndType        #19:#20        // flag:Z</span><br><span class="line">  #50 = NameAndType        #17:#18        // num:I</span><br><span class="line">  #51 = NameAndType        #21:#22        // gender:C</span><br><span class="line">  #52 = Class              #63            // java/lang/System</span><br><span class="line">  #53 = NameAndType        #64:#65        // out:Ljava/io/PrintStream;</span><br><span class="line">  #54 = Utf8               java/lang/StringBuilder</span><br><span class="line">  #55 = NameAndType        #66:#67        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #56 = NameAndType        #66:#68        // append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">  #57 = NameAndType        #69:#70        // toString:()Ljava/lang/String;</span><br><span class="line">  #58 = Class              #71            // java/io/PrintStream</span><br><span class="line">  #59 = NameAndType        #72:#73        // println:(Ljava/lang/String;)V</span><br><span class="line">  #60 = Utf8               www.atguigu.com</span><br><span class="line">  #61 = Utf8               com/atguigu/java1/JavapTest</span><br><span class="line">  #62 = Utf8               java/lang/Object</span><br><span class="line">  #63 = Utf8               java/lang/System</span><br><span class="line">  #64 = Utf8               out</span><br><span class="line">  #65 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #66 = Utf8               append</span><br><span class="line">  #67 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #68 = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #69 = Utf8               toString</span><br><span class="line">  #70 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #71 = Utf8               java/io/PrintStream</span><br><span class="line">  #72 = Utf8               println</span><br><span class="line">  #73 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">boolean</span> flag;</span><br><span class="line">    descriptor: Z</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">    descriptor: C</span><br><span class="line">    flags: ACC_PROTECTED</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="keyword">int</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.JavapTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         5: ldc           #2                  // String java</span><br><span class="line">         7: putfield      #3                  // Field info:Ljava/lang/String;</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">10</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags:</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #5                  // Field num:I</span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">30</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     i   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()C</span><br><span class="line">    flags: ACC_PROTECTED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #6                  // Field gender:C</span><br><span class="line">         <span class="number">4</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">33</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         3: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #8                  // class java/lang/StringBuilder</span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        10: invokespecial #9                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">13</span>: aload_0</span><br><span class="line">        14: getfield      #3                  // Field info:Ljava/lang/String;</span><br><span class="line">        17: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">20</span>: iload_1</span><br><span class="line">        21: invokevirtual #11                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        24: invokevirtual #12                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        27: invokevirtual #13                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">36</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">37</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">38</span>: <span class="number">30</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">28</span>     <span class="number">1</span>     i   I</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: ldc           #14                 // String www.atguigu.com</span><br><span class="line">         <span class="number">2</span>: astore_0</span><br><span class="line">         <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">3</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>组合使用</strong>：-v 不包含私有信息，所以可以使用组合方式获取更全的信息 <code>java -v -p JavapTest.class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/dongshuhuan/JavaProjects/JVM_study/src/com/dsh/jvmp2/chapter01/java1/JavapTest<span class="class">.<span class="keyword">class</span>   //字节码文件所属的路径</span></span><br><span class="line"><span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2020-9-21</span>; size <span class="number">1358</span> bytes   <span class="comment">//最后修改时间，字节码文件大小</span></span><br><span class="line">  MD5 checksum <span class="number">526</span>b4a845e4d98180438e4c5781b7e88  <span class="comment">//MD5散列值</span></span><br><span class="line">  Compiled from <span class="string">"JavapTest.java"</span>                 <span class="comment">//源文件名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">JavapTest</span>         //全类名</span></span><br><span class="line">  minor version: 0                              //副版本</span><br><span class="line">  major version: <span class="number">52</span>                             <span class="comment">//主版本</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER                  <span class="comment">//访问标识</span></span><br><span class="line">Constant pool:                                  <span class="comment">//常量池</span></span><br><span class="line">   #1 = Methodref          #16.#46        // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">  ...(中间省略一大坨)</span><br><span class="line">  #73 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  </span><br><span class="line">######################  字段表集合的信息start  ###########################</span><br><span class="line">&#123;                   <span class="comment">//字段表集合的信息</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num;  <span class="comment">//字段名</span></span><br><span class="line">    descriptor: I   <span class="comment">//字段描述符：字段的类型</span></span><br><span class="line">    flags: ACC_PRIVATE  <span class="comment">//字段的访问标识</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> flag;</span><br><span class="line">    descriptor: Z</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">    descriptor: C</span><br><span class="line">    flags: ACC_PROTECTED</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="keyword">int</span> <span class="number">1</span>        <span class="comment">//常量字段属性：ConstantValue</span></span><br><span class="line"></span><br><span class="line">####################### 字段情况end ###########################</span><br><span class="line"></span><br><span class="line">####################### 方法表集合信息start ###########################</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.JavapTest(); <span class="comment">//构造器1的信息</span></span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         5: ldc           #2                  // String java</span><br><span class="line">         7: putfield      #3                  // Field info:Ljava/lang/String;</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">10</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> com.atguigu.java1.JavapTest(<span class="keyword">boolean</span>); <span class="comment">//重载构造器</span></span><br><span class="line">    descriptor: (Z)V</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         5: ldc           #2                  // String java</span><br><span class="line">         7: putfield      #3                  // Field info:Ljava/lang/String;</span><br><span class="line">        <span class="number">10</span>: aload_0</span><br><span class="line">        <span class="number">11</span>: iload_1</span><br><span class="line">        12: putfield      #4                  // Field flag:Z</span><br><span class="line">        <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">23</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">25</span>: <span class="number">15</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">16</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line">            <span class="number">0</span>      <span class="number">16</span>     <span class="number">1</span>  flag   Z</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">28</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags:</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #5                  // Field num:I</span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">30</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     i   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()C</span><br><span class="line">    flags: ACC_PROTECTED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #6                  // Field gender:C</span><br><span class="line">         <span class="number">4</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">33</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V   <span class="comment">//方法描述符：方法的形参列表、返回值类型</span></span><br><span class="line">    flags: ACC_PUBLIC   <span class="comment">//方法的访问标识</span></span><br><span class="line">    Code:               <span class="comment">//方法的Code属性</span></span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span>    <span class="comment">//stack: 操作数栈的最大深度 </span></span><br><span class="line">                                        <span class="comment">//locals: 局部变量表的长度</span></span><br><span class="line">                                        <span class="comment">//args_size: 方法接收参数的个数</span></span><br><span class="line">   <span class="comment">//偏移量  操作码    操作数</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span>            </span><br><span class="line">         <span class="number">2</span>: istore_1                    </span><br><span class="line">         3: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #8                  // class java/lang/StringBuilder</span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        10: invokespecial #9                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">13</span>: aload_0</span><br><span class="line">        14: getfield      #3                  // Field info:Ljava/lang/String;</span><br><span class="line">        17: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">20</span>: iload_1</span><br><span class="line">        21: invokevirtual #11                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        24: invokevirtual #12                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        27: invokevirtual #13                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//行号表：指明字节码的偏移量与java源程序中代码的行号的一一对应关系</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">36</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">37</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">38</span>: <span class="number">30</span></span><br><span class="line">    <span class="comment">//局部变量表：描述内部局部变量的相关信息，这里有2个 this 和 i</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/JavapTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">28</span>     <span class="number">1</span>     i   I</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: ldc           #14                 // String www.atguigu.com</span><br><span class="line">         <span class="number">2</span>: astore_0</span><br><span class="line">         <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">3</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"JavapTest.java"</span>    <span class="comment">//附加属性: 指明当前字节码文件对应的源程序文件名</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
<h5 id="d，总结："><a href="#d，总结：" class="headerlink" title="d，总结："></a>d，总结：</h5><blockquote>
<ul>
<li>通过javap命令可以查看一个Java类反汇编得到的Class文件版本号，常量池，访问标识，变量表，指令代码行号表等等信息，不显示类索引，父类索引，接口索引集合，<code>&lt;clinit&gt;()</code>、<code>&lt;init&gt;()</code>等结构</li>
<li>通过对前面例子代码反汇编文件的简单分析，可以发现，一个方法的执行通常会涉及下面几块内存的操作：<ul>
<li>Java栈中：局部变量表，操作数栈</li>
<li>Java堆。通过对象的地址引用去操作</li>
<li>常量池</li>
<li>其他如帧数据区，方法区的剩余部分等情况，测试中没有显示出来</li>
</ul>
</li>
<li>平常，我们比较关注的是Java类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行的，可以参考官方文档查看每一个指令的含义<a href="https://docs.oracle.com/javase/specs/jvm/se7/html/jvms-6.html" target="_blank" rel="noopener">官方文档</a></li>
</ul>
</blockquote>
<h3 id="二，字节码指令集与解析举例"><a href="#二，字节码指令集与解析举例" class="headerlink" title="二，字节码指令集与解析举例"></a>二，字节码指令集与解析举例</h3><h4 id="1，概述：-1"><a href="#1，概述：-1" class="headerlink" title="1，概述："></a>1，概述：</h4><blockquote>
<ul>
<li>Java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令</li>
<li>Java 虚拟机的指令由<strong>一个字节长度</strong>的、代表着某种特定操作含义的数字（称为==操作码，Opcode==)以及跟随其后的零至多个代表此操作所需参数（称为==操作数，Operands==)而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。</li>
<li>由于限制了Java 虚拟机操作码的长度为一个字节（即0~255），这意味着指令集的操作码总数不可能超过256条。</li>
<li>熟悉虚拟机的指令对于动态字节码生成、反编译Class文件、Class文件修补都有着非常重要的价值。因此，阅读字节码作为了解Java虚拟机的基础技能，需要熟练掌握常见指令。</li>
</ul>
</blockquote>
<h5 id="a，执行模型："><a href="#a，执行模型：" class="headerlink" title="a，执行模型："></a>a，执行模型：</h5><blockquote>
<p>如果不考虑一尺昂处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	自动计算PC寄存器的值加1;</span><br><span class="line">	根据PC寄存器的指示位置，从字节码流中取出操作码;</span><br><span class="line">	if(字节码存在操作数) 从字节码流中取出操作数;</span><br><span class="line">	执行操作码所定义的操作;</span><br><span class="line">&#125;while(字节码长度&gt;0);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="b，字节码与数据类型"><a href="#b，字节码与数据类型" class="headerlink" title="b，字节码与数据类型"></a>b，字节码与数据类型</h5><blockquote>
<p>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如， iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。</p>
<p>对于大部分与数据类型相关的字节码指令，<strong>它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务</strong>：</p>
<ul>
<li><code>i</code>代表对<code>int</code>类型的数据操作</li>
<li><code>l</code>代表<code>long</code></li>
<li><code>s</code>代表<code>short</code></li>
<li><code>c</code>代表<code>char</code></li>
<li><code>f</code>代表<code>float</code></li>
<li><code>d</code>代表<code>dobule</code></li>
</ul>
<p>也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylenght指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象</p>
<p>还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的</p>
<p>大部分的指令都没有支持整数类型byte、char和 short,甚至没有任何指令支持 boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展(Sign-Extend-)为相应的int类型数据,将 boolean和char类型数据零位扩展(Zero-Extend-)为相应的int类型数据。与之类似,在处理 boolean、byte、short和char类型的数组时,也会转换为使用对应的int类型的字节码指令来处理。因此,大多数对于 boolean、byte、 short和char类型数据的操作</p>
</blockquote>
<h5 id="c，指令分类"><a href="#c，指令分类" class="headerlink" title="c，指令分类"></a>c，指令分类</h5><blockquote>
<ul>
<li>由于完全介绍和学习这些指令需要花费大量时间，为了让大家能够更快地熟悉和了解这些基本指令，这里将JVM中的字节码指令集用途大致分成9类。<ul>
<li>加载与存储指令</li>
<li>算数指令</li>
<li>类型转换指令</li>
<li>对象的创建与访问指令</li>
<li>方法调用与返回指令</li>
<li>操作数栈管理指令</li>
<li>比较控制指令</li>
<li>异常处理指令</li>
<li>同步控制指令</li>
</ul>
</li>
<li>在做值相关操作的时候：<ul>
<li>一个指令，可以从局部变量表，常量池，堆中对象，方法调用，系统调用中等取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈</li>
<li>一个指令，也可以从操作数栈中取出一到多个值（pop多次），完成赋值，加减乘除，方法传参，系统调用等等操作。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="2，加载与存储指令"><a href="#2，加载与存储指令" class="headerlink" title="2，加载与存储指令"></a>2，加载与存储指令</h4><blockquote>
<ul>
<li><p><strong>作用</strong>：</p>
<ul>
<li>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递</li>
</ul>
</li>
<li><p><strong>常用指令</strong>：</p>
<table>
<thead>
<tr>
<th>常用指令</th>
</tr>
</thead>
<tbody><tr>
<td>1，【局部变量压栈指令】将一个局部变量加载到操作数栈:xload、xload_（其中x为i、1、f、d、a， n为0到3）</td>
</tr>
<tr>
<td>2，【常量入栈指令】将一个常量加载到操作数栈：bipush，sipush，ldc，ldc_w，ldc2_w，aconst_numm，iconst_m1，iconst_ <i>，lconst_ <l>，fconst_ <f>，dconst_ <d></d></f></l></i></td>
</tr>
<tr>
<td>3，【出栈装入局部变量表指令】将一个数值从操作数栈存储到局部变量表：xstore，xstore_ <n>（其中x为i，l，f，d，a，n为0到3）；xastore（其中x为i，l，f，d，a，b，c，s）</n></td>
</tr>
<tr>
<td>4，扩充局部变量表的访问索引的指令：wide</td>
</tr>
</tbody></table>
<ul>
<li>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_ <n>）。这些指令助记符实际上代表了一组指令（例如 iload_ <n>代表了iload_0、iload_1、iload_2和iload_3这几个指令）。这几组指令都是某个带有一个操作数的通用指令（例如 iload）的特殊形式，<strong>对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中</strong>。<ul>
<li>如 iload_0：将局部变链表中索引为0位置上的数据压入操作数栈中</li>
<li>如iload 4：将局部变链表中索引为4位置上的数据压入操作数栈中</li>
</ul>
</n></n></li>
<li>除此之外，他们的语义和原生的的通用指令完全一致（例如iload_ 0的语义与操作数为0时的iload指令完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，<n>代表非负的整数，<i>代表是int类型数据，<l>代表long类型，<f>代表float类型，<d>代表double类型</d></f></l></i></n></li>
<li>操作byte、char、short和boolean类型数据时，经常用int类型的指令来表示</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="a，再谈操作数栈与局部变量表"><a href="#a，再谈操作数栈与局部变量表" class="headerlink" title="a，再谈操作数栈与局部变量表"></a>a，再谈操作数栈与局部变量表</h5><blockquote>
<ul>
<li><p><strong>操作数栈（Operand Stacks）</strong>：</p>
<ul>
<li><p>我们知道，Java字节码是Java虚拟机所使用的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的 。 在解释执行过程中，每当为Java方法分配栈桢时，Java虚拟机往往需要开辟一块额外的空间作为<strong>操作数栈，来存放计算的操作数以及返回结果</strong>。</p>
</li>
<li><p>具体来说便是：<strong>执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。</strong></p>
<p><img src="/2021/04/05/jvm/105.png" alt></p>
<ul>
<li>以加法指令iadd 为例。假设在执行该指令前，栈顶的两个元素分别为int值1和 int值2，那么iadd 指令将弹出这两个int，并将求得的和 int值3压入栈中。</li>
</ul>
<p><img src="/2021/04/05/jvm/106.png" alt></p>
<ul>
<li>由于 iadd 指令只消耗栈顶的两个元素，因此，对于离栈顶距离为2的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>局部变量表（Local Variables）</strong></p>
<ul>
<li><p>Java方法栈桢的另外一个重要组成部分则是局部变量区,<strong>字节码程序可以将计算的结果缓存在局部变量区之中</strong>。实际上，Java虚拟机将局部变量区<strong>当成一个数组</strong>,依次存放this指针(仅非静态方法),所传入的参数,以及字节码中的局部变量。</p>
</li>
<li><p>和操作数栈一样，long类型以及double类型的值将只占据两个单元，其余类型仅占据一个单元</p>
<p><img src="/2021/04/05/jvm/107.png" alt></p>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">long</span> l,<span class="keyword">float</span> f)</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        String s = <span class="string">"Hello,World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对应图示：</p>
<p><img src="/2021/04/05/jvm/108.png" alt></p>
<ul>
<li>第一个是this</li>
<li>第二个l是long型，占据两个槽位</li>
<li>第三个f是float型，占据一个槽位</li>
<li>i和s共用一个槽位</li>
</ul>
</li>
<li><p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
</li>
<li><p>在方法执行时，虚拟机使用局部变量表完成方法的传递</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="b，局部变量压栈指令"><a href="#b，局部变量压栈指令" class="headerlink" title="b，局部变量压栈指令"></a>b，局部变量压栈指令</h5><blockquote>
<ul>
<li><p><strong>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈</strong></p>
</li>
<li><p>这类指令大体可以分为：</p>
<ul>
<li>&gt; xload_<n>（x为i、l、f、d、a、n为0到3）</n></li>
<li>&gt; xload （x为i、l、f、d、a）</li>
</ul>
<p>说明：在这里，x的取值表示数据类型</p>
</li>
<li><p>指令xload_n 表示将第n个局部变量压入操作数栈，比如iload_1、fload_0、aload_0等指令，其中aload_n表示将一个对象引用压栈</p>
</li>
<li><p>指令xload通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令iload、fload等</p>
</li>
</ul>
<p><img src="/2021/04/05/jvm/109.png" alt></p>
</blockquote>
<h5 id="c，常量入栈指令："><a href="#c，常量入栈指令：" class="headerlink" title="c，常量入栈指令："></a>c，常量入栈指令：</h5><blockquote>
<p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为const系列，push系列和ldc指令</p>
<p>==指令const系列==：用于对特定的常量入栈，入栈的常量隐含在指令本身里，指令有：iconst_<i>（i从-1到5）、lconst_<l>（l从0到1）、fconst_<f>（f从0到2）、dconst_<d>（d从0到1）、aconst_null。</d></f></l></i></p>
<ul>
<li>iconst_m1将-1压入操作数栈；</li>
<li>iconst_x（x为0到5）将x压入栈；</li>
<li>lconst_0、lconst_1分别将长整数0和1压入栈；</li>
<li>fconst_0、fconst_1、fconst_2分别将浮点数0、1、2压入栈；</li>
<li>dconst_0和dconst_1分别将double型0和1压入栈；</li>
<li>aconst_null将null压入操作数栈</li>
</ul>
<p>从指令的命名上不难找出规律,指令助记符的第一个字符总是喜欢表示数据类型,i表示整数,1表示长整数,f表示浮点数,d表示双精度浮点,习惯上用a表示对象引用。如果指令隐含操作的参数,会以下划线形式给出</p>
<p>==指令push系列==：主要包括bipush和sipush。他们的区别在于接收数据类型不同，bipush接收8位整数作为参数，sipush接收16位整数，他们都将参数压入栈</p>
<p>==指令ldc系列==：如果以上指令都不能满足需求，那么可以使用万能的ldc指令，它可以接收一个8位参数，该参数指向常量池中int、float或者String索引，将指定的内容压入堆栈。 </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>常数指令</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>int（boolean，byte，char，short）</td>
<td>iconst</td>
<td>[-1,5]</td>
</tr>
<tr>
<td></td>
<td>bipush</td>
<td>[-128,127]</td>
</tr>
<tr>
<td></td>
<td>sipush</td>
<td>[-32768,32767]</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any int value</td>
</tr>
<tr>
<td>long</td>
<td>lconst</td>
<td>0,1</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any long value</td>
</tr>
<tr>
<td>float</td>
<td>fconst</td>
<td>0,1,2</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any float value</td>
</tr>
<tr>
<td>double</td>
<td>dconst</td>
<td>0,1</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any double value</td>
</tr>
<tr>
<td>reference</td>
<td>aconst</td>
<td>null</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>String literal、Class lteral</td>
</tr>
</tbody></table>
<p>举例说明一：int类型</p>
<p><img src="/2021/04/05/jvm/110.png" alt></p>
<p>举例说明二：其他类型</p>
<p><img src="/2021/04/05/jvm/111.png" alt></p>
</blockquote>
<h5 id="d，出栈装入局部变量表指令"><a href="#d，出栈装入局部变量表指令" class="headerlink" title="d，出栈装入局部变量表指令"></a>d，出栈装入局部变量表指令</h5><blockquote>
<p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值</p>
<p>这类指令主要以store的形式存在，比如xstore（x为i、l、f、d、a）、xstore_n（x为i、l、f、d、a，n为0至3）</p>
<ul>
<li>其中，指令istore_n将从操作数栈中弹出一个整数，并把他赋值给局部变量索引n位置</li>
<li>指令xstore由于没有隐含参数信息，故需要提供一个byte类型的参数类指引目标局部变量表的位置</li>
</ul>
<p>说明：</p>
<ul>
<li><strong>一般说来，类似像store这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置</strong>。但是，为了尽可能压缩指令大小，使用专门的istore_1指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有 istore_0、istore_2、istore_3，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置。</li>
<li>由于局部变量表前几个位置总是非常常用，因此<strong>这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积</strong>。如果局部变量表很大，需要存储的槽位大于3，那么可以使用istore指令，外加一个参数，用来表示需要存放的槽位位置</li>
</ul>
<p><img src="/2021/04/05/jvm/112.png" alt></p>
<ul>
<li><p>foo方法解析</p>
<ul>
<li><p>操作数栈最大深度为5</p>
</li>
<li><p>两个代码块共用了一个槽位，在第一个代码块执行完毕之后第二个代码块会复用第一个代码块的槽位</p>
<p><img src="/2021/04/05/jvm/113.png" alt></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3，算数指令"><a href="#3，算数指令" class="headerlink" title="3，算数指令"></a>3，算数指令</h4><blockquote>
<ul>
<li><p><strong>作用</strong></p>
<ul>
<li>算术指令用于对两个操作数栈上的值进行某种特定运算，并把计算结果重新压入操作数栈</li>
</ul>
</li>
<li><p><strong>分类</strong></p>
<ul>
<li>大体上算术指令可以分为两种:对整型数据进行运算的指令与对浮点类型数据进行运算的指令</li>
</ul>
</li>
<li><p><strong>byte、short、char和boolean类型说明</strong></p>
<ul>
<li><p>在每一大类中，都有针对Java虚拟机具体数据类型的专用算术指令。但没有直接支持byte、 short、 char和boolean类型的算术指令，对于这些数据的运算，都使用int类型的指令来处理。此外，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。<br> <strong>Java虚拟机中的实际类型与运算类型</strong></p>
<table>
<thead>
<tr>
<th>实际类型</th>
<th>运算类型</th>
<th>分类</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>int</td>
<td>一</td>
</tr>
<tr>
<td>byte</td>
<td>int</td>
<td>一</td>
</tr>
<tr>
<td>char</td>
<td>int</td>
<td>一</td>
</tr>
<tr>
<td>short</td>
<td>int</td>
<td>一</td>
</tr>
<tr>
<td>int</td>
<td>int</td>
<td>一</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
<td>一</td>
</tr>
<tr>
<td>reference</td>
<td>reference</td>
<td>一</td>
</tr>
<tr>
<td>returnAddress</td>
<td>returnAddress</td>
<td>一</td>
</tr>
<tr>
<td>long</td>
<td>long</td>
<td>二</td>
</tr>
<tr>
<td>double</td>
<td>double</td>
<td>二</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>运算时的溢出</strong></p>
<ul>
<li>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，<strong>只有除法指令以及求余指令中当出现除数为0时会导致虚拟机抛出异常ArithmeticException.</strong></li>
</ul>
</li>
<li><p><strong>运算模式</strong></p>
<ul>
<li><strong>向最接近数舍入模式</strong>：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；（类似于四舍五入）</li>
<li><strong>向零舍入模式</strong>：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果；（类似于取整）</li>
</ul>
</li>
<li><p><strong>NaN值的使用</strong></p>
<ul>
<li><p>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN值来表示。而且所有使用NaN值作为操作数的算术操作，结果都会返回 NaN；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> j = i / <span class="number">0.0</span>;</span><br><span class="line">    System.out.println(j);<span class="comment">//无穷大</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> d1 = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">double</span> d2 = d1 / <span class="number">0.0</span>;</span><br><span class="line">    System.out.println(d2);<span class="comment">//NaN: not a number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="a，所有的算数指令"><a href="#a，所有的算数指令" class="headerlink" title="a，所有的算数指令"></a>a，所有的算数指令</h5><blockquote>
<ul>
<li>加法指令：iadd、ladd、fadd、dadd</li>
<li>减法指令：isub、lsub、fsub、dsub</li>
<li>乘法指令：imu、lmu、fmul、dmul</li>
<li>除法指令：irem、ldiv、fdiv、ddiv</li>
<li>求余指令：irem、lrem、frem、drem     //remainder：余数</li>
<li>取反指令：ineg、lneg、fneg、dneg       // negation：取反</li>
<li>自增指令：iinc</li>
<li>位运算指令，又可分为：<ul>
<li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li>
<li>按位或指令：ior、lor</li>
<li>按位与指令：iand、land</li>
<li>按位异或指令：ixor、lxor</li>
</ul>
</li>
<li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li>
</ul>
</blockquote>
<h5 id="b，举例说明"><a href="#b，举例说明" class="headerlink" title="b，举例说明"></a>b，举例说明</h5><blockquote>
<ul>
<li><p>举例一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">float</span> j = -i;</span><br><span class="line">    i = -j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 ldc #4 &lt;10.0&gt; &#x2F;&#x2F;压入i</span><br><span class="line">2 fstore_1      &#x2F;&#x2F;存储在操作数栈索引为1的位置</span><br><span class="line">3 fload_1       &#x2F;&#x2F;加载操作数上索引为1的数i</span><br><span class="line">4 fneg          &#x2F;&#x2F;对i取反</span><br><span class="line">5 fstore_2      &#x2F;&#x2F;将i取反的结果j存储在操作数栈索引为2的位置</span><br><span class="line">6 fload_2       &#x2F;&#x2F;加载操作数栈索引为2的j</span><br><span class="line">7 fneg          &#x2F;&#x2F;对j取反</span><br><span class="line">8 fstore_1      &#x2F;&#x2F;将j存储在操作数栈为1的索引i上，及改变i的值</span><br><span class="line">9 return        &#x2F;&#x2F;方法返回</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例二：自增与相加运算：</p>
<p><img src="/2021/04/05/jvm/114.png" alt></p>
</li>
<li><p>举例三：异或运算举例</p>
<p><img src="/2021/04/05/jvm/115.png" alt></p>
</li>
<li><p>特别注意：<strong>静态方法里面局部变量表槽位没有this</strong></p>
<ul>
<li>方法传入参数<code>i</code>占据了第0个索引</li>
</ul>
<p><img src="/2021/04/05/jvm/116.png" alt></p>
</li>
<li><p>举例四：前++和后++的问题：</p>
<ul>
<li><p>如果不涉及赋值操作，从字节码角度看是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//i++;</span></span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 bipush 10</span><br><span class="line">2 istore_1</span><br><span class="line">3 iinc 1 by 1</span><br><span class="line">6 return</span><br></pre></td></tr></table></figure>
</li>
<li><p>涉及到赋值操作时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a = i++;</span><br><span class="line">                                                                                                        </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = ++j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>i++是先赋值后运算</p>
</li>
<li><p>++i是先运算后赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 0 bipush 10</span><br><span class="line"> 2 istore_1</span><br><span class="line"> 3 iload_1</span><br><span class="line"> 4 iinc 1 by 1</span><br><span class="line"> 7 istore_2</span><br><span class="line"> 8 bipush 20</span><br><span class="line">10 istore_3</span><br><span class="line">11 iinc 3 by 1</span><br><span class="line">14 iload_3</span><br><span class="line">15 istore 4</span><br><span class="line">17 return</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="c，比较指令说明："><a href="#c，比较指令说明：" class="headerlink" title="c，比较指令说明："></a>c，比较指令说明：</h5><blockquote>
<ul>
<li>比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈。</li>
<li>比较指令有dcmpg、dcmpl、fcmpg、fcmpl、lcmp<ul>
<li>与前面讲解的指令类似，首字符d表示double类型，f表示float，l表示long</li>
</ul>
</li>
<li>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpl两个指令，他们的区别在于在数字比较时，若遇到NaN值，处理结构不同</li>
<li>指令dcmpl和dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述</li>
<li>指令lcmp针对long型整数，由于long型整数没有NaN值，故无需准备两套指令</li>
<li><strong>举例</strong>：<ul>
<li>指令fcmpg和fcmpl都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为v2，栈顶顺位第2位的元素为v1，<strong>若v1=v2，则压入0；若v1 &gt; v2则压入1；若v1 &lt; v2则压入 一1</strong>。</li>
<li><strong>两个指令的不同之处在于，如果遇到NaN值，fcmpg会压入1，而fcmpl会压入一1</strong>。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="4，类型转换指令"><a href="#4，类型转换指令" class="headerlink" title="4，类型转换指令"></a>4，类型转换指令</h4><blockquote>
<ul>
<li>类型转换指令可以将两种不同的数值类型进行相互转换（主要除了boolean之外的七种类型）</li>
<li>这些转换操作一般用于实现用户代码中的<strong>显示类型转换操作</strong>，或者用来处理<strong>字节码指令集中数据类型相关指令</strong>无法与数据类型一一对应的问题</li>
</ul>
</blockquote>
<h5 id="a，宽化类型转换（Widening-Numeric-Conversions）"><a href="#a，宽化类型转换（Widening-Numeric-Conversions）" class="headerlink" title="a，宽化类型转换（Widening Numeric Conversions）"></a>a，宽化类型转换（Widening Numeric Conversions）</h5><blockquote>
<ul>
<li><strong>转换规则：</strong><ul>
<li>Java虚拟机直接支持以下数值的宽化类型转换（widening numeric conversion），小范围类型向大范围类型的安全转换），也就说，并不需要指令执行，包括<ul>
<li>从int类型到long，float或者double类型，对应的指令为：i2l、i2f、i2d</li>
<li>从long乐行到float、double类型，对应的指令为l2f、l2d</li>
<li>从float类型到double类型，对应的指令为f2d</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>==简化为：int ——》 long ——》 float ——》 double==</p>
<p><img src="/2021/04/05/jvm/117.png" alt></p>
<ul>
<li><p><strong>精度损失问题：</strong></p>
<ul>
<li><p>宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从int转换到long，或者从int转换到double，都不会丢失任何信息，转换前后的值是精确相等的</p>
</li>
<li><p>从int、long类型数值转换为float、或者long类型数值转换到double时，将可能发生精度丢失——可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据IEEE754最接近舍入模式所得到的正确整数值</p>
</li>
<li><p>尽管宽化类型转换实际上是可能发生精度丢失的，但是这汇总转换永远不会导致Java虚拟机抛出运行时异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例：精度损失的问题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upCast2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">123123123</span>;</span><br><span class="line">    <span class="keyword">float</span> f = i;</span><br><span class="line">    System.out.println(f);<span class="comment">//123123120  精度丢失</span></span><br><span class="line">                                                </span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">123123123123L</span>;</span><br><span class="line">    l = <span class="number">123123123123123123L</span>;</span><br><span class="line">    <span class="keyword">double</span> d = l;</span><br><span class="line">    System.out.println(d);<span class="comment">//123123123123123120 精度丢失</span></span><br><span class="line">&#125;</span><br><span class="line">                                                </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>补充说明</strong>：</p>
<ul>
<li><p>从byte，char和short类型到int类型的宽化类型转换实际上是不存在的，对于byte类型转为int，虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据，而将byte转为long时，使用的是i2l，可以看到在内部byte在这里已经等同于int类型处理，类似的还有short类型，这种处理方式有两个特点:</p>
<ul>
<li><p>一方面可以减少实际的数据类型，如果为short和byte都准备一套指令，那么指令的数量就会大增，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将short和byte当做int处理也在情理之中。</p>
</li>
<li><p>另一方面，由于局部变量表中的槽位固定为32位，无论是byte或者short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</p>
<p><img src="/2021/04/05/jvm/118.png" alt></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="窄化类型转换（Narrowing-Numeric-Conversion）"><a href="#窄化类型转换（Narrowing-Numeric-Conversion）" class="headerlink" title="窄化类型转换（Narrowing Numeric Conversion）"></a>窄化类型转换（Narrowing Numeric Conversion）</h5><blockquote>
<ul>
<li><p><strong>转换规则：</strong></p>
<ul>
<li><p>Java虚拟机也直接支持以下窄化类型转换</p>
<ul>
<li><p>从int类型至byte，short或者char类型，对应的指令有：i2b、i2c、i2s</p>
</li>
<li><p>从long类型到int类型，对应的指令有：l2i</p>
</li>
<li><p>从float类型到int或者long类型对应的指令：f2i、f2l</p>
</li>
<li><p>从double类型到int、long或float者类型。对应的指令有：d2i、d2l、d2f</p>
</li>
<li><p>s2b不存在，实际的情况处理为i2b</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> s = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)s;</span><br><span class="line">&#125;</span><br><span class="line">                                                                                                        </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 bipush 10</span><br><span class="line">2 istore_1</span><br><span class="line">3 iload_1</span><br><span class="line">4 i2b</span><br><span class="line">5 istore_2</span><br><span class="line">6 return</span><br><span class="line">                                                                                                        </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>精度损失问题</strong></p>
<ul>
<li><p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级,因此,转换过程很可能会导致数值丢失精度。</p>
</li>
<li><p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况,但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i; <span class="comment">//byte 最大到127  转换后精度丢失，结果为-128</span></span><br><span class="line">    System.out.println(b);<span class="comment">//-128</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>补充说明：</strong></p>
<ul>
<li><p>当将一个浮点值窄话转换为正数类型T（T限于int或long类型之一）的时候，将遵循以下转换规则：</p>
<ul>
<li>如果浮点值是NaN，那转换结果就是int或long类型的0</li>
<li>如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v，如果v在目标类型T（int或long）的表示范围之内，那转换结果就是v，否则，将根据v的符号，转换为T所能表示的最大或者最小正数</li>
</ul>
</li>
<li><p>当将一个double类型窄化转换为 float类型时,将遵循以下转换规则: 通过向最接近数舍入模式舍入一个可以使用 float类型表示的数字。最后结果根据下面这3条规则判断:</p>
<ul>
<li><p>如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零</p>
</li>
<li><p>如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大</p>
</li>
<li><p>对于double类型的NaN值将按规定转换为float类型的NaN值</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试NaN,无穷大的情况</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d1 = Double.NaN; <span class="comment">//0.0 / 0.0</span></span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)d1;</span><br><span class="line">    System.out.println(d1);<span class="comment">//NaN</span></span><br><span class="line">    System.out.println(i);<span class="comment">//0 整型不存在NaN，按0处理</span></span><br><span class="line">                                                                                                                                                            </span><br><span class="line">    <span class="keyword">double</span> d2 = Double.POSITIVE_INFINITY;<span class="comment">// Infinity</span></span><br><span class="line">    <span class="keyword">long</span> l = (<span class="keyword">long</span>)d2;</span><br><span class="line">    <span class="keyword">int</span> j = (<span class="keyword">int</span>)d2;</span><br><span class="line">    System.out.println(l);<span class="comment">//9223372036854775807  转换后指向了long型的最大值  Infinity -&gt; 9223372036854775807</span></span><br><span class="line">    System.out.println(Long.MAX_VALUE);<span class="comment">//9223372036854775807</span></span><br><span class="line">    System.out.println(j);<span class="comment">//2147483647 转换后指向了int型的最大值  Infinity -&gt; 2147483647</span></span><br><span class="line">    System.out.println(Integer.MAX_VALUE);<span class="comment">//2147483647</span></span><br><span class="line">                                                                                                                                                            </span><br><span class="line">    <span class="keyword">float</span> f = (<span class="keyword">float</span>)d2;</span><br><span class="line">    System.out.println(f);<span class="comment">//Infinity   float无穷大没有具体值</span></span><br><span class="line">                                                                                                                                                            </span><br><span class="line">    <span class="keyword">float</span> f1 = (<span class="keyword">float</span>)d1;</span><br><span class="line">    System.out.println(f1);<span class="comment">//NaN</span></span><br><span class="line">&#125;</span><br><span class="line">                                                                                                                                                            </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="5，对象的创建与访问指令"><a href="#5，对象的创建与访问指令" class="headerlink" title="5，对象的创建与访问指令"></a>5，对象的创建与访问指令</h4><blockquote>
<p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为<strong>创建指令、字段访问指令、数组操作指令、类型检查指令</strong>。</p>
</blockquote>
<h5 id="a，创建指令："><a href="#a，创建指令：" class="headerlink" title="a，创建指令："></a>a，创建指令：</h5><blockquote>
<p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令:</p>
<ul>
<li><p><strong>创建类实例的指令：new</strong></p>
<ul>
<li><p>它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的以后用压入栈</p>
<p><img src="/2021/04/05/jvm/119.png" alt></p>
</li>
</ul>
</li>
<li><p><strong>创建数组的指令：newarray、anewarray、multianewarray</strong></p>
<ul>
<li><p><strong>newarray</strong>：创建基本类型数组</p>
</li>
<li><p><strong>anewarray</strong>：创建引用类型数组</p>
</li>
<li><p><strong>multianewarray</strong>：创建多维数组</p>
</li>
<li><p>下面的例子中 strArray之所以是anewArray而不是multianewArray是因为strArray在堆中相当于只是创建了一个一维数组</p>
<p><img src="/2021/04/05/jvm/120.png" alt></p>
</li>
</ul>
</li>
</ul>
<p>上述创建指令可以用于创建对象或者数组，由于对象和数组再Java中的广泛使用，这些指令的使用频率也非常高</p>
</blockquote>
<h5 id="b，字段访问指令"><a href="#b，字段访问指令" class="headerlink" title="b，字段访问指令"></a>b，字段访问指令</h5><blockquote>
<p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例汇总的字段或者数组元素</p>
<ul>
<li><p><strong>访问类字段（static字段，或者称为类变量）的指令：getstatic、putstatic</strong></p>
</li>
<li><p><strong>访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield</strong></p>
</li>
<li><p><strong>举例</strong>：</p>
<ul>
<li><p>以getstatic指令为例，它含有一个操作数，为指向常量池的Fieldref索引，它的作用就是获取Fieldref指定的对象或者值，并将其压入操作数栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System. out. println (<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 getstatic #8 &lt;java&#x2F;lang&#x2F;System.out&gt; </span><br><span class="line">3 ldc #9 &lt;hello&gt;</span><br><span class="line">5 invokevirtual#10&lt;java&#x2F;io&#x2F;PrintStream.println&gt; </span><br><span class="line">8 return</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/05/jvm/121.png" alt></p>
<p><img src="/2021/04/05/jvm/122.png" alt></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="c，数组操作指令"><a href="#c，数组操作指令" class="headerlink" title="c，数组操作指令"></a>c，数组操作指令</h5><blockquote>
<ul>
<li><p>数组操作指令主要有：xastore和xaload指令。具体为：</p>
<ul>
<li><p>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</p>
</li>
<li><p>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore</p>
<table>
<thead>
<tr>
<th>数组类型</th>
<th>加载指令</th>
<th>存储指令</th>
</tr>
</thead>
<tbody><tr>
<td>byte（boolean）</td>
<td>baload</td>
<td>bastore</td>
</tr>
<tr>
<td>char</td>
<td>caload</td>
<td>castore</td>
</tr>
<tr>
<td>short</td>
<td>saload</td>
<td>sastore</td>
</tr>
<tr>
<td>int</td>
<td>iaload</td>
<td>iastore</td>
</tr>
<tr>
<td>long</td>
<td>laload</td>
<td>lastore</td>
</tr>
<tr>
<td>float</td>
<td>faload</td>
<td>fastore</td>
</tr>
<tr>
<td>double</td>
<td>daload</td>
<td>dastore</td>
</tr>
<tr>
<td>reference</td>
<td>aaload</td>
<td>aastore</td>
</tr>
</tbody></table>
<p><img src="/2021/04/05/jvm/123.png" alt></p>
</li>
</ul>
</li>
<li><p>取数组长度的指令：arraylength</p>
<ul>
<li><p>该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈</p>
<p><img src="/2021/04/05/jvm/124.png" alt></p>
</li>
</ul>
</li>
<li><p><strong>说明</strong>：</p>
<ul>
<li>指令xaload表示将数组的元素压栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中栈顶元素为数组索引 i ，栈顶顺位第2个元素为数组引用a，该指令会弹出栈顶这两个元素，并将a[i]重新压入栈。</li>
<li>xastore则专门针对数组操作，以iastore为例，它用于给一个int数组的给定索引赋值。在iastore执行前，操作数栈顶需要以此准备3个元素:<strong>值、索引、数组引用</strong>，iastore会弹出这3个值，并将值赋给数组中指定索引的位置</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="d，类型检查指令"><a href="#d，类型检查指令" class="headerlink" title="d，类型检查指令"></a>d，类型检查指令</h5><blockquote>
<p>检查类实例或数组类型的指令：instanceof、checkcast</p>
<ul>
<li><p>指令checkcast用于检查类型强制转换是否可以进行，如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常</p>
</li>
<li><p>指令instanceof用来判断给定对象是否是某一个类的实例，他会将判断结果压入操作数栈</p>
<p><img src="/2021/04/05/jvm/125.png" alt></p>
</li>
</ul>
</blockquote>
<h4 id="6，方法调用与返回指令"><a href="#6，方法调用与返回指令" class="headerlink" title="6，方法调用与返回指令"></a>6，方法调用与返回指令</h4><h5 id="a，方法调用指令"><a href="#a，方法调用指令" class="headerlink" title="a，方法调用指令"></a>a，方法调用指令</h5><blockquote>
<ul>
<li><p>方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic</p>
</li>
<li><p>以下5条指令用于方法调用：</p>
<ul>
<li><p>invokevirtual：指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态，这也是Java语言中<strong>最常见的方法分派方式</strong></p>
</li>
<li><p>invokeinterface：指令用于<strong>调用接口方法</strong>，它会在运行时搜索由特定对象所实现的这个接口方法，并找出合适的方法进行调用</p>
</li>
<li><p>invokespecial：指令用于调用一些需要特殊处理的实例方法，包括<strong>实例初始化方法（构造器），私有方法和父类方法</strong>，这些方法都是<strong>静态类型绑定</strong>的，不会在调用时进行动态派发</p>
</li>
<li><p>invokestatic：指令用于调用命令<strong>类中的类方法（static方法）</strong>，这是<strong>静态绑定</strong>的</p>
</li>
<li><p>invokedynamic：调用动态绑定的方法，这个是JDK1.7后新加入的指令，用于在运行时动态解析出调用限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是有用户所设定的引导方法决定的</p>
</li>
<li><p>举例一：<strong>invokespecial</strong></p>
<p><img src="/2021/04/05/jvm/126.png" alt></p>
</li>
<li><p>举例二：<strong>invokestatic</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法调用指令:invokestatic:静态分派</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    methodStatic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例三：<strong>invokestatic</strong></p>
<p><img src="/2021/04/05/jvm/127.png" alt></p>
</li>
<li><p>举例四：<strong>invokevirtual</strong></p>
<p><img src="/2021/04/05/jvm/128.png" alt></p>
</li>
<li><p><strong>方法调用指令的补充说明</strong></p>
<p><img src="/2021/04/05/jvm/129.png" alt></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="b，方法返回指令"><a href="#b，方法返回指令" class="headerlink" title="b，方法返回指令"></a>b，方法返回指令</h5><blockquote>
<p>方法调用结束前，需要进行返回，方法返回指令是<strong>根据返回值的类型</strong>区分的。</p>
<ul>
<li><p>包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn</p>
</li>
<li><p>另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用</p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>返回指令</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>return</td>
</tr>
<tr>
<td>int（boolean，byte，char，short）</td>
<td>ireturn</td>
</tr>
<tr>
<td>long</td>
<td>lreturn</td>
</tr>
<tr>
<td>float</td>
<td>freturn</td>
</tr>
<tr>
<td>double</td>
<td>dreturn</td>
</tr>
<tr>
<td>reference</td>
<td>areturn</td>
</tr>
</tbody></table>
</li>
<li><p>举例：</p>
<ul>
<li><p>通过ireturn指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p>
</li>
<li><p>如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区。</p>
</li>
<li><p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者</p>
<p><img src="/2021/04/05/jvm/130.png" alt></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="7，操作数栈管理指令"><a href="#7，操作数栈管理指令" class="headerlink" title="7，操作数栈管理指令"></a>7，操作数栈管理指令</h4><blockquote>
<p>如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。</p>
<p>这类指令包括如下内容:</p>
<ul>
<li>将一个或两个元素从栈顶弹出，并且直接废弃：pop、pop2</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x2、dup_x2、dup2_x2</li>
<li>将栈最顶端的两个Slot数值位置交换：<strong>swap</strong>。Java虚拟机没有提供交换两个64位数据类型（long double）数值的指令</li>
<li>指令nop，是一个非常特殊的指令，它的字节码为0x00，和汇编语言中的nop一样，它表示什么都不做，这条指令一般可用于调试，占位等。</li>
</ul>
<p>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型</p>
<p><strong>说明</strong>：</p>
<ul>
<li>不带_x的指令是复制栈顶数据并压入栈顶。包括两个指令，dup和dup2.dup的系数代表要复制的Slot个数。<ul>
<li>dup开头的指令用于复制1个Slot的数据。例如1个int或1个reference类型数据</li>
<li>dup2开头的指令用于复制2个Slot的数据。例如1个long，或2个int，或1个int+1个</li>
</ul>
</li>
<li>带_x的指令是复制栈顶数据并插入栈顶以下的某个位置，共有4个指令，dup_x1，dup2_x1，dup_x2、dup2_x2。对于带_x的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置，因此<ul>
<li>dup_x1插入位置：1+1=2，即栈顶2个Slot下面</li>
<li>dup_x2插入位置：1+2=3，即栈顶3个Slot下面</li>
<li>dup2_x1插入位置：2+1=3，即栈顶3个Slot下面</li>
<li>dup2_x1插入位置：2+2=4，即栈顶4个Slot下面</li>
</ul>
</li>
<li>pop：将栈顶的1个Slot数值出栈，例如1个short类型数值</li>
<li>pop2：将栈顶的2个Slot数值出栈，例如1个double类型数值，或者2个int类型数值</li>
</ul>
<p>例：</p>
<p><img src="/2021/04/05/jvm/131.png" alt></p>
<p><img src="/2021/04/05/jvm/132.png" alt></p>
</blockquote>
<h4 id="8，控制转移指令"><a href="#8，控制转移指令" class="headerlink" title="8，控制转移指令"></a>8，控制转移指令</h4><blockquote>
<p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为 ：</p>
<ol>
<li>比较指令</li>
<li>条件跳转指令</li>
<li>比较条件跳转指令</li>
<li>多条件分支跳转指令</li>
<li>无条件跳转指令等</li>
</ol>
</blockquote>
<h5 id="a，比较指令（这个是算数指令）："><a href="#a，比较指令（这个是算数指令）：" class="headerlink" title="a，比较指令（这个是算数指令）："></a>a，比较指令（这个是算数指令）：</h5><blockquote>
<ul>
<li>比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈。</li>
<li><strong>比较指令有dcmpg、dcmpl、fcmpg、fcmpl、lcmp</strong><ul>
<li>与前面讲解的指令类似，首字符d表示double类型，f表示float，l表示long</li>
</ul>
</li>
<li>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpl两个指令，他们的区别在于在数字比较时，若遇到NaN值，处理结构不同</li>
<li>指令dcmpl和dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述</li>
<li>指令lcmp针对long型整数，由于long型整数没有NaN值，故无需准备两套指令</li>
<li><strong>举例</strong>：<ul>
<li>指令fcmpg和fcmpl都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为v2，栈顶顺位第2位的元素为v1，<strong>若v1=v2，则压入0；若v1 &gt; v2则压入1；若v1 &lt; v2则压入 一1</strong>。</li>
<li><strong>两个指令的不同之处在于，如果遇到NaN值，fcmpg会压入1，而fcmpl会压入一1</strong>。</li>
</ul>
</li>
<li>特别注意：<ul>
<li>数值类型的数据才可以谈比较大小</li>
<li>boolean、引用数据类型不能比较大小</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="b，条件跳转指令"><a href="#b，条件跳转指令" class="headerlink" title="b，条件跳转指令"></a>b，条件跳转指令</h5><blockquote>
<ul>
<li><p>条件跳转指令通常和比较指令结合使用。在条件跳共今不前，一般可以先用比较指令选行栈顶元素的准备，然后进行条件跳转。</p>
</li>
<li><p><strong>条件跳转指令有: ifeq， iflt， ifle， ifne， ifgt， ifge， ifnull， ifnonnull</strong>。这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的offset）。 它们的统一含义为:<strong>弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。</strong></p>
</li>
<li><p>具体说明：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ifeq</td>
<td>equals 当栈顶int类型数值等于0时跳转</td>
</tr>
<tr>
<td>ifne</td>
<td>not equals 当栈顶in类型数值不等于0时跳转</td>
</tr>
<tr>
<td>iflt</td>
<td>lower than 当栈顶in类型数值小于0时跳转</td>
</tr>
<tr>
<td>ifle</td>
<td>lower or equals 当栈顶in类型数值小于等于0时跳转</td>
</tr>
<tr>
<td>ifgt</td>
<td>greater than  当栈顶int类型数组大于0时跳转</td>
</tr>
<tr>
<td>ifge</td>
<td>greater or equals 当栈顶in类型数值大于等于0时跳转</td>
</tr>
<tr>
<td>ifnull</td>
<td>为null时跳转</td>
</tr>
<tr>
<td>ifnonnull</td>
<td>不为null时跳转</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li>与前面运算规则一致<ul>
<li>对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型的比较指令完成</li>
<li>对于long，float，double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后在执行int类型的条件分支比较操作来完成整个分支跳转</li>
</ul>
</li>
<li>由于各类型的比较最终都会转为int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。</li>
</ul>
</li>
<li><p>举例一：<strong>ifeq</strong></p>
<p><img src="/2021/04/05/jvm/133.png" alt></p>
</li>
<li><p>举例二：<strong>ifnonnull</strong>：</p>
<p><img src="/2021/04/05/jvm/134.png" alt></p>
</li>
<li><p>举例三：<strong>综合比较指令</strong></p>
<p><img src="/2021/04/05/jvm/135.png" alt></p>
<p><img src="/2021/04/05/jvm/136.png" alt></p>
<p><img src="/2021/04/05/jvm/137.png" alt></p>
</li>
</ul>
</blockquote>
<h5 id="c，比较条件跳转指令"><a href="#c，比较条件跳转指令" class="headerlink" title="c，比较条件跳转指令"></a>c，比较条件跳转指令</h5><blockquote>
<ul>
<li><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体,它将比较和跳转两个步骤合二为一。</p>
</li>
<li><p><strong>这类指令有：if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、 ificmpge、if_ acmpeq和if_acmpne</strong>，其中指令助记符加上“<code>if_</code>”后,以字符“<code>i</code>”开头的指令针对int型整数操作(也包括 short和byte类型)，以字符“<code>a</code>”开头的指令表示对象引用的比较。</p>
</li>
<li><p>具体说明：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>if_icmpeq</td>
<td>比较栈顶两int类型数值大小,当前者等于后者时跳转</td>
</tr>
<tr>
<td>if_icmpne</td>
<td>比较栈顶两int类型数值大小,当前者不等于后者时跳转</td>
</tr>
<tr>
<td>if_icmplt</td>
<td>比较栈顶两int类型数值大小,当前者小于后者时跳转</td>
</tr>
<tr>
<td>if_icmple</td>
<td>比较栈顶两int类型数值大小,当前者小于等于后者时跳转</td>
</tr>
<tr>
<td>if_icmpgt</td>
<td>比较栈顶两int类型数值大小,当前者大于后者时跳转</td>
</tr>
<tr>
<td>if_icmpge</td>
<td>比较栈顶两int类型数值大小,当前者大于等于后者时跳转</td>
</tr>
<tr>
<td>if_acmpeq</td>
<td>比较栈顶两引用类型数值,当结果相等时跳转</td>
</tr>
<tr>
<td>if_acmpne</td>
<td>比较栈顶两引用类型数值,当结果不相等时跳转</td>
</tr>
</tbody></table>
<p>这些指令都接收<strong>两个字节</strong>的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需<strong>要准备两个元素进行比较</strong>。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。如<strong>果预设条件成立，则执行跳转，否则，继续执行下一条语句。</strong></p>
</li>
<li><p>举例一</p>
<p><img src="/2021/04/05/jvm/138.png" alt></p>
</li>
</ul>
</blockquote>
<h5 id="d，多条件分支跳转"><a href="#d，多条件分支跳转" class="headerlink" title="d，多条件分支跳转"></a>d，多条件分支跳转</h5><blockquote>
<ul>
<li><p>多条件分支跳转指令是专为switch一case语句设计的，主要有<strong>tableswitch</strong>和<strong>lookupswitch</strong>。</p>
<table>
<thead>
<tr>
<th>指令名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>tableswitch</td>
<td>用于switch条件跳转，case值连续</td>
</tr>
<tr>
<td>lookupswitch</td>
<td>用于switch条件跳转，case值不连续</td>
</tr>
</tbody></table>
<ul>
<li>从助记符上看，两者都是switch语句的实现，它们的区别:<ul>
<li>tableswitch要求<strong>多个条件分支值是连续的</strong>，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量位置，<strong>因此效率比较高</strong>。</li>
<li>指令lookupswitch内部存<strong>放着各个离散的case一offset对</strong>，每次执行都要搜索全部的case一offset对，找到匹配的case值，并根据对应的offset计算跳转地址，<strong>因此效率较低。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>指令tableswitch的示意图如下图所示。由于tableswitch的case值是连续的，因此只需要记录最低值和最高值，以及每一项对应的offset偏移量，根据给定的index值通过简单的计算即可直接定位到offset。</p>
<p><img src="/2021/04/05/jvm/139.png" alt></p>
</li>
<li><p>指令lookupswitch处理的是离散的case值，但是出于效率考虑，将case一offset对按照case值大小排序，给定index时，需要査找与index相等的case，获得其offset，如果找不到则跳转到default。指令1ookupswitch 如下图所示</p>
<p><img src="/2021/04/05/jvm/140.png" alt></p>
</li>
</ul>
<ul>
<li><p>例：</p>
<p><img src="/2021/04/05/jvm/141.png" alt></p>
<p><img src="/2021/04/05/jvm/142.png" alt></p>
<p><img src="/2021/04/05/jvm/143.png" alt></p>
<p><img src="/2021/04/05/jvm/144.png" alt></p>
</li>
</ul>
</blockquote>
<h5 id="e，无条件跳转"><a href="#e，无条件跳转" class="headerlink" title="e，无条件跳转"></a>e，无条件跳转</h5><blockquote>
<ul>
<li><p>目前主要的无条件跳转指令为goto。指令goto接收两个字节的操作数，共同组成一个带符号的整数，<strong>用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。</strong></p>
</li>
<li><p>如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令goto_w，它和goto有相同的作用，但是它接收4个宇节的操作数，可以表示更大的地址范围。</p>
</li>
<li><p>指令jsr、jsr_w、ret虽然也是无条件跳转的，但主要用于try-finally语句，且已经被虚拟机逐渐废弃，故不在这里介绍这两个指令</p>
</li>
<li><p>具体指令说明：</p>
<table>
<thead>
<tr>
<th>指令名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>goto</td>
<td>无条件跳转</td>
</tr>
<tr>
<td>goto_w</td>
<td>无条件跳转（宽索引）</td>
</tr>
<tr>
<td>jsr</td>
<td>跳转至指定16位offset位置，并将jsr下条指令地址压入栈顶</td>
</tr>
<tr>
<td>jsr_w</td>
<td>跳转至指定32位offer位置，并将jsr_w下条指令地址压入栈顶</td>
</tr>
<tr>
<td>ret</td>
<td>返回至由指定的局部变量所给出的指令位置（一般与jsr、jsr_w联合使用）</td>
</tr>
</tbody></table>
</li>
<li><p>举例一：循环结构与goto的搭配</p>
<p><img src="/2021/04/05/jvm/145.png" alt></p>
</li>
<li><p>思考：</p>
<ul>
<li><p>whileTest和forTest的字节码是一样的，区别是i的作用域不同</p>
</li>
<li><p>doWhileTest中i++至少会执行一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思考：如下两个方法的操作有何不同？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whileTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以继续使用i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不可以继续使用i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更进一步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWhileTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(i &lt;= <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                        </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="9，异常处理指令"><a href="#9，异常处理指令" class="headerlink" title="9，异常处理指令"></a>9，异常处理指令</h4><h5 id="a，抛出异常指令"><a href="#a，抛出异常指令" class="headerlink" title="a，抛出异常指令"></a>a，抛出异常指令</h5><blockquote>
<ul>
<li><p>==athrow指令==</p>
<ul>
<li>在Java程序中显示抛出异常的操作 （throw语句）都是由athrow指令来实现。 除了使用throw语句显示抛出异常情况之外，<strong>JVM规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出</strong>。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv或 ldiv指令中抛出 ArithmeticException异常。</li>
</ul>
</li>
<li><p><strong>注意</strong>：</p>
<ul>
<li>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是<strong>在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。</strong></li>
</ul>
</li>
<li><p><strong>异常及异常处理：</strong> </p>
<ul>
<li><p>过程一：异常对象的生成过程 –&gt; throw(手动/自动) –&gt; 指令：athrow</p>
</li>
<li><p>过程二：异常的处理：抓抛模型。try-catch-finally –&gt; 使用异常表</p>
<p><img src="/2021/04/05/jvm/146.png" alt></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="b，异常处理与异常表"><a href="#b，异常处理与异常表" class="headerlink" title="b，异常处理与异常表"></a>b，异常处理与异常表</h5><blockquote>
<ul>
<li><p><strong>处理异常：</strong></p>
<ul>
<li>在Java虚拟机中，<strong>处理异常</strong>（catch语句）不是由字节码指令来实现的（早期使用jsr，ret指令），而是<strong>采用异常表来完成的</strong></li>
</ul>
</li>
<li><p><strong>异常表：</strong></p>
<ul>
<li>如果一个方法定义了一个try一catch或者try一finally的异常处理，就会创建一个异常表。它包含了每个异常处理或者finally块的信息。异常表保存了每个异常处理信息。比如: <ul>
<li>起始位置</li>
<li>结束位置 </li>
<li>程序计数器记录的代码处理的偏移地址 </li>
<li>被捕获的异常类在常量池中的索引</li>
</ul>
</li>
</ul>
<p><strong>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧</strong>，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程</p>
<p><strong>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。</strong>在这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return前，它直接跳到finally块来完成目标</p>
</li>
<li><p>举例：</p>
<p><img src="/2021/04/05/jvm/147.png" alt></p>
<p>try finally代码执行过程举例</p>
<p><img src="/2021/04/05/jvm/148.png" alt></p>
</li>
</ul>
</blockquote>
<h4 id="10-同步控制指令"><a href="#10-同步控制指令" class="headerlink" title="10,同步控制指令"></a>10,同步控制指令</h4><blockquote>
<p>java虚拟机支持两种同步结构:方法级的同步和方法内部一段指令序列的同步，这两种同步都是使用monitor来支持的。</p>
</blockquote>
<h5 id="a，方法级的同步："><a href="#a，方法级的同步：" class="headerlink" title="a，方法级的同步："></a>a，方法级的同步：</h5><blockquote>
<ul>
<li><p>方法级的同步：<strong>是隐式的</strong>，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的<code>ACC_SYNCHRONIZED</code>访问标志得知一个方法是否声明为同步方法;</p>
</li>
<li><p>当调用方法时，调用指令将会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否设置</p>
<ul>
<li>如果设置了，执行线程将先持有同步锁，然后执行方法，<strong>最后</strong>在方法完成（无论是正常完成还是非正常完成）时<strong>释放同步锁</strong></li>
<li>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁</li>
<li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放</li>
</ul>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 aload_0</span><br><span class="line">1 dup</span><br><span class="line">2 getfield #2 &lt;com&#x2F;atguigu&#x2F;java1&#x2F;SynchronizedTest.i&gt;</span><br><span class="line">5 iconst_1</span><br><span class="line">6 iadd</span><br><span class="line">7 putfield #2 &lt;com&#x2F;atguigu&#x2F;java1&#x2F;SynchronizedTest.i&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：</p>
<ul>
<li>这段代码和普通的无同步操作的代码没有什么不同，没有使用monitorenter和monitorexit进行同步区控制。这是因为，对于同步方法而言，当虚拟机通过方法的<strong>访问标示符判断是一个同步方法</strong>时，<strong>会自动在方法调用前进行加锁，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁</strong>。因此，<strong>对于同步方法而言，monitorenter和monitorexit指令是隐式存在的，并未直接出现在字节码中。</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="b，方法内指定指令序列的同步"><a href="#b，方法内指定指令序列的同步" class="headerlink" title="b，方法内指定指令序列的同步"></a>b，方法内指定指令序列的同步</h5><blockquote>
<ul>
<li><p>同步一段指令集序列:通常是由java中的synchronized语句块来表示的。jvm的指令集有 monitorenter 和monitorexit两条指令来支持synchronized关键字的语义。</p>
</li>
<li><p>当一个线程进入同步代码块时，它使用monitorenter指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0，才会被允许进入同步块。</p>
</li>
<li><p>当线程退出同步块时，需要使用monitorexit声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p>
</li>
<li><p>指令monitorenter和monitorexit在执行时，都需要在操作数栈顶压入对象，之后monitorenter和monitorexit的锁定和释放都是针对这个对象的监视器进行的。</p>
</li>
<li><p>下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程4离开临界区后，线程1、2、3才有可能进入</p>
<p><img src="/2021/04/05/jvm/149.png" alt></p>
<p><img src="/2021/04/05/jvm/150.png" alt></p>
</li>
</ul>
</blockquote>
<h3 id="三，类加载过程的详解"><a href="#三，类加载过程的详解" class="headerlink" title="三，类加载过程的详解"></a>三，类加载过程的详解</h3><h4 id="1，概述"><a href="#1，概述" class="headerlink" title="1，概述"></a>1，概述</h4><blockquote>
<ul>
<li><p>在Java中数据类型分为基本数据类型和引用数据类型。<strong>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载</strong></p>
</li>
<li><p>按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段:</p>
<p><img src="/2021/04/05/jvm/151.png" alt></p>
<p>其中，验证、准备、解析3个部分统称为链接（Linking）</p>
</li>
<li><p>从程序中类的使用过程看:</p>
<p><img src="/2021/04/05/jvm/152.png" alt></p>
</li>
</ul>
</blockquote>
<h4 id="2，过程一：Loading（加载）阶段"><a href="#2，过程一：Loading（加载）阶段" class="headerlink" title="2，过程一：Loading（加载）阶段"></a>2，过程一：Loading（加载）阶段</h4><h5 id="a，加载完成的操作"><a href="#a，加载完成的操作" class="headerlink" title="a，加载完成的操作"></a>a，加载完成的操作</h5><blockquote>
<ul>
<li><strong>加载的理解</strong>：<ul>
<li><strong>所谓加载，简而言之就是将Java类的乳节码文件加载到机器内存中，并在内存中构建出Java类的原型一一类模板对象。</strong>所谓类模板对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</li>
<li>反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。</li>
</ul>
</li>
<li><strong>加载完成的操作：</strong><ul>
<li><strong>加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例</strong></li>
<li>在加载类时，Java虚拟机必须完成以下3件事情：<ul>
<li>通过类的全名，获取类的二进制数据流</li>
<li>解析类的二进制数据流为方法区内的数据结构（Java类模型）</li>
<li>创建爱你java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="b，二进制流的获取方式"><a href="#b，二进制流的获取方式" class="headerlink" title="b，二进制流的获取方式"></a>b，二进制流的获取方式</h5><blockquote>
<ul>
<li>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（<strong>只要所读取的字节码符合JVM规范即可</strong>）<ul>
<li>虚拟机可能通过文件系统读入一个class后缀的文件<strong>（最常见）</strong></li>
<li>读入jar、zip等归档数据包，提取类文件</li>
<li>实现存放在数据库中的类的二进制数据</li>
<li>使用类似于HTTP之类的协议通过网络进行加载</li>
<li>在运行时生成一段Class的二进制信息等</li>
</ul>
</li>
<li>在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例</li>
<li>如果输入数据不是ClassFile的结构，则会抛出ClassFormatError</li>
</ul>
</blockquote>
<h5 id="c，类模型与Class实例的位置"><a href="#c，类模型与Class实例的位置" class="headerlink" title="c，类模型与Class实例的位置"></a>c，类模型与Class实例的位置</h5><blockquote>
<ul>
<li><p>类模型的位置：</p>
<ul>
<li>加载的类在JVM中创建相应的类结构，类结构会存储在方法区（JDK1.8之前：永久代；JDK1.8之后：元空间）</li>
</ul>
</li>
<li><p>Class实例的位置：</p>
<ul>
<li>类将.class文件加载至元空间后，会在堆中创建一个java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。（instanceKlass -&gt; mirror : Class的实例）</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/05/jvm/153.png" alt></p>
<p>外部可以通过访问代表Order类的Class对象来获取Order的类数据结构</p>
</li>
<li><p><strong>再说明：</strong></p>
<ul>
<li><p>Class类的构造方法是私有的，只有JVM能够创建。 java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据、入口。通过Class类提供的接口，可以获得目标类所关联的.class文件中具体的数据结构:方法、字段等信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 过程一：加载阶段</span></span><br><span class="line"><span class="comment"> * 通过Class类，获得了java.lang.String类的所有方法信息，并打印方法访问标识符、描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">            <span class="comment">//获取当前运行时类声明的所有方法</span></span><br><span class="line">            Method[] ms = clazz.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">                <span class="comment">//获取方法的修饰符</span></span><br><span class="line">                String mod = Modifier.toString(m.getModifiers());</span><br><span class="line">                System.out.print(mod + <span class="string">" "</span>);</span><br><span class="line">                <span class="comment">//获取方法的返回值类型</span></span><br><span class="line">                String returnType = m.getReturnType().getSimpleName();</span><br><span class="line">                System.out.print(returnType + <span class="string">" "</span>);</span><br><span class="line">                <span class="comment">//获取方法名</span></span><br><span class="line">                System.out.print(m.getName() + <span class="string">"("</span>);</span><br><span class="line">                <span class="comment">//获取方法的参数列表</span></span><br><span class="line">                Class&lt;?&gt;[] ps = m.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (ps.length == <span class="number">0</span>) System.out.print(<span class="string">')'</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ps.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> end = (i == ps.length - <span class="number">1</span>) ? <span class="string">')'</span> : <span class="string">','</span>;</span><br><span class="line">                    <span class="comment">//获取参数的类型</span></span><br><span class="line">                    System.out.print(ps[i].getSimpleName() + end);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">                                                                                                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                                                                                                    </span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="d，数组类的加载"><a href="#d，数组类的加载" class="headerlink" title="d，数组类的加载"></a>d，数组类的加载</h5><blockquote>
<p>创建数组类的情况稍微有些特殊，因为<strong>数组类本身并不是由类加载器负责创建</strong>，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组（下述简称A）的过程：</p>
<ul>
<li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型；</li>
<li>JVM使用指定的元素类型和数组维度来创建新的数组类。</li>
</ul>
<p>如果数组的元素类型是引用类型，数据类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public</p>
</blockquote>
<h4 id="3，过程二：Linking（链接）阶段"><a href="#3，过程二：Linking（链接）阶段" class="headerlink" title="3，过程二：Linking（链接）阶段"></a>3，过程二：Linking（链接）阶段</h4><h5 id="a，环节1：链接阶段之Verification（验证）"><a href="#a，环节1：链接阶段之Verification（验证）" class="headerlink" title="a，环节1：链接阶段之Verification（验证）"></a>a，环节1：链接阶段之Verification（验证）</h5><blockquote>
<p><strong>Verification（验证）：</strong></p>
<ul>
<li><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p>
</li>
<li><p><strong>它的目的是保证加载的字节码是合法，合理并符合规范的。</strong></p>
</li>
<li><p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检查，如图所示：</p>
<p><img src="/2021/04/05/jvm/154.png" alt></p>
<p><strong>整体说明</strong>：</p>
<ul>
<li>验证的内容则涵盖了类数据信息的格式验证，语义检查，字节码验证，以及符号引用验证等<ul>
<li>其中<strong>格式验证会和加载阶段一起执行</strong>，验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区汇中</li>
<li><strong>格式验证之外的验证操作将会在方法区中进行</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>链接阶段的验证虽然拖慢了加载速度，但是他避免了在字节码运行时还需要进行各种检查</p>
</li>
<li><p><strong>具体说明：</strong></p>
<ul>
<li>==格式验证==：是否以魔数OxCAFEBABE开头，主版本和副版本号是否在当前Java虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</li>
<li>Java虚拟机会进行字节码的==语义检查==，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：<ul>
<li>是否所有的类都有父类的存在（在Java里，除了Object外，其他类都应该有父类）</li>
<li>是否一些被定义为final的方法或者类被重写或继承了</li>
<li>非抽象类是否是是实现了所有抽象方法或者接口方法</li>
<li>是否存在不兼容的方法（比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；abstract情况下的方法，就不能是final的）</li>
</ul>
</li>
<li>Java虚拟机还会进行==字节码验证==，字节码验证也是验证过程<strong>中最为复杂的一个过程</strong>，它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：<ul>
<li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li>
<li>函数的调用是否传递了正确类型的参数</li>
<li>变量的赋值是不是给了正确的数据类型等。</li>
</ul>
</li>
<li>栈映射帧（StackMapTable）就是在这个阶段，<strong>用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。</strong>但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的</li>
<li><strong>在前面3次检查中，已经排除了文件格式错误，语义错误以及字节码的不正确性，但是依然不能确保类是没有问题的。</strong></li>
<li>校验器还将进行==符号引用的验证==。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机就会检查这些类或者方法确实是存在的</strong>，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError，如果一个方法无法被找到，则会抛出NoSuchMethodError。<strong>此阶段在解析环节才会执行</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="b，环节2：链接阶段之Preparation（准备）"><a href="#b，环节2：链接阶段之Preparation（准备）" class="headerlink" title="b，环节2：链接阶段之Preparation（准备）"></a>b，环节2：链接阶段之Preparation（准备）</h5><blockquote>
<p><strong>准备阶段（Preparation）</strong>，简言之，<strong>为==类的静态变量==分配内存，并将其初始化为默认值</strong></p>
<ul>
<li><p>Java虚拟机为各类型变量默认的初始值如表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>OL</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>Java并不支持boolean类型，对于boolean类型，内部实现是int，由于int的默认值是0，故对应的，boolean的默认值是false</p>
</li>
<li><p><strong>注意：</strong></p>
<ul>
<li><p><strong>这里不包含基本数据类型的字段用==static final==修饰的情况，因为final在编译的时候就会分配了，准备阶段会显示赋值</strong></p>
</li>
<li><p>注意这里不会为实例变量分配初始化，<strong>类变量会分配在方法区中</strong>，而<strong>实例变量是会随着对象一起分配到Java堆中</strong></p>
</li>
<li><p>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行</p>
<p><img src="/2021/04/05/jvm/155.png" alt></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="c，环节3：链接阶段之Resolution（解析）"><a href="#c，环节3：链接阶段之Resolution（解析）" class="headerlink" title="c，环节3：链接阶段之Resolution（解析）"></a>c，环节3：链接阶段之Resolution（解析）</h5><blockquote>
<ul>
<li><p>在准备阶段完成后，就进入了解析阶段：</p>
</li>
<li><p><strong>解析阶段（Resolution），简而言之，将类、接口、字段和方法的符号引用转为直接引用</strong></p>
</li>
<li><p>具体描述：</p>
<ul>
<li><p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println（）方法被调用时，系统需要明确知道该方法的位置。</p>
</li>
<li><p>举例：输出操作System.out.println()对应的字节码</p>
<p><code>invokevirtual #24 &lt;java/io/PrintStream.println&gt;</code></p>
<p><img src="/2021/04/05/jvm/156.png" alt></p>
<p><img src="/2021/04/05/jvm/157.png" alt></p>
<p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用</strong></p>
</li>
</ul>
</li>
<li><p>小结：</p>
<ul>
<li>所谓解析就是将符号引用转为直接引用，也就是得到类，字段，方法在内存中的指针或者偏移量。因此，可以说，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段，但只存在符号引用，不能确定系统中一定存在该结构。</li>
<li>不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行，在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行。</li>
</ul>
</li>
<li><p><strong>字符串复习</strong></p>
<ul>
<li>最后，再来看一下CONSTANT_String的解析，由于字符串在程序开发中有着重要的作用，因此，有必要了解一下String在Java虚拟机中的处理，<strong>当在Java代码中直接施一公字符串常量时，就会在类中出现CONSTANT_String，</strong>他表示字符串常量，并且会引用一个CONSTANT_UTF8的常量项。<strong>在Java虚拟机内部运行中的常量池中，会维护一张字符串拘留表（intern），他会保存所有出现过的字符串常量，并且没有重复项。</strong>只要以CONSTANT_String形式出现的字符串也都会在这张表中。使用String.intern()方法可以得到一个字符串在拘留表中的引用，因为该表中没有重复项，所以任何字面相同的字符串的String.intern()方法返回总是相等的</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="4，过程三：Initialization（初始化）阶段"><a href="#4，过程三：Initialization（初始化）阶段" class="headerlink" title="4，过程三：Initialization（初始化）阶段"></a>4，过程三：Initialization（初始化）阶段</h4><blockquote>
<p><strong>初始化阶段，简言之，为==类的静态变量==赋予正确的初始值</strong></p>
<ul>
<li><p>具体描述：</p>
<ul>
<li><p>类的初始化是类装载的最后一个阶段，如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中，此时，类才会开始执行Java字节码（即：<strong>到了初始化阶段，才真正开始执行类中定义的Java程序代码）</strong></p>
</li>
<li><p><strong>初始化阶段的重要工作是执行类的初始化方法：&lt;clinit&gt;()方法</strong></p>
<ul>
<li><p>该方法仅能由Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成</p>
</li>
<li><p>它是由类静态成员的赋值语句以及static语句块合并产生的</p>
<p><img src="/2021/04/05/jvm/158.png" alt></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>说明：</p>
<ul>
<li><p>在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的&lt;clinit&gt;总是在子类&lt;clinit&gt;之前被调用。也就是说，父类的static块优先级高于子类</p>
<ul>
<li><p>口诀：由父及子，静态先行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        number = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"father static&#123;&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                                                                                                                                                </span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubInitialization</span> <span class="keyword">extends</span> <span class="title">InitializationTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        number = <span class="number">4</span>;<span class="comment">//number属性必须提前已经加载：一定会先加载父类。</span></span><br><span class="line">        System.out.println(<span class="string">"son static&#123;&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                                                                </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        <span class="comment">//father static&#123;&#125;</span></span><br><span class="line">        <span class="comment">//son static&#123;&#125;</span></span><br><span class="line">        <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Java编译器并不会为所有的类都产生&lt;clinit&gt;()初始化方法，那些类在编译为字节码后，字节码文件中将不会包括&lt;clinit&gt;()方法</p>
<ul>
<li>一个类中并没有声明任何的类变量，也没有静态代码块时</li>
<li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</li>
<li>一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="a，static与final的搭配问题"><a href="#a，static与final的搭配问题" class="headerlink" title="a，static与final的搭配问题"></a>a，static与final的搭配问题</h5><blockquote>
<ul>
<li><p>static不加final的==变量==都在初始化环节赋值</p>
</li>
<li><p>static加final的常量 ——》 static final</p>
<ul>
<li>加static的<ul>
<li>基本型，在链接阶段的准备阶段赋值</li>
<li>引用类型：<ul>
<li>字面量声明在链接的准备阶段赋值（直接赋值常量，而非调用方法）</li>
<li>new等方式在初始化阶段clinit中赋值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>结论：<strong>使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显示赋值，是在链接阶段的准备环节进行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哪些场景下，java编译器就不会生成&lt;clinit&gt;()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//场景1：对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//场景2：静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="comment">//场景3：比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//不加final的变量会生成clinit，加final变为常量就不会</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> num3 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过代码理解static和final的搭配使用情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-09-14 18:55</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</span></span><br><span class="line"><span class="comment"> * 情况1：在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="comment"> * 情况2：在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 在链接阶段的准备环节赋值的情况：</span></span><br><span class="line"><span class="comment"> * 1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> * 2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在初始化阶段&lt;clinit&gt;()中赋值的情况：</span></span><br><span class="line"><span class="comment"> * 排除上述的在准备环节赋值的情况之外的情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最终结论：使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">                                                </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">                                                </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">"helloworld0"</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">"helloworld1"</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">                                                </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s2 = <span class="string">"helloworld2"</span>;</span><br><span class="line">                                                </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">2</span>;<span class="comment">//字面量，在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值，编译阶段确定不了具体值</span></span><br><span class="line">                                                </span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h5 id="b-lt-clinit-gt-的线程安全性"><a href="#b-lt-clinit-gt-的线程安全性" class="headerlink" title="b,&lt;clinit&gt;()的线程安全性"></a>b,&lt;clinit&gt;()的线程安全性</h5><blockquote>
<ul>
<li><p>对于&lt;clinit&gt;()方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性</p>
</li>
<li><p>虚拟机保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁，同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行、&lt;clinit&gt;()方法完毕</p>
</li>
<li><p>正是<strong>因为函数&lt;clinit&gt;()带锁线程安全的，</strong>因此，如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来他们并没有可用的锁信息。</p>
</li>
<li><p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行&lt;clinit&gt;()方法了，那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。</p>
</li>
<li><p>举例：</p>
<ul>
<li><p>loadA线程加载了staticA，staticA加载了staticB</p>
</li>
<li><p>loadB线程加载了staticB，staticB加载了staticA</p>
</li>
<li><p>staticA和staticB都有1s的阻塞，所以当staticA想要加载staticB的时候，staticB已经被loadB线程先加载</p>
</li>
<li><p>所以loadA线程需要等待staticB，而loadB线程也要等待staticA</p>
</li>
<li><p>由此出现了类的交叉加载行为，继而出现了类的死锁行为</p>
</li>
<li><p>程序呈现出僵持状态，输出语句不会打印，相当于程序进入阻塞状态，出现了事实上的死锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死锁举例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.dsh.jvmp2.chapter03.java1.StaticB"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"StaticA init OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.dsh.jvmp2.chapter03.java1.StaticA"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"StaticB init OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                                                                                            </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDeadLockMain</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> flag;</span><br><span class="line">                                                                                            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDeadLockMain</span><span class="params">(<span class="keyword">char</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="keyword">this</span>.setName(<span class="string">"Thread"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                            </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.dsh.jvmp2.chapter03.java1.Static"</span> + flag);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="string">" over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StaticDeadLockMain loadA = <span class="keyword">new</span> StaticDeadLockMain(<span class="string">'A'</span>);</span><br><span class="line">        loadA.start();</span><br><span class="line">        StaticDeadLockMain loadB = <span class="keyword">new</span> StaticDeadLockMain(<span class="string">'B'</span>);</span><br><span class="line">        loadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                            </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="c，类的初始化情况：主动使用-VS-被动使用"><a href="#c，类的初始化情况：主动使用-VS-被动使用" class="headerlink" title="c，类的初始化情况：主动使用 VS 被动使用"></a>c，类的初始化情况：主动使用 VS 被动使用</h5><blockquote>
<p><strong>主动使用：</strong></p>
<ul>
<li><p>Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况:（即:如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。）</p>
<ol>
<li>当创建一个类的实例时，比如使用<strong>new关键字，或者通过反射、克隆、反序列化</strong></li>
<li>当调用类的静态方法时，即<strong>当使用了字节码invokestatic指令</strong></li>
<li>当使用类，接口的静态字段时（final修饰特殊考虑），比如，<strong>使用getstatic或者putstatic指令（对应访问变量、赋值变量操作）</strong></li>
<li>当使用java.lang.reflect包中的方法反射类的方法时，比如：<strong>Class.forName(“com.itfang.java.Test”)</strong></li>
<li>当<strong>初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</strong></li>
<li>如果一个<strong>接口定义了default方法</strong>，那么直接实现或者间接实现该接口的类的初始化。该接口要在其之前被初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个类</li>
<li>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）</li>
</ol>
</li>
<li><p><strong>针对5的补充说明：</strong></p>
<ul>
<li>当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但这条规则并不适用于接口<ul>
<li>在初始化一个类时，并不会先初始化它所实现的接口</li>
<li>在初始化一个接口时，并不会先初始化它的父接口</li>
</ul>
</li>
<li>因此，一个父接口并不会因为它的子接口或实现类的初始化而初始化，只有当程序首次使用特定接口的静态字段时才会导致该接口的初始化</li>
</ul>
</li>
<li><p><strong>针对7的补充说明</strong></p>
<ul>
<li>JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用<code>public static void main（String[]）</code>方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</li>
</ul>
</li>
<li><p>对于1，2的情况举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 测试类的主动使用：意味着会调用类的&lt;clinit&gt;()，即执行了类的初始化阶段</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。</span></span><br><span class="line"><span class="comment"> * 2. 当调用类的静态方法时，即当使用了字节码invokestatic指令。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化的过程：</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"order.dat"</span>));</span><br><span class="line"></span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> Order());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (oos != <span class="keyword">null</span>)</span><br><span class="line">                    oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化的过程：（验证）</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"order.dat"</span>));</span><br><span class="line"></span><br><span class="line">            Order order = (Order) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ois != <span class="keyword">null</span>)</span><br><span class="line">                    ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Order.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Order类的初始化过程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Order method()...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>针对3中的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(User.num);//类初始化了   num是变量</span></span><br><span class="line"><span class="comment">//        System.out.println(User.num1);//类没有初始化 num1是静态常量</span></span><br><span class="line">        System.out.println(User.num2); <span class="comment">//类初始化了 num2不是字面量方式声明的，需要方法调用，编译期间无法确定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(CompareA.NUM1);//接口不需要初始化</span></span><br><span class="line">        System.out.println(CompareA.NUM2);<span class="comment">//接口需要初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"User类的初始化过程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"CompareA的初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM2 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于其他情况的举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类的主动使用其他情况</span></span><br><span class="line"><span class="comment"> * 8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</span></span><br><span class="line"><span class="comment"> * （涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ActiveUse3的初始化过程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">                                              </span><br><span class="line">    <span class="comment">//4、 当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName("com.xxxx.xxx.Test")</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.dsh.jvmp2.chapter03.java1.Order"</span>);</span><br><span class="line">            <span class="comment">//输出语句</span></span><br><span class="line">            <span class="comment">//ActiveUse3的初始化过程</span></span><br><span class="line">            <span class="comment">//Order类的初始化过程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">                                              </span><br><span class="line">    &#125;</span><br><span class="line">                                              </span><br><span class="line">    <span class="comment">//5、 当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</span></span><br><span class="line">    <span class="comment">// 注意：</span></span><br><span class="line">    <span class="comment">// 当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</span></span><br><span class="line">    <span class="comment">// &gt;在初始化一个类时，并不会先初始化它所实现的接口</span></span><br><span class="line">    <span class="comment">// &gt;在初始化一个接口时，并不会先初始化它的父接口</span></span><br><span class="line">    <span class="comment">// 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，</span></span><br><span class="line">    <span class="comment">// 才会导致该接口的初始化。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.num);<span class="comment">//接口CompareD不会初始化</span></span><br><span class="line">        <span class="comment">//依次输出</span></span><br><span class="line">        <span class="comment">//ActiveUse3的初始化过程</span></span><br><span class="line">        <span class="comment">//Father类的初始化过程</span></span><br><span class="line">        <span class="comment">//Son类的初始化过程</span></span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">                                              </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(CompareC.NUM1); <span class="comment">//CompareC父接口CompareB并不会初始化</span></span><br><span class="line">        <span class="comment">//依次输出</span></span><br><span class="line">        <span class="comment">//ActiveUse3的初始化过程</span></span><br><span class="line">        <span class="comment">//CompareC的初始化  -&gt; 子接口初始化了，但是父接口并没有初始化</span></span><br><span class="line">        <span class="comment">//2094196067</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</span></span><br><span class="line">    <span class="comment">// 如果Son2还有子类，根据5,那么其子类的父类，父类的父类也都要被初始化</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Son2.num);</span><br><span class="line">        <span class="comment">//依次输出</span></span><br><span class="line">        <span class="comment">//ActiveUse3的初始化过程</span></span><br><span class="line">        <span class="comment">//Father类的初始化过程</span></span><br><span class="line">        <span class="comment">//CompareB的初始化 -&gt; CompareB接口定义了default方法，所以接口要初始化，注意区分与CompareD的区别</span></span><br><span class="line">        <span class="comment">//Son2类的初始化过程</span></span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">                                                                                            </span><br><span class="line">    <span class="comment">//7. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="comment">//依次输出</span></span><br><span class="line">        <span class="comment">//ActiveUse3的初始化过程</span></span><br><span class="line">        <span class="comment">//hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Father类的初始化过程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">CompareD</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Son类的初始化过程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> <span class="keyword">extends</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">CompareB</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Son2类的初始化过程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"CompareB的初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareC</span> <span class="keyword">extends</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"CompareC的初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareD</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"CompareD的初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>被动使用：</strong></p>
<ul>
<li><p>除了以上的情况属于主动使用，其他的情况均属于被动使用，被动使用不会引起类的初始化</p>
</li>
<li><p>也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化</p>
<ol>
<li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化<ul>
<li>当通过子类引用父类的静态变量，不会导致子类初始化</li>
</ul>
</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发次类或接口的初始化，因为常量在链接阶段就已经被显示赋值了</li>
<li>调用ClassLoader类的loadClass（）方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</li>
</ol>
</li>
<li><p>对于1，2情况的举例；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 关于类的被动使用，即不会进行类的初始化操作，即不会调用&lt;clinit&gt;()</span></span><br><span class="line"><span class="comment"> * 说明：没有初始化的类，不意味着没有加载！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassiveUse1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。</span></span><br><span class="line"><span class="comment">     *    &gt; 当通过子类引用父类的静态变量，不会导致子类初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Child.num);</span><br><span class="line">        <span class="comment">//输出情况</span></span><br><span class="line">        <span class="comment">//Parent的初始化过程  -&gt; 子类不需要初始化</span></span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 通过数组定义类引用，不会触发此类的初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Parent[] parents = <span class="keyword">new</span> Parent[<span class="number">10</span>];<span class="comment">//不打印 —&gt; 没有初始化，运行时才会加载进来</span></span><br><span class="line">        System.out.println(parents.getClass());<span class="comment">//class [Lcom.dsh.jvmp2.chapter03.java1.Parent;</span></span><br><span class="line">        System.out.println(parents.getClass().getSuperclass());<span class="comment">//class java.lang.Object</span></span><br><span class="line">        parents[<span class="number">0</span>] = <span class="keyword">new</span> Parent();<span class="comment">//Parent的初始化过程    -&gt; 类初始化</span></span><br><span class="line">        parents[<span class="number">1</span>] = <span class="keyword">new</span> Parent();<span class="comment">//不打印 -&gt; 类已经初始化过了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent的初始化过程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Child的初始化过程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于3，4情况的举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassiveUse2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(Person.NUM);// 不会触发Person类的初始化</span></span><br><span class="line">        System.out.println(Person.NUM1);<span class="comment">// 触发了Person类的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">                                              </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(SerialA.ID);//接口同理 使用SerialA.ID不会触发SerialA的初始化</span></span><br><span class="line">        System.out.println(SerialA.ID1);<span class="comment">//接口同理 ID1会触发SerialA的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">                                              </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4. 调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不会触发Person类的初始化，被动使用</span></span><br><span class="line">            Class clazz = ClassLoader.getSystemClassLoader().loadClass(<span class="string">"com.dsh.jvmp2.chapter03.java1.Person"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                                              </span><br><span class="line">&#125;</span><br><span class="line">                                              </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person类的初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">1</span>;<span class="comment">//在链接过程的准备环节就被赋值为1了。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//此时的赋值操作需要在&lt;clinit&gt;()中执行</span></span><br><span class="line">&#125;</span><br><span class="line">                                              </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SerialA</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"SerialA的初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">                                              </span><br><span class="line">    <span class="keyword">int</span> ID = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ID1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//此时的赋值操作需要在&lt;clinit&gt;()中执行</span></span><br><span class="line">&#125;</span><br><span class="line">                                              </span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="5，过程四，类的Using使用"><a href="#5，过程四，类的Using使用" class="headerlink" title="5，过程四，类的Using使用"></a>5，过程四，类的Using使用</h4><blockquote>
<ul>
<li><p>任何一个类型在使用之前都必须经历过完整的<strong>加载、链接和初始化</strong>3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“万事俱备，只欠东风”，就等着开发者使用了。</p>
</li>
<li><p>开发人员可以在程序中访问和调用它的静态类成员信息（比如:静态字段、静态方法），或者使用new关键字为其创建对象实例。</p>
</li>
<li><p>例：加载一个类时，以Order类为例：</p>
<ul>
<li><p>方法区存放Order类模板数据/对象</p>
</li>
<li><p>堆空间中创建一个Order类的Class实例，这个实例指向了方法区中的类模板对象</p>
</li>
<li><p>栈中（栈帧的局部变量表中）中声明了一个class对象，class对象指向了堆空间中的Class实例</p>
</li>
<li><p>Order的对象实例存放在堆中</p>
</li>
<li><p>如图所示</p>
<p><img src="/2021/04/05/jvm/159.png" alt></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="6，过程五，类的Unloading（卸载）"><a href="#6，过程五，类的Unloading（卸载）" class="headerlink" title="6，过程五，类的Unloading（卸载）"></a>6，过程五，类的Unloading（卸载）</h4><blockquote>
<p>类存在于方法区中，jdk8中方法区的落地实现是元空间，元空间使用的是系统内存，所以当类没有被及时卸载时，可能会出现方法区的OOM</p>
</blockquote>
<h5 id="a，类，类的加载器，类的实例之间的引用关系"><a href="#a，类，类的加载器，类的实例之间的引用关系" class="headerlink" title="a，类，类的加载器，类的实例之间的引用关系"></a>a，类，类的加载器，类的实例之间的引用关系</h5><blockquote>
<ul>
<li>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader（）方法，就能获得它的类加载器。由此可见，<strong>代表某个类的Class实例与其类的加载器之间为双向关联关系。</strong></li>
<li>一个类的实例总是引用代表这个类的Class对象。在0bject类中定义了<strong>getClass（）方法，这个方法返回代表对象所属类的Class对象的引用</strong>。此外，<strong>所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。</strong></li>
</ul>
</blockquote>
<h5 id="b，类的生命周期"><a href="#b，类的生命周期" class="headerlink" title="b，类的生命周期"></a>b，类的生命周期</h5><blockquote>
<ul>
<li><p>当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。</p>
</li>
<li><p><strong>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</strong></p>
</li>
</ul>
</blockquote>
<h5 id="c，具体例子"><a href="#c，具体例子" class="headerlink" title="c，具体例子"></a>c，具体例子</h5><p><img src="/2021/04/05/jvm/160.png" alt></p>
<ul>
<li>loader1变量和obj变量间接应用代表Sample类的Class对象，而objClass变量则直接引用它。</li>
<li>如果程序运行过程中,将上图左侧三个引用变量都置为nu1,此时Sample对象结束生命周期, Myclass Loader对象结束生命周期,代表SampleClass类的对象也结束生命周期, Sample类在方法区内的二进制数据被卸载。</li>
<li>当再次有需要时,会检查Sample类的Clas对象是否存在,如果存在会直接使用,不再重新加载;如果不存在 Sample类会被重新加载,在Java虚拟机的堆区会生成一个新的代表 SampleClass类的实例(可以通过哈希码查看是否是同一个实例)。</li>
</ul>
<h5 id="d，类的加载："><a href="#d，类的加载：" class="headerlink" title="d，类的加载："></a>d，类的加载：</h5><blockquote>
<ul>
<li>启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范)</li>
<li>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载,因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到,其达到 unreachable的可能性极小。</li>
<li>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载,而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想,稍微复杂点的应用场景中(比如:很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能),被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。</li>
<li>综合以上三点,<strong>一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的</strong>。同时我们可以看的出来,开发者在开发代码时候,不应该对虚拟机的类型卸载做任何假设的前提下,来实现系统中的特定功能。</li>
</ul>
</blockquote>
<h5 id="e，回顾：方法区的垃圾回收"><a href="#e，回顾：方法区的垃圾回收" class="headerlink" title="e，回顾：方法区的垃圾回收"></a>e，回顾：方法区的垃圾回收</h5><blockquote>
<ul>
<li><strong>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</strong></li>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</li>
<li>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了，需要同时满足下面三个条件：<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类以及任何派生子类的实例</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
</li>
<li><strong>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</strong></li>
</ul>
</blockquote>
<h4 id="7，大厂面试题："><a href="#7，大厂面试题：" class="headerlink" title="7，大厂面试题："></a>7，大厂面试题：</h4><p><strong>蚂蚁金服：</strong></p>
<blockquote>
<p>描述一下JVM加载Class文件的原理机制</p>
<p>一面：类加载过程</p>
</blockquote>
<p><strong>百度</strong></p>
<blockquote>
<p>类加载的时机</p>
<p>Java类加载过程</p>
<p>简述Java加载机制</p>
</blockquote>
<p><strong>腾讯</strong></p>
<blockquote>
<p>JVM中类加载机制，类加载过程？</p>
</blockquote>
<p><strong>滴滴</strong></p>
<blockquote>
<p>JVM类加载机制</p>
</blockquote>
<p><strong>美团</strong></p>
<blockquote>
<p>Java类加载过程</p>
<p>描述一下JVM加载class文件的原理机制</p>
</blockquote>
<p><strong>京东</strong></p>
<blockquote>
<p>什么是类的加载</p>
<p>哪些情况会触发类的加载</p>
<p>讲一下JVM加载一个类的过程</p>
<p>JVM的类加载机制是什么</p>
</blockquote>
<h3 id="四、类加载器"><a href="#四、类加载器" class="headerlink" title="四、类加载器"></a>四、类加载器</h3><blockquote>
<p>类加载是JVM执行类加载机制的前提</p>
<p><strong>ClassLoader的作用：</strong></p>
<ul>
<li><p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，<strong>ClassLoader在整个装载阶段，只能影响到类的加载</strong>，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。</p>
<p><img src="/2021/04/05/jvm/161.png" alt></p>
<p>类加载器最早出现在Java1.0版本中，那个时候只是单纯地为了满足Java Applet应用而被研发出来。但如今类加载器却在0SGi、字节码加解密领域大放异彩。这主要归功于Java虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在JVM内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</p>
</li>
</ul>
</blockquote>
<h4 id="1，概述-1"><a href="#1，概述-1" class="headerlink" title="1，概述"></a>1，概述</h4><h5 id="a，类加载的分类"><a href="#a，类加载的分类" class="headerlink" title="a，类加载的分类"></a>a，类加载的分类</h5><blockquote>
<ul>
<li><p>类的加载分类：<strong>显示加载 VS 隐式加载</strong></p>
</li>
<li><p>class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。</p>
<ul>
<li><p>显示加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用<code>Class.forName（name）</code>或<code>this.getClass().getClassLoader().loadClass()</code>加载class对象</p>
</li>
<li><p>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</p>
</li>
<li><p>在日常开发以上两种方式一般会混合使用</p>
</li>
<li><p><strong>举例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(); <span class="comment">//隐式加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.dsh.jvmp2.chapter04.java.User"</span>); <span class="comment">//显式加载</span></span><br><span class="line">            ClassLoader.getSystemClassLoader().loadClass(<span class="string">"com.dsh.jvmp2.chapter04.java.User"</span>);<span class="comment">//显式加载</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="b，类加载的必要性"><a href="#b，类加载的必要性" class="headerlink" title="b，类加载的必要性"></a>b，类加载的必要性</h5><blockquote>
<p>一般情况下，Java开发人员并不需要在程序中显示地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说:</p>
<ul>
<li>避免在开发中遇到<code>java.lang.ClassNotFoundException</code>异常或<code>java.lang.NoClassDefFoundError</code>异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</li>
<li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li>
</ul>
</blockquote>
<h5 id="c，命名空间"><a href="#c，命名空间" class="headerlink" title="c，命名空间"></a>c，命名空间</h5><blockquote>
<p><strong>何为类的唯一性？</strong></p>
<ul>
<li>对于任意一个类，<strong>都需要由加载他的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性</strong>。每个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只要在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类源自同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等</li>
</ul>
<p><strong>命名空间</strong></p>
<ul>
<li>每个类加载器都有自己的命名空间，命名空间由<strong>该加载器及所有的父加载器所加载的类</strong>组成</li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li>
</ul>
<p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String rootDir = <span class="string">"/Users/dongshuhuan/JavaProjects/JVM_study/src"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建自定义的类的加载器1</span></span><br><span class="line">        UserClassLoader loader1 = <span class="keyword">new</span> UserClassLoader(rootDir);</span><br><span class="line">        Class clazz1 = loader1.findClass(<span class="string">"com.dsh.jvmp2.chapter04.java.User"</span>);</span><br><span class="line">        <span class="comment">//创建自定义的类的加载器2</span></span><br><span class="line">        UserClassLoader loader2 = <span class="keyword">new</span> UserClassLoader(rootDir);</span><br><span class="line">        Class clazz2 = loader2.findClass(<span class="string">"com.dsh.jvmp2.chapter04.java.User"</span>);</span><br><span class="line">        System.out.println(clazz1 == clazz2); <span class="comment">//false clazz1与clazz2对应了不同的类模板结构。</span></span><br><span class="line">  		System.out.println(clazz1.getClassLoader());</span><br><span class="line">        <span class="comment">//com.dsh.jvmp2.chapter04.java.UserClassLoader@1d44bcfa</span></span><br><span class="line">        System.out.println(clazz2.getClassLoader());</span><br><span class="line">        <span class="comment">//com.dsh.jvmp2.chapter04.java.UserClassLoader@6f94fa3e</span></span><br><span class="line">        <span class="comment">//######################</span></span><br><span class="line">        Class clazz3 = ClassLoader.getSystemClassLoader().loadClass(<span class="string">"com.dsh.jvmp2.chapter04.java.User"</span>);</span><br><span class="line">        System.out.println(clazz3.getClassLoader());</span><br><span class="line">        <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//自定义类加载器的父类就是系统类加载器</span></span><br><span class="line">        System.out.println(clazz1.getClassLoader().getParent());</span><br><span class="line">        <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="d，类加载机制的基本特征"><a href="#d，类加载机制的基本特征" class="headerlink" title="d，类加载机制的基本特征"></a>d，类加载机制的基本特征</h5><blockquote>
<p>通常类加载机制有三个基本特征:</p>
<ul>
<li><strong>双亲委派模型：</strong>但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的<code>ServiceProvider/ServiceLoader</code>机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如：Java中JNDI，JDBC，文件系统，Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器</li>
<li><strong>可见性</strong>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，不然，因为缺少必要的隔离，我们就没办法利用类加载器去实现容器的逻辑</li>
<li><strong>单一性</strong>：由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载，但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相不可见</li>
</ul>
</blockquote>
<h4 id="2，类加载器的分类"><a href="#2，类加载器的分类" class="headerlink" title="2，类加载器的分类"></a>2，类加载器的分类</h4><blockquote>
<ul>
<li><p>JVM支持两种类型的类加载器，分别为<strong>引导类加载器（Bootstrap ClassLoader）</strong> 和<strong>自定义类加载器（User一Defined ClassLoader）</strong>。</p>
</li>
<li><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况:</p>
<p><img src="/2021/04/05/jvm/162.png" alt></p>
</li>
<li><p>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</p>
</li>
<li><p>不同类加载器看似是继承（Inheritance）关系，实际上<strong>是包含关系</strong>。在下层加载器中，包含着上层加载器的引用,如代码所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    ClassLoader parent;<span class="comment">//父类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;<span class="comment">//parent = new ParentClassLoader()</span></span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                                          </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                                          </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;<span class="comment">//parent = new ParentClassLoader();</span></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h5 id="a，引导类加载器"><a href="#a，引导类加载器" class="headerlink" title="a，引导类加载器"></a>a，引导类加载器</h5><blockquote>
<p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p>
<ul>
<li><p>这个类加载使用<strong>C/C++语言实现</strong>的，嵌套在JVM内部</p>
</li>
<li><p>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jarbsun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</p>
</li>
<li><p>并不继承自<code>java.lang.ClassLoader</code>，没有父加载器。</p>
</li>
<li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
</li>
<li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。<br><img src="/2021/04/05/jvm/163.png" alt></p>
<p>​    使用-XX:+TraceClassLoading参数得到</p>
</li>
<li><p>C/C++：指针函数&amp;函数指针、C++支持多继承，更加高效</p>
</li>
<li><p>Java：由C++演变而来，（C++）–版，单继承</p>
</li>
</ul>
</blockquote>
<h5 id="b，扩展类加载器"><a href="#b，扩展类加载器" class="headerlink" title="b，扩展类加载器"></a>b，扩展类加载器</h5><blockquote>
<p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
<ul>
<li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p>
</li>
<li><p>继承于ClassLoader类、</p>
</li>
<li><p>父类加载器为启动类加载器</p>
</li>
<li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p>
<p><img src="/2021/04/05/jvm/164.png" alt></p>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"**********启动类加载器**************"</span>);</span><br><span class="line">        <span class="comment">//获取BootstrapClassLoader能够加载的api的路径</span></span><br><span class="line">        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span></span><br><span class="line">        ClassLoader classLoader = java.security.Provider<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//null  引导类加载器是获取不到的</span></span><br><span class="line">        System.out.println(<span class="string">"***********扩展类加载器*************"</span>);</span><br><span class="line">        String extDirs = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : extDirs.split(<span class="string">";"</span>)) &#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span></span><br><span class="line">        ClassLoader classLoader1 = sun.security.ec.CurveDB<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(classLoader1);</span><br><span class="line">        <span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">**********启动类加载器**************</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_171</span>.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_171</span>.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_171</span>.jdk/Contents/Home/jre/lib/sunrsasign.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_171</span>.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_171</span>.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_171</span>.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_171</span>.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_171</span>.jdk/Contents/Home/jre/classes</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">***********扩展类加载器*************</span><br><span class="line">/Users/dongshuhuan/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_171</span>.jdk/Contents/Home/jre/lib/ext:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">4</span>b1210ee</span><br><span class="line">                                          </span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h5 id="c，系统类加载器"><a href="#c，系统类加载器" class="headerlink" title="c，系统类加载器"></a>c，系统类加载器</h5><blockquote>
<p><strong>系统类加载器(AppClassLoader)</strong></p>
<ul>
<li><p>java语言编写，由sun.misc.Launcher$AppClassLoader实现</p>
</li>
<li><p>继承于ClassLoader类</p>
</li>
<li><p>父类加载器为扩展类加载器</p>
</li>
<li><p>它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库</p>
</li>
<li><p>应用程序中的类加载器默认是系统类加载器。</p>
</li>
<li><p>它是用户自定义类加载器的默认父加载器</p>
</li>
<li><p>通过ClassLoader的getSystemClassLoader（）方法可以获取到该类加载器</p>
</li>
</ul>
</blockquote>
<h5 id="d，用户自定义类加载器"><a href="#d，用户自定义类加载器" class="headerlink" title="d，用户自定义类加载器"></a>d，用户自定义类加载器</h5><blockquote>
<p><strong>用户自定义类加载器</strong></p>
<ul>
<li>在]ava的日常应用程序开发中,类的加载几乎是由上述3种类加载器相互配合执行的。在必要时,我们还可以自定义类加载器,来定制类的加载方式。</li>
<li>体现Java语言强大生命力和巨大魅力的关键因素之一便是,Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包,也可以是网络上的远程资源。</li>
<li>通过类加载器可以实现非常绝妙的插件机制,这方面的实际应用案例举不胜举。例如,著名的SGI组件框架,再如，Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制,这种机制无须重新打包发布应用程序就能实现。</li>
<li>同时,自定义加载器能够实现应用隔离,例如 Tomcat, Spring等中间件和组件框架都在内部实现了自定义的加载器,并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多,想不修改C/C++程序就能为其新 增功能,几乎是不可能的,仅仅一个兼容性便能阻挡住所有美好的设想。</li>
<li>自定义类加载器通常需要继承于classLoader</li>
</ul>
</blockquote>
<h4 id="3，测试不同的类加载器"><a href="#3，测试不同的类加载器" class="headerlink" title="3，测试不同的类加载器"></a>3，测试不同的类加载器</h4><blockquote>
<p>每个Class对象都会包含一个定义它的ClassLoader的一个引用</p>
<p>获取ClassLoader的途径</p>
<table>
<thead>
<tr>
<th>获得当前类的ClassLoader：clazz.getClassLoader()</th>
</tr>
</thead>
<tbody><tr>
<td>获得当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</td>
</tr>
<tr>
<td>获得系统的ClassLoader：ClassLoader.getSystemClassLoder()</td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li><p>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。</p>
</li>
<li><p>数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器来说，是通过Class.getClassLoader（）返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统该类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line">        <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//获取扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);</span><br><span class="line">        <span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line">        <span class="comment">//试图获取引导类加载器：失败</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line">                                          </span><br><span class="line">        <span class="comment">//###########################</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">"java.lang.String"</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);<span class="comment">//null</span></span><br><span class="line">            <span class="comment">//自定义的类默认使用系统类加载器</span></span><br><span class="line">            ClassLoader classLoader1 = Class.forName(<span class="string">"com.dsh.jvmp2.chapter04.java.ClassLoaderTest1"</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line">            <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">                                          </span><br><span class="line">            <span class="comment">//关于数组类型的加载:使用的类的加载器与数组元素的类的加载器相同</span></span><br><span class="line">            String[] arrStr = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrStr.getClass().getClassLoader());<span class="comment">//null:表示使用的是引导类加载器</span></span><br><span class="line">                                          </span><br><span class="line">            ClassLoaderTest1[] arr1 = <span class="keyword">new</span> ClassLoaderTest1[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr1.getClass().getClassLoader());</span><br><span class="line">            <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">                                          </span><br><span class="line">            <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr2.getClass().getClassLoader());</span><br><span class="line">            <span class="comment">//null:基本数据类型不需要类的加载器（虚拟机预先定义）</span></span><br><span class="line">            System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line">            <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</blockquote>
<h4 id="4，ClassLoader源码解析"><a href="#4，ClassLoader源码解析" class="headerlink" title="4，ClassLoader源码解析"></a>4，ClassLoader源码解析</h4><blockquote>
<p><strong>ClassLoader与现有类加载器的关系</strong></p>
<p><img src="/2021/04/05/jvm/165.png" alt></p>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
</blockquote>
<h5 id="a，ClassLoader的主要方法"><a href="#a，ClassLoader的主要方法" class="headerlink" title="a，ClassLoader的主要方法"></a>a，ClassLoader的主要方法</h5><blockquote>
<p>抽象类 classLoader的主要方法:(内部没有抽象方法)</p>
<ul>
<li><p><code>public final classLoader getParent()</code>返回该类加载器的超类加载器</p>
</li>
<li><p><code>public Class&lt;?&gt; loadclass(String name) throws ClassNotFoundException</code>     加载名称为name的类,返回结果为java.lang.Class类的实例。如果找不到类,则返回classNotFoundException异常。该方法中的逻辑就是<strong>双亲委派模式的实现</strong>。</p>
</li>
<li><p><code>protected Class&lt;?&gt; findclass（String name） throws ClassNotFoundException</code>     查找二进制名称为name的类，返回结果为java.1ang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass（）方法调用。</p>
<ul>
<li>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在IDK1.2之后已不再建议用户去覆盖loadClass（）方法，而是建议把自定义的类加载逻辑写在findClass（）方法中，从前面的分析可知， findClass（）方法是在loadClass（）方法中被调用的，当 loadClass（）方法中父加载器加载失败后，则会调用自己的findClass（）方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</li>
<li>需要注意的是ClassLoader类中并没有实现findClass（）方法的具体代码逻辑，取而代之的是抛出 <code>ClassNotFoundException</code>异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。<strong>一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass（）方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass（）方法生成类的Class对象。</strong></li>
</ul>
</li>
<li><p><code>protected final Class&lt;?&gt; defineClass（String name， byte[] b， int off， int len）</code>：根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</p>
<ul>
<li><p>defineClass（）方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中己实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。        defineClass（）方法通常与findClass（）方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader的findClass（）方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象</p>
</li>
<li><p>简单举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findclass（String name） <span class="keyword">throws</span> ClassNotFoundException&#123;         <span class="comment">//获取类的字节数组         </span></span><br><span class="line">    <span class="keyword">byte</span>[] classData = getclassData（name）;   </span><br><span class="line">    <span class="keyword">if</span> （classData == <span class="keyword">null</span>） &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException（）；     </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;          </span><br><span class="line">        <span class="comment">//使用defineClass生成class对象      </span></span><br><span class="line">        <span class="keyword">return</span> defineclass（name， classData， <span class="number">0</span>， classData.length）;         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>protected final void resolveclass(Class&lt;?&gt; c)</code>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p>
</li>
<li><p><code>protected final Class&lt;?&gt; findLoadedClass(String name)</code>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</p>
</li>
<li><p><code>private final ClassLoader parent;</code>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</p>
</li>
<li><p><strong>loadClass方法解析：</strong></p>
<p>ClassLoader.getSystemClassLoader().loadClass(“com.dsh.jvmp2.chapter04.java.User”);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先，在缓存中检查是否已经加载同名类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取当前类加载器的父类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果存在父类加载器，则调用父类加载器进行类的加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//父类加载器是引导类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">                                          </span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;<span class="comment">//当前类的加载器的父类加载器未加载此类 or 当前类的加载器未加载此类</span></span><br><span class="line">                <span class="comment">// 调用当前classLoader的findClass方法</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                                          </span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否进行过解析操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                                          </span><br></pre></td></tr></table></figure>


</li>
</ul>
</blockquote>
<h5 id="b，SecureClassLoader与URLClassLoader"><a href="#b，SecureClassLoader与URLClassLoader" class="headerlink" title="b，SecureClassLoader与URLClassLoader"></a>b，SecureClassLoader与URLClassLoader</h5><blockquote>
<ul>
<li><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类 URLClassLoader有所关联。</p>
</li>
<li><p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如 findClass（）、findResource（）等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。<strong>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类</strong>，这样就可以避免自己去编写findClass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<p><img src="/2021/04/05/jvm/166.png" alt="image-20210524165656651"></p>
</li>
</ul>
</blockquote>
<h5 id="c，ExtClassLoader与AppClassLoader"><a href="#c，ExtClassLoader与AppClassLoader" class="headerlink" title="c，ExtClassLoader与AppClassLoader"></a>c，ExtClassLoader与AppClassLoader</h5><blockquote>
<ul>
<li><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和系统类加载器AppClassLoader，这两个类都继承自URLClassLoader，是sun.misc.Launcher的静态内部类。 sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下:</p>
<p><img src="/2021/04/05/jvm/167.png" alt="image-20210524170053477"></p>
<p>我们发现ExtClassLoader并没有重写1oadClass（）方法，这足矣说明其遵循双亲委派模退，而AppClassLoader重载了loadClass（）方法，但最终调用的还是父类1oadClass（）方法，因此依然遵守双亲委派模式。</p>
</li>
</ul>
</blockquote>
<h5 id="d，Class-forName-与ClassLoader-loadClass"><a href="#d，Class-forName-与ClassLoader-loadClass" class="headerlink" title="d，Class.forName()与ClassLoader.loadClass()"></a>d，Class.forName()与ClassLoader.loadClass()</h5><blockquote>
<ul>
<li>Class.forName（）:是一个静态方法，最常用的是Class.forName（String className）；根据传入的类的全限定名返回一个Class对象。<strong>该方法在将 Class 文件加载到内存的同时，会执行类的初始化</strong>。如:Class.forName（”com.atguigu.java.HelloWorld”）；</li>
<li>ClassLoader.loadClass（）:这是一个实例方法，需要一个ClassLoader对象来调用该方法<strong>。该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。</strong>该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器.如:ClassLoader cl=……；cl.loadClass（”com.atguigu.java.HelloWorld”）；</li>
</ul>
</blockquote>
<h4 id="5，双亲委派模型"><a href="#5，双亲委派模型" class="headerlink" title="5，双亲委派模型"></a>5，双亲委派模型</h4><blockquote>
<p>类加载器用来把类加载到Java虚拟机中。从IDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</p>
</blockquote>
<h5 id="a，定义与本质"><a href="#a，定义与本质" class="headerlink" title="a，定义与本质"></a>a，定义与本质</h5><blockquote>
<ul>
<li><p><strong>定义：</strong></p>
<ul>
<li>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回，只有父类加载器无法完成此加载任务时，才自己去加载</li>
</ul>
</li>
<li><p><strong>本质：</strong></p>
<ul>
<li><p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载</p>
<p><img src="/2021/04/05/jvm/168.png" alt></p>
<p><img src="/2021/04/05/jvm/169.png" alt></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="b，优势与劣势"><a href="#b，优势与劣势" class="headerlink" title="b，优势与劣势"></a>b，优势与劣势</h5><blockquote>
<p><strong>优势：</strong></p>
<ul>
<li>避免类的重复加载，确保一个类的全局唯一性<ul>
<li><strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，</strong>当父亲已经加载了该类，就没有必要子加载器再加载一次</li>
</ul>
</li>
<li>保护程序安全，防止核心API被随意篡改</li>
</ul>
<p>代码支持</p>
<ul>
<li><p>双亲委派机制在<code>java.lang.ClassLoadelr.loadClass（String，boolean）</code>接口中体现。该接口的逻辑如下:</p>
<ol>
<li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li>
<li>判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass（name， false）接口进行加载。</li>
<li>反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassOrNull（name）接口，让引导类加载器进行加载。如果通过以上3条路径都没能成功加载，则调用findClass（name）接口进行加载。该接口最终会调用</li>
<li>如果通过以上3条路径都没能成功加载，则调用<code>findClass（name）</code>接口进行加载。该接口最终会调用</li>
</ol>
<p>java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。 双亲委派的模型就隐藏在这第2和第3步中。</p>
</li>
</ul>
<p>举例；</p>
<ul>
<li>假设当前加载的是java.lang.Object这个类，很显然，该类属于IDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载javaJang.0bject时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载</li>
</ul>
<p>思考：</p>
<ul>
<li>如果在自定义的类加载器中重写<code>java.lang.ClassLoader.loadClass（String）</code>或 <code>java.lang.ClassLoader.loadClass（String， boolean）</code>方法，抹去其中的双亲委派机制，仅保留上面这4步中的第1步与第4步，那么是不是就能够加载核心类库了呢？</li>
<li>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用<code>java.lang.ClassLoader.defineClass（String， byte[]， int， int，ProtectionDomain）</code>方法，而该方法会执行<code>preDefineClass（）</code>接口，该接口中提供了对JDK核心类库的保护。</li>
</ul>
<p>双亲委派模式的弊端</p>
<ul>
<li>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</li>
<li>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</li>
</ul>
<p>结论：</p>
<ul>
<li><strong>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</strong></li>
<li>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</li>
</ul>
</blockquote>
<h5 id="c，破坏双亲委派机制"><a href="#c，破坏双亲委派机制" class="headerlink" title="c，破坏双亲委派机制"></a>c，破坏双亲委派机制</h5><blockquote>
<p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
</blockquote>
<p><strong>第一次破坏双亲委派机制</strong></p>
<blockquote>
<p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一一即JDK1.2面世以前的“远古”时代。</p>
<p>由于双亲委派模型在JDK1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass（）被子类覆盖的可能性，只能在IDK1.2之后的java.lang.ClassLoader中<strong>添加一个新的protected方法findClass（），并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass（）中编写代码</strong>。上节我们已经分析过1oadClass（）方法，双亲委派的具体逻辑就实现在这里面，按照1oadClass（）方法的逻辑，如果父类加载失败，会自动调用自己的findClass（）方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
</blockquote>
<p><strong>第二次破坏双亲委派机制：线程上下文加载器</strong></p>
<blockquote>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<strong>越基础的类由越上层的加载器进行加载</strong>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，<strong>如果有基础类型又要调用回用户的代码，那该怎么办呢？</strong></p>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的INDI服务提供者接口（ Service Provider Interface， SPI）的代码，现在问题来了，<strong>启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</strong>（SPI:在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计:<strong>线程上下文类加载器（Thread ContextClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader（）方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</strong></p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<strong>这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</strong>，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在IDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF/ services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<p><img src="/2021/04/05/jvm/170.png" alt></p>
<p>默认上下文加载器就是应用类加载器,这样以上下文加载器为中介,使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>
</blockquote>
<p><strong>第三次破坏双亲委派机制：</strong></p>
<blockquote>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如:<strong>代码热替换（Hot Swap）</strong>、<strong>模块热部署（Hot Deployment）</strong>等</p>
<p>IBM公司主导的JSR一291 （即OSGiR4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<strong>网状结构</strong>。</p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索:</p>
<ol>
<li><strong>将以java.*开头的类，委派给父类加载器加载。</strong></li>
<li><strong>否则，将委派列表名单内的类，委派给父类加载器加载。</strong></li>
<li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<p>说明:只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p>
</blockquote>
<p><strong>小结：</strong></p>
<blockquote>
<p>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p>
<p>正如:OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了0SGi的实现，就算是掌握了类加载器的精粹</strong>。</p>
</blockquote>
<h5 id="d，热替换的实现"><a href="#d，热替换的实现" class="headerlink" title="d，热替换的实现"></a>d，热替换的实现</h5><blockquote>
<p>热替换是指在程序中的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热<strong>替换的关键需求在于服务不能中断</strong>，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器</p>
<p>但对Java来说，热替换并非天生就支持，++如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类++。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>注意:由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</p>
<p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示:</p>
<p><img src="/2021/04/05/jvm/171.png" alt></p>
</blockquote>
<p>热替换实现代码</p>
<blockquote>
<p>程序的执行过程时每隔5秒进行一次输出</p>
<ol>
<li>首先在Demo1中定义输出方法，使用javac编译为class</li>
<li>运行程序，输出<code>OldDemo1</code></li>
<li>修改Demo1中的输出方法，使用javac再次编译为class文件，此时class文件发生了替换</li>
<li>观察程序输出,程序输出了<code>OldDemo1---&gt; NewDemo1</code></li>
</ol>
<p><img src="/2021/04/05/jvm/172.png" alt></p>
<p>Demo1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hot</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println("OldDemo1");//替换前输出</span></span><br><span class="line">        System.out.println(<span class="string">"OldDemo1---&gt; NewDemo1"</span>);<span class="comment">//替换后输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义的类加载器MyClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义类的加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = <span class="keyword">this</span>.findLoadedClass(className);</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">null</span>;</span><br><span class="line">        WritableByteChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == clazz) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String classFile = getClassFile(className);</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">                fileChannel = fis.getChannel();</span><br><span class="line">                ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                outChannel = Channels.newChannel(baos);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = fileChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    outChannel.write(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">                clazz = defineClass(className, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fileChannel != <span class="keyword">null</span>)</span><br><span class="line">                        fileChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>)</span><br><span class="line">                        outChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类文件的完全路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClassFile</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + <span class="string">"/"</span> + className.replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试代码LoopRun</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopRun</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1. 创建自定义类加载器的实例</span></span><br><span class="line">                String rootDir = <span class="string">"/Users/dongshuhuan/JavaProjects/JVM_study/src"</span>;</span><br><span class="line">                MyClassLoader loader = <span class="keyword">new</span> MyClassLoader(rootDir);</span><br><span class="line">                <span class="comment">//2. 加载指定的类</span></span><br><span class="line">                Class clazz = loader.findClass(<span class="string">"com.dsh.jvmp2.chapter04.java1.Demo1"</span>);</span><br><span class="line">                <span class="comment">//3. 创建运行时类的实例</span></span><br><span class="line">                Object demo = clazz.newInstance();</span><br><span class="line">                <span class="comment">//4. 获取运行时类中指定的方法</span></span><br><span class="line">                Method m = clazz.getMethod(<span class="string">"hot"</span>);</span><br><span class="line">                <span class="comment">//5. 调用指定的方法</span></span><br><span class="line">                m.invoke(demo);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"not find"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="6，沙箱安全机制"><a href="#6，沙箱安全机制" class="headerlink" title="6，沙箱安全机制"></a>6，沙箱安全机制</h4><blockquote>
<ul>
<li><p>沙箱安全机制：</p>
<ul>
<li>保证程序安全</li>
<li>保护Java原生的JDK代码</li>
</ul>
</li>
<li><p><strong>Java安全模型的核心就是Java沙箱（sandbox）</strong>。什么是沙箱？沙箱是一个限制程序运行的环境。</p>
</li>
<li><p>沙箱机制就是<strong>将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</strong></p>
</li>
<li><p>沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>
</li>
<li><p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p>
</li>
</ul>
</blockquote>
<h5 id="a，JDK1-0时期"><a href="#a，JDK1-0时期" class="headerlink" title="a，JDK1.0时期"></a>a，JDK1.0时期</h5><blockquote>
<p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱（ Sandbox）机制。如下图所示JDK1.0安全模型</p>
<p><img src="/2021/04/05/jvm/173.png" alt="image-20210524180535116"></p>
</blockquote>
<h5 id="b，JDK1-1时期"><a href="#b，JDK1-1时期" class="headerlink" title="b，JDK1.1时期"></a>b，JDK1.1时期</h5><blockquote>
<ul>
<li><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p>
</li>
<li><p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型</p>
<p><img src="/2021/04/05/jvm/174.png" alt="image-20210524180651470"></p>
</li>
</ul>
</blockquote>
<h5 id="c，JDK1-2时期"><a href="#c，JDK1-2时期" class="headerlink" title="c，JDK1.2时期"></a>c，JDK1.2时期</h5><blockquote>
<p>在Java1.2版本中,再次改进了安全机制,增加了<strong>代码签名。</strong>不论本地代码或是远程代码,都会按照用户的安全策略设定,由类加载器加载到虚拟机中权限不同的运行空间,来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型：</p>
<p><img src="/2021/04/05/jvm/175.png" alt="image-20210524180802670"></p>
</blockquote>
<h5 id="d，JDK1-6时期"><a href="#d，JDK1-6时期" class="headerlink" title="d，JDK1.6时期"></a>d，JDK1.6时期</h5><blockquote>
<p>当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。</p>
<p>虚拟机会把所有代码加载到不同的系统域和应用域。<strong>系统域部分专门负责与关键资源进行交互</strong>，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限 （Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）</p>
<p><img src="/2021/04/05/jvm/176.png" alt="image-20210524180935584"></p>
</blockquote>
<h4 id="7，自定义类的加载器"><a href="#7，自定义类的加载器" class="headerlink" title="7，自定义类的加载器"></a>7，自定义类的加载器</h4><p><strong>为什么要自定义类加载器</strong></p>
<blockquote>
<ul>
<li><strong>隔离加载器</strong><ul>
<li>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如:阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如:Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。（类的仲裁–&gt;类冲突）</li>
</ul>
</li>
<li><strong>修改类加载的方式</strong><ul>
<li>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</li>
</ul>
</li>
<li><strong>扩展加载源</strong><ul>
<li>比如从数据库、网络、甚至是电视机机顶盒进行加载</li>
</ul>
</li>
<li><strong>防止源码泄漏</strong><ul>
<li>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>常见的场景：</strong></p>
<blockquote>
<ul>
<li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE和OSGI、JPMS等框架</li>
<li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</li>
</ul>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p>
</blockquote>
<p><strong>实现方式：</strong></p>
<blockquote>
<p>用户通过定制自己的类加载器，这样可以重新定义类的加载规则，以便实现一些自定义的处理逻辑</p>
<p>实现方式：</p>
<ul>
<li>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</li>
<li>在自定义ClassLoader的子类时候，我们常见的会有两种做法<ul>
<li>方式一:重写loadClass（）方法</li>
<li>方式二:重写findClass（）方法</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>对比</strong></p>
<blockquote>
<ul>
<li>这两种方法本质上差不多，毕竟loadClass（）也会调用findClass（），但是从逻辑上讲我们最好不要直接修改loadClass（）的内部逻辑。建议的做法是只在findClass（）里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。<ul>
<li>loadClass（）这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写</li>
</ul>
</li>
<li>loadClass（）方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。<ul>
<li>当编写好自定义类加载器后，便可以在程序中调用loadClass（）方法来实现类加载操作。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>说明</strong></p>
<blockquote>
<ul>
<li>其父类加载器是系统类加载器</li>
<li>JVM中所有类加载都会使用<code>java.lang.ClassLoader.loadClass(String)</code>接口（自定义类加载器并重写<code>java.lang.ClassLoader.loadClass(String)</code>接口除外），连JDK的核心库类也不能例外</li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<blockquote>
<p>自定义类加载器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义ClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String byteCodePath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String byteCodePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String byteCodePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取字节码文件的完整路径</span></span><br><span class="line">            String fileName = byteCodePath + className + <span class="string">".class"</span>;</span><br><span class="line">            <span class="comment">//获取一个输入流</span></span><br><span class="line">            bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">            <span class="comment">//获取一个输出流</span></span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="comment">//具体读入数据并写出的过程</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(data, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取内存中的完整的字节数组的数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] byteCodes = baos.toByteArray();</span><br><span class="line">            <span class="comment">//调用defineClass()，将字节数组的数据转换为Class的实例。</span></span><br><span class="line">            Class clazz = defineClass(<span class="keyword">null</span>, byteCodes, <span class="number">0</span>, byteCodes.length);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (baos != <span class="keyword">null</span>)</span><br><span class="line">                    baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="keyword">null</span>)</span><br><span class="line">                    bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader loader = <span class="keyword">new</span> MyClassLoader(<span class="string">"/Users/dongshuhuan/JavaProjects/JVM_study/src/com/dsh/jvmp2/chapter04/java1/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = loader.loadClass(<span class="string">"Demo1"</span>);</span><br><span class="line">            System.out.println(<span class="string">"加载此类的类的加载器为："</span> + clazz.getClassLoader().getClass().getName());<span class="comment">//com.dsh.jvmp2.chapter04.java2.MyClassLoader</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"加载当前Demo1类的类的加载器的父类加载器为："</span> + clazz.getClassLoader().getParent().getClass().getName());<span class="comment">//sun.misc.Launcher$AppClassLoader</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="8，Java9新特性"><a href="#8，Java9新特性" class="headerlink" title="8，Java9新特性"></a><strong>8，Java9新特性</strong></h4><blockquote>
<p>为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<ul>
<li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform classloader）。可以通过ClassLoader的新方法getPlatformClassLoader（）来获取。</li>
</ul>
<p>JDK9时基于模块化进行构建（原来的rt.jar 和tools.jar被拆分成数十个JMOD文件），其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HOME>\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</JAVA_HOME></p>
<ul>
<li>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader</li>
</ul>
<p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于<code>jdk.internal.loader.BuiltinClassLoader</code></p>
<p><img src="/2021/04/05/jvm/177.png" alt></p>
<p>如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在 JDK9及更高版本的JDK中崩溃。</p>
<ul>
<li>在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName（）方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li>
<li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li>
<li>类加载的委派关系也发生了变动。</li>
</ul>
<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p>
<p>双亲委派模式示意图</p>
<p><img src="/2021/04/05/jvm/178.png" alt></p>
</blockquote>
<h2 id="JVM下篇——性能监控与调优篇"><a href="#JVM下篇——性能监控与调优篇" class="headerlink" title="JVM下篇——性能监控与调优篇"></a>JVM下篇——性能监控与调优篇</h2><h3 id="一，概述篇"><a href="#一，概述篇" class="headerlink" title="一，概述篇"></a>一，概述篇</h3><h4 id="1，大厂面试题："><a href="#1，大厂面试题：" class="headerlink" title="1，大厂面试题："></a>1，大厂面试题：</h4><blockquote>
<p><strong>支付宝：</strong></p>
<p>支付宝三面：JVM性能调优都做了什么？</p>
<p><strong>小米：</strong></p>
<p>做过JVM内存优化吗？</p>
<p>从SQL，JVM，架构，数据库四个方卖弄讲讲优化思路</p>
<p><strong>蚂蚁金服：</strong></p>
<p>JVM的编译优化</p>
<p>JVM性能调优都做了什么</p>
<p>JVM诊断调优工具用过哪些？</p>
<p>二面：JVM怎么样调优，堆内存，栈空间设置多少合适</p>
<p>三面：JVM相关的分析工具使用过的有哪些？具体的性能调优步骤如何</p>
<p><strong>阿里：</strong></p>
<p>如何进行JVM调优？有哪些方法？</p>
<p>如何理解内存泄露问题？有哪些情况会导致内存泄露？如何解决？</p>
<p><strong>字节跳动</strong></p>
<p>三面：JVM如何调优，参数怎么调？</p>
<p><strong>拼多多：</strong></p>
<p>从SQL，JVM，架构，数据库四个方面讲讲优化思路</p>
<p><strong>京东：</strong></p>
<p>JVM诊断调优工具用过哪些？</p>
<p>每秒几十万并发的秒杀系统为什么会频繁发生GC？</p>
<p>日均百万级交易系统如何优化JVM？</p>
<p>线上生产系统OOM如何监控及定位与解决？</p>
<p>高并发系统如何基于G1垃圾回收器优化性能？</p>
</blockquote>
<h4 id="2，背景说明："><a href="#2，背景说明：" class="headerlink" title="2，背景说明："></a>2，背景说明：</h4><h5 id="a，生产环境中的问题："><a href="#a，生产环境中的问题：" class="headerlink" title="a，生产环境中的问题："></a>a，生产环境中的问题：</h5><ul>
<li>生产环境发生了内存溢出该如何处理？</li>
<li>生产环境应该给服务器分配多少内存合适？</li>
<li>如何对垃圾回收器的性能进行调优？</li>
<li>生产环境CPU负载飙高该如何处理？</li>
<li>生产环境应该给应用分配多少线程合适？</li>
<li>不加log，如何确定请求是否执行了某一行代码？</li>
<li>不加log，如何实时查看某个方法的入参与返回值？</li>
</ul>
<h5 id="b，为什么要调优？"><a href="#b，为什么要调优？" class="headerlink" title="b，为什么要调优？"></a>b，为什么要调优？</h5><ul>
<li>防止出现OOM</li>
<li>解决OOM</li>
<li>减少Full GC出现的频率</li>
</ul>
<h5 id="c，不同阶段的考虑"><a href="#c，不同阶段的考虑" class="headerlink" title="c，不同阶段的考虑"></a>c，不同阶段的考虑</h5><ul>
<li>上线前</li>
<li>项目运行阶段</li>
<li>线上出现OOM</li>
</ul>
<h4 id="3，调优概述："><a href="#3，调优概述：" class="headerlink" title="3，调优概述："></a>3，调优概述：</h4><h5 id="a，监控的依据："><a href="#a，监控的依据：" class="headerlink" title="a，监控的依据："></a>a，监控的依据：</h5><ul>
<li>运行日志</li>
<li>异常堆栈</li>
<li>GC日志</li>
<li>线程快照</li>
<li>对转储快照</li>
</ul>
<h5 id="b，调优的大方向："><a href="#b，调优的大方向：" class="headerlink" title="b，调优的大方向："></a>b，调优的大方向：</h5><ul>
<li>合理地编写代码</li>
<li>充分并合理的使用硬件资源</li>
<li>合理地进行JVM调优</li>
</ul>
<h4 id="4，性能优化的步骤："><a href="#4，性能优化的步骤：" class="headerlink" title="4，性能优化的步骤："></a>4，性能优化的步骤：</h4><h5 id="a，第1步（发现问题）：性能监控"><a href="#a，第1步（发现问题）：性能监控" class="headerlink" title="a，第1步（发现问题）：性能监控"></a>a，第1步（发现问题）：性能监控</h5><blockquote>
<p>一种<strong>以非强行或者入侵方式**</strong>收集或查看**应用运营性能数据的活动</p>
<p>监控通常是指一种在生产，质量评估或者开发环境下实施的带有<strong>预防或主动性</strong>的活动</p>
<p>当应用相关干系人提出性能问题却<strong>没有提供足够多的线索</strong>时，首先我们需要进行性能监控，随后是性能分析</p>
</blockquote>
<ul>
<li>GC频繁</li>
<li>cpu load过高</li>
<li>OOM</li>
<li>内存泄露</li>
<li>死锁</li>
<li>程序响应时间较长</li>
</ul>
<h5 id="b，第2步（排查问题）：性能分析"><a href="#b，第2步（排查问题）：性能分析" class="headerlink" title="b，第2步（排查问题）：性能分析"></a>b，第2步（排查问题）：性能分析</h5><blockquote>
<p>一种以<strong>侵入方式</strong>收集运行性能数据的活动，它会影响应用的吞吐量或响应性</p>
<p>性能分析是针对性能问题的大幅结果，关注的范围通常比性能监控更加集中</p>
<p>性能分析很少在生产环境下进行，通常是在<strong>质量评估，系统测试或者开发环境下</strong>进行，是性能监控之后的步骤。</p>
</blockquote>
<ul>
<li>打印GC日志，通过GCviewer或者<a href="http://gceasy.io来分析日志信息" target="_blank" rel="noopener">http://gceasy.io来分析日志信息</a></li>
<li>灵活运用命令行工具，jstack，jmap，jinfo等</li>
<li>dump出堆文件，使用内存分析工具分析文件</li>
<li>使用阿里Arthas，或jconsole，JVisualVM来实时查看JVM状态</li>
<li>jstack查看堆栈信息</li>
</ul>
<h5 id="c，第3步（解决问题）：性能调优"><a href="#c，第3步（解决问题）：性能调优" class="headerlink" title="c，第3步（解决问题）：性能调优"></a>c，第3步（解决问题）：性能调优</h5><blockquote>
<p>一种为改善应用响应性或吞吐量而更改参数，源代码，属性配置的活动，性能调优是在性能监控，性能分析之后的活动</p>
</blockquote>
<ul>
<li>适当增加内存，根据业务背景选择垃圾回收器</li>
<li>优化代码，控制内存使用</li>
<li>增加机器，分散节点压力</li>
<li>合理设置线程池线程数量</li>
<li>使用中间件提高程序效率，比如缓存，消息队列等</li>
<li>其他。。。</li>
</ul>
<h4 id="5，性能评价-测试指标"><a href="#5，性能评价-测试指标" class="headerlink" title="5，性能评价/测试指标"></a>5，性能评价/测试指标</h4><h5 id="a，停顿时间（或响应时间）"><a href="#a，停顿时间（或响应时间）" class="headerlink" title="==a，停顿时间（或响应时间）=="></a>==a，停顿时间（或响应时间）==</h5><blockquote>
<p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间</p>
</blockquote>
<p>常用操作的响应时间列表：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>响应时间</th>
</tr>
</thead>
<tbody><tr>
<td>打开一个站点</td>
<td>几秒</td>
</tr>
<tr>
<td>数据库查询一条记录（有索引）</td>
<td>十几毫秒</td>
</tr>
<tr>
<td>机械磁盘一次寻址定位</td>
<td>4毫秒</td>
</tr>
<tr>
<td>从机械磁盘顺序读取1M数据</td>
<td>2毫秒</td>
</tr>
<tr>
<td>从SSD磁盘顺序读取1M数据</td>
<td>0.3毫秒</td>
</tr>
<tr>
<td>从远程分布式换成Redis读取一个数据</td>
<td>0.5毫秒</td>
</tr>
<tr>
<td>从内存读取1M数据</td>
<td>十几微妙</td>
</tr>
<tr>
<td>Java程序本地方法调用</td>
<td>几微秒</td>
</tr>
<tr>
<td>网络传输2Kb数据</td>
<td>1微秒</td>
</tr>
</tbody></table>
<p>在垃圾回收环节中：</p>
<p>暂停时间：<strong>执行垃圾收集时，程序的工作线程被暂停的时间</strong>，设置参数<code>-XX:MaxGCPauseMillis</code></p>
<h5 id="b，吞吐量"><a href="#b，吞吐量" class="headerlink" title="==b，吞吐量=="></a>==b，吞吐量==</h5><ul>
<li>对单位时间内完成的工作量（请求）的量度</li>
<li>在GC中：运行用户代码的时间占总运行时间（总运行时间：程序的运行时间+内存回收的时间）的比例设为n，则吞吐量为==1-1/(1+n)。==设置参数：<code>-XX:GCTimeRatio=n</code></li>
</ul>
<h5 id="c，并发数："><a href="#c，并发数：" class="headerlink" title="c，并发数："></a>c，并发数：</h5><ul>
<li>同一时刻，对服务器有实际交互的请求数</li>
</ul>
<h5 id="d，内存占用："><a href="#d，内存占用：" class="headerlink" title="d，内存占用："></a>d，内存占用：</h5><ul>
<li>Java堆区所占的内存大小</li>
</ul>
<h3 id="二，命令行篇"><a href="#二，命令行篇" class="headerlink" title="二，命令行篇"></a>二，命令行篇</h3><h4 id="1，概述：-2"><a href="#1，概述：-2" class="headerlink" title="1，概述："></a>1，概述：</h4><blockquote>
<p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。<br>Java作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成Java应用出现性能问题的因素非常多，例如线程控制，磁盘读写，数据库访问，网络I/O，垃圾收集等，想要定位这些问题，一款优秀的性能诊断工具必不可少</p>
<p>体会1：使用数据说明问题，使用知识分析问题，使用工具处理问题</p>
<p>体会2：无监控，不调优</p>
</blockquote>
<h4 id="2，jps：查看正在运行的Java进程"><a href="#2，jps：查看正在运行的Java进程" class="headerlink" title="2，jps：查看正在运行的Java进程"></a>2，jps：查看正在运行的Java进程</h4><h5 id="a，基本情况："><a href="#a，基本情况：" class="headerlink" title="a，基本情况："></a>a，基本情况：</h5><blockquote>
<p>jps（Java Process Status）</p>
<p>显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程</p>
<p>说明：对于本地虚拟机进程来说，进程的本地虚拟机ID与操作系统的进程ID是一致的，是唯一的</p>
</blockquote>
<h5 id="b，基本语法："><a href="#b，基本语法：" class="headerlink" title="b，基本语法："></a>b，基本语法：</h5><blockquote>
<p>它的基本使用语法：==<code>jps  [options] [hostid]</code>==</p>
<p>我们还可以通过追加参数，来打印额外的信息</p>
</blockquote>
<p><strong>options参数：</strong></p>
<blockquote>
<ul>
<li>-q：仅仅显示LVMID（local virtual machine id），即本地虚拟机唯一id，不显示主类的名称等</li>
<li>-l：输出应用程序主类的全类名 或 如果进程执行的是jar包，则输出jar完整路径</li>
<li>-m：输出虚拟机进程启动时传递给主类main（）的参数</li>
<li>-v：列出虚拟机进程启动时的JVM参数。比如：<code>-Xms20m -Xmx50m</code>是启动程序指定的jvm参数</li>
</ul>
<p><strong>说明：以上参数可以综合使用</strong></p>
<p>例如：<code>jps -q</code>或<code>jps -lv</code></p>
<p>补充：</p>
<p>如果某Java进程关闭了默认开启的UserPerfData参数（即使使用参数<code>-XX:-UsePerfData</code>），那么jps命令（以及下面介绍的jstat）将无法探知该Java进程</p>
</blockquote>
<p><strong>hostid参数</strong></p>
<blockquote>
<p>RMI注册表中注册的主机名</p>
<p>如果想要远程监控主机上Java程序，需要安装<strong>jstatd</strong></p>
<p>对于具有更严格的安全事件的网络场所而言，可能使用一个自定的策略文件来显示对特定的可信主机或网络的访问，尽管<strong>这种技术容易受到IP地址欺诈攻击</strong></p>
<p>如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行jstatd服务器，而是在本地使用jstat和jps工具</p>
</blockquote>
<h4 id="3，jstat：查看JVM统计信息"><a href="#3，jstat：查看JVM统计信息" class="headerlink" title="3，jstat：查看JVM统计信息"></a>3，jstat：查看JVM统计信息</h4><h5 id="a，基本情况：-1"><a href="#a，基本情况：-1" class="headerlink" title="a，基本情况："></a>a，基本情况：</h5><blockquote>
<p>jstat（JVM Statistics Monitoring Tool）：用于监视虚拟机各种运行状态信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类装载，内存，垃圾收集，JIT编译等运行数据</p>
<p>在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首先工具，常用于检测垃圾回收问题以及内存泄露问题</p>
</blockquote>
<h5 id="b，基本语法：-1"><a href="#b，基本语法：-1" class="headerlink" title="b，基本语法："></a>b，基本语法：</h5><blockquote>
<p>它的基本使用语法为：<code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmind&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></p>
<p>查看命令相关参数：<code>jstat -h</code>或<code>jstat -help</code></p>
</blockquote>
<p><strong>option参数</strong></p>
<blockquote>
<p>选项option可以由以下值构造。</p>
<ul>
<li><strong>类装载相关的：</strong><ul>
<li>-class：显示ClassLoader的相关信息：类的装载，卸载数量，总空间，类装载所消耗的时间等</li>
</ul>
</li>
<li><strong>垃圾回收相关的：</strong><ul>
<li>-gc：显示与GC相关的堆信息。包括Eden区，两个Survivor区，老年代，永久代等的容量，已用空间，GC时间合计等信息。<ul>
<li>例如：<code>jstat -gc 6496</code></li>
<li><strong>新生代相关：</strong><ul>
<li>S0C是第一个幸存者区的大小（字节）</li>
<li>S1C是第二个幸存者区的大小（字节）</li>
<li>S0U是第一个幸存者区已使用的大小（字节）</li>
<li>S1U是第二个幸存者区已使用的大小（字节）</li>
<li>EC是Eden空间的大小（字节）</li>
<li>EU是Eden空间已使用大小（字节）</li>
</ul>
</li>
<li><strong>老年代相关</strong><ul>
<li>OC是老年代的大小（字节）</li>
<li>OU是老年代已使用的大小（字节）</li>
</ul>
</li>
<li><strong>方法区（元空间）相关</strong><ul>
<li>MC是方法区的大小</li>
<li>MU是方法区已使用的大小</li>
<li>CCSC是压缩类空间的大小</li>
<li>CCSU是压缩类空间已使用的大小</li>
</ul>
</li>
<li><strong>其他</strong><ul>
<li>YGC是指从应用程序启动到采用时young gc次数</li>
<li>YGCT是指从应用程序启动到采样时young gc消耗的时间（秒）</li>
<li>FGC是指从应用程序启动到采样时full gc次数</li>
<li>FGCT是指从应用程序启动到采样时full gc消耗的时间（秒）</li>
<li>GCT是指从应用程序启动到采样时gc的总时间</li>
</ul>
</li>
</ul>
</li>
<li>-gccapacity：显示内容与-gc基本相同，但是输出主要关注Java堆各个区域使用到的最大，最小空间。</li>
<li>-gcutil：显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</li>
<li>-gccause：与-gcutil功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因</li>
<li>-gcnew：显示新生代GC状况</li>
<li>-gcnewcapacity：显示内容与-gcnew基本相同，输出主要关注使用到的最大，最小空间</li>
<li>-geold：显示老年代GC状况</li>
<li>gcoldcapacity：显示内容与-gcold基本相同，输出主要关注使用到的最大，最小空间</li>
<li>-gcpermcapacity：显示永久代使用到的最大，最小空间</li>
</ul>
</li>
<li><strong>JIT相关的：</strong><ul>
<li>-compiler：显示JIT编译器编译过的方法，耗时等信息</li>
<li>-printcompilation：输出已经被JIT编译的方法</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>interval参数：</strong></p>
<blockquote>
<p>用于指定输出统计数据的周期，单位为毫秒，即：查询间隔</p>
<p>例：<code>jstat -class 6496 1000</code></p>
</blockquote>
<p><strong>count参数：</strong></p>
<blockquote>
<p>用于指定查询的总次数</p>
<p>例如：<code>jstat -class 6496 1000 10</code></p>
</blockquote>
<p><strong>-t参数：</strong></p>
<blockquote>
<p>可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位：秒</p>
<p>例如：<code>jstat -class -t 6496 1000 10</code></p>
<p>我们可以比较Java进程的启动时间以及总GC时间（GCT列），或者两次测量的间隔时间以及总GC时间的增量，来得出GC时间占运行时间的比例</p>
<p>如果该比例超过20%，则说明目前堆的压力较大；如果该比例超过90%，则说明堆里几乎没有可用空间，随时都可能抛出OOM异常</p>
</blockquote>
<p><strong>-h参数：</strong></p>
<blockquote>
<p>可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p>
<p>例如：<code>jstat -class -t -h3 6496 1000 10</code></p>
</blockquote>
<h5 id="c，补充："><a href="#c，补充：" class="headerlink" title="c，补充："></a>c，补充：</h5><p><strong>jstat还可以用来判断是否出现内存泄露</strong></p>
<blockquote>
<p>第一步：</p>
<p>在长时间运行的Java程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行数据中OU列（即已占用的老年代内存）的最小值</p>
<p>第二步：</p>
<p>然后，我们每隔一段较长的时间重复依次上述操作，来获得多组OU最小值，如果这些值呈上涨趋势，则说明该Java程序的老年代内存已使用量在不断上涨，这以为这无法回收的对象在不断增加，因此很有可能存在内存泄露</p>
</blockquote>
<h4 id="4，jinfo：实时查看和修改JVM配置参数"><a href="#4，jinfo：实时查看和修改JVM配置参数" class="headerlink" title="4，jinfo：实时查看和修改JVM配置参数"></a>4，jinfo：实时查看和修改JVM配置参数</h4><h5 id="a，基本情况"><a href="#a，基本情况" class="headerlink" title="a，基本情况"></a>a，基本情况</h5><blockquote>
<p>jinfo（Configuration Info For Java）</p>
<p>查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数</p>
<p>在很多情况下，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虚拟机参数的默认值。在这种情况下，可能需要通过文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了jinfo工具，开发人员可以很方便地找到Java虚拟机参数的当前值</p>
</blockquote>
<h5 id="b，基本语法"><a href="#b，基本语法" class="headerlink" title="b，基本语法"></a>b，基本语法</h5><blockquote>
<p> jinfo [options] pid</p>
<p>说明：Java进程ID必须要加上</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>选项说明</th>
</tr>
</thead>
<tbody><tr>
<td>no option</td>
<td>输出全部的参数和系统属性</td>
</tr>
<tr>
<td>-flag name</td>
<td>输出对应名称的参数</td>
</tr>
<tr>
<td>-flag [+-]name</td>
<td>开启或关闭对应名称的参数，只有被标记为manageable的参数才可以被动态修改</td>
</tr>
<tr>
<td>-flags</td>
<td>输出全部的参数</td>
</tr>
<tr>
<td>-sysprops</td>
<td>输出系统属性</td>
</tr>
</tbody></table>
<p>查看</p>
<ul>
<li><p>jinfo -sysprops PID</p>
<p>可以查看由System.getProperties()取得的参数</p>
</li>
<li><p>jinfo -flags PID</p>
<p>查看曾经赋过值的一些参数</p>
</li>
<li><p>jinfo -flag 具体参数 PID</p>
<p>查看某个Java进程的具体参数的值</p>
</li>
</ul>
<p>修改：</p>
<p>jinfo不仅可以查看运行时某一个Java虚拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效</p>
<p>但是，并非所有参数都支持动态修改，参数只有被标记为manageable的flag可以被实时修改。其实，这个修改能力是极其有限的。</p>
<p>可以查看被标记为manageable的参数</p>
<p><code>java -XX:+PrintFlagsFinal -version | grep manageable</code></p>
<p><img src="/2021/04/05/jvm/179.png" alt="image-20210531164044933"></p>
<ul>
<li><p>针对boolean类型</p>
<p>jinfo -flag [+-]具体参数 PID</p>
</li>
<li><p>针对非boolean类型</p>
<p>jinfo -flag 具体参数=具体参数值 PID</p>
</li>
</ul>
</blockquote>
<h5 id="c，拓展"><a href="#c，拓展" class="headerlink" title="c，拓展"></a>c，拓展</h5><ul>
<li><p><code>java -XX:+PirntFlagsInitial</code></p>
<p>查看所有JVM参数启动的初始值</p>
</li>
<li><p><code>java -XX:+PrintFlagsFinal</code></p>
<p>查看所有JVM参数的最终值</p>
</li>
<li><p><code>java -XX:+PrintCommandLineFlags</code></p>
<p>查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值</p>
</li>
</ul>
<h4 id="5，jmap：导出内存映像文件-amp-内存使用情况"><a href="#5，jmap：导出内存映像文件-amp-内存使用情况" class="headerlink" title="5，jmap：导出内存映像文件 &amp; 内存使用情况"></a>5，jmap：导出内存映像文件 &amp; 内存使用情况</h4><h5 id="a，基本情况-1"><a href="#a，基本情况-1" class="headerlink" title="a，基本情况"></a>a，基本情况</h5><blockquote>
<p>jmap（JVM Memory Map）</p>
<p>作用一方面是获取dump文件（堆转储快照文件，二进制文件），它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况，堆中对象的统计信息，类加载信息等</p>
<p>开发人员可以在控制台中输入<code>jmap -help</code>查阅jmap工具的具体使用方式和一些标准选项配置</p>
</blockquote>
<h5 id="b，基本语法-1"><a href="#b，基本语法-1" class="headerlink" title="b，基本语法"></a>b，基本语法</h5><blockquote>
<p>他的基本使用语法为：</p>
<ul>
<li><code>jmap [option] &lt;pid&gt;</code></li>
<li><code>jmap [option] ,executable &lt;core&gt;</code></li>
<li><code>jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</code></li>
</ul>
<p>其中option包括</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-dump</td>
<td>生成dump文件</td>
</tr>
<tr>
<td>-finalizerInfo</td>
<td>以ClassLoader为统计口径输出永久代的内存状态信息</td>
</tr>
<tr>
<td>-heap</td>
<td>输出整个堆空间的详细信息，包括GC的使用，堆配置信息，以及内存的使用信息等</td>
</tr>
<tr>
<td>-histo</td>
<td>输出堆空间中对象的统计信息，包括类、实例数量和合计容量</td>
</tr>
<tr>
<td>-permstat</td>
<td>以ClassLoader为统计口径输出永久代的内存状态信息</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机进程对-dump选项没有任何响应时，强制执行生成dump文件</td>
</tr>
</tbody></table>
<ul>
<li>==<strong>-dump</strong>==<ul>
<li>生成Java堆转储快照：dump文件</li>
<li>特别的：-dump:live只保存堆中的存活对象</li>
</ul>
</li>
<li>==<strong>-heap</strong>==<ul>
<li>输出整个堆空间的详细信息，包括GC的使用，堆配置信息，以及内存的使用功信息等</li>
</ul>
</li>
<li>==<strong>-histo</strong>==<ul>
<li>输出堆中对戏那个的统计信息，包括类，实例数量和合计容量</li>
<li>特别的：-history:live只统计堆中的存活对象</li>
</ul>
</li>
<li><strong>-permstat</strong><ul>
<li>以ClassLoader为统计口径输出永久代的内存状态信息</li>
<li>仅Linux/solaris平台有效</li>
</ul>
</li>
<li><strong>-finalizerinfo</strong><ul>
<li>显示在F-Queue中等待finalizer线程执行finalize方法的对象</li>
<li>仅Linux/solaris平台有效</li>
</ul>
</li>
<li><strong>-F</strong><ul>
<li>当虚拟机进程对-dump选项没有任何响应时，可使用此选项强制执行生成dump文件</li>
<li>仅Linux/solaris平台有效</li>
</ul>
</li>
<li><strong>-h | help</strong><ul>
<li>jmap工具使用的帮助命令</li>
</ul>
</li>
<li><strong>-J &lt;flag&gt;</strong><ul>
<li>传递参数给jmap启动的jvm</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="c，使用1：导出内存映像文件"><a href="#c，使用1：导出内存映像文件" class="headerlink" title="c，使用1：导出内存映像文件"></a>c，使用1：导出内存映像文件</h5><blockquote>
<p>一般来说，使用jmap指令生成dump文件的操作算得上是最常用的jmap命令之一，将堆中所有存活对象导出至一个文件之中</p>
<p>Heap Dump又叫做堆存储文件，指一个Java进程在某个时间点的内存快照。Heap Dump在触发内存快照的时候会保存此刻的信息如下：</p>
<ul>
<li>All Objects</li>
</ul>
<p>Class,fields,primitive values and references</p>
<ul>
<li>All Classes</li>
</ul>
<p>ClassLoader,name,super class,static fields</p>
<ul>
<li>Garbage Collection Roots</li>
</ul>
<p>Objects defined to be reachable by the JVM</p>
<ul>
<li>Thread Stacks and Local Variables</li>
</ul>
<p>The call-stacks of threads at the moment of the snapshot,and per-frame information about local objects</p>
<p>说明：</p>
<ol>
<li>通常在写Heap Dump文件前会触发一次Full GC，所以heap dump文件里保存的都是Full GC后留下的对象信息</li>
<li>由于生成dump文件比较好使，因此大家需要耐心等待，尤其是大内存镜像生成dump文件则需要耗费更长的时间来完成</li>
</ol>
</blockquote>
<p>手动方式：</p>
<blockquote>
<ul>
<li><code>jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</code></li>
<li>==<code>jmap -dump:live,format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</code>==</li>
</ul>
</blockquote>
<p>自动方式</p>
<blockquote>
<p>当程序发生OOM退出系统时，一些瞬时信息都随着程序的终止而消失，而重现OOM问题往往比较困难或者耗时。此时若能在OOM时，自动导出dump文件就显得非常迫切</p>
<p>这里介绍一种比较常用的去的堆快照文件的方法，即使用：</p>
<ul>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：在程序发生OOM时，导出应用程序的当前堆快照。</li>
<li><code>-XX:HeapDumpPath=&lt;filename.hprof&gt;</code>：可以指定堆快照的保存位置</li>
</ul>
<p>比如：<code>-Xmx100m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=C:\1.hprof</code></p>
</blockquote>
<h5 id="d，使用2：显示堆内存相关信息"><a href="#d，使用2：显示堆内存相关信息" class="headerlink" title="d，使用2：显示堆内存相关信息"></a>d，使用2：显示堆内存相关信息</h5><blockquote>
<ul>
<li><code>jmap -heap pid</code></li>
<li><code>jmap -histo pid</code></li>
</ul>
</blockquote>
<h5 id="e，使用3：其他作用"><a href="#e，使用3：其他作用" class="headerlink" title="e，使用3：其他作用"></a>e，使用3：其他作用</h5><blockquote>
<ul>
<li><code>jmap -permstat pid</code>：查看系统的ClassLoader信息</li>
<li><code>jmap -finalizerinfo</code>：查看堆积在finalizer队列中的对象</li>
</ul>
</blockquote>
<h5 id="f，小结"><a href="#f，小结" class="headerlink" title="f，小结"></a>f，小结</h5><blockquote>
<ul>
<li>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差</li>
<li>举例：假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么<code>:live</code>选项将无法探知到这些对象</li>
<li>另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。与前面讲的jstat则不同，垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需要直接读取即可。</li>
</ul>
</blockquote>
<h4 id="6，jhat：JDK自带堆分析工具"><a href="#6，jhat：JDK自带堆分析工具" class="headerlink" title="6，jhat：JDK自带堆分析工具"></a>6，jhat：JDK自带堆分析工具</h4><h5 id="a，基本情况-2"><a href="#a，基本情况-2" class="headerlink" title="a，基本情况"></a>a，基本情况</h5><blockquote>
<p>jhat（JVM Heap Analysis Tool）</p>
<p>Sun JDK提供的jhat命令与jmap命令搭配使用，用于分析jmap生成的heap dump文件（堆转储快照）。jhat内置了一个微型的HTTP/HTML服务区，生成dump文件的分析结果后，用户可以在浏览器中查看分析结果（分析虚拟机转储快照信息）</p>
<p>使用了jhat命令，就启动了一个HTTP服务，端口是7000，即<a href="http://localhost:7000/就可以在浏览器里分析" target="_blank" rel="noopener">http://localhost:7000/就可以在浏览器里分析</a></p>
<p>说明：jhat命令在JDK9,JDK10中已经被删除，官方建议用VisualVM代替</p>
</blockquote>
<h5 id="b，基本语法-2"><a href="#b，基本语法-2" class="headerlink" title="b，基本语法"></a>b，基本语法</h5><blockquote>
<p>他的基本使用语法为：</p>
<p>jhat [option] [dumpfile]</p>
</blockquote>
<p><strong>option参数：</strong></p>
<blockquote>
<ul>
<li><p><code>-stack false|true</code></p>
<p>关闭|打开对象分配调用栈跟踪</p>
</li>
<li><p><code>-refs false|true</code></p>
<p>关闭|打开对象引用跟踪</p>
</li>
<li><p><code>-port port-number</code></p>
<p>设置jhat HTTP Server的端口号，默认是7000</p>
</li>
<li><p><code>-exclude exclude-file</code></p>
<p>执行对象查询时需要排除的数据成员</p>
</li>
<li><p><code>baseline exclude-file</code></p>
<p>指定一个基准堆转储</p>
</li>
<li><p><code>-debug int</code></p>
<p>设置debug级别</p>
</li>
<li><p><code>-version</code></p>
<p>启动后显示版本信息就退出</p>
</li>
<li><p><code>-J&lt;flag&gt;</code></p>
<p>传入启动参数，比如-J -Xmx512m</p>
</li>
</ul>
</blockquote>
<h4 id="7，jstack：打印JVM中线程快照"><a href="#7，jstack：打印JVM中线程快照" class="headerlink" title="7，jstack：打印JVM中线程快照"></a>7，jstack：打印JVM中线程快照</h4><h5 id="a，基本情况-3"><a href="#a，基本情况-3" class="headerlink" title="a，基本情况"></a>a，基本情况</h5><blockquote>
<p>jstack（JVM Stack Trace）:</p>
<p>用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合</p>
<p>生成线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁，死循环，请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用jstack显示各个线程调用的堆栈情况</p>
<p>在thread dump中，要留意下面几种状态</p>
<ul>
<li>==<strong>死锁，Deadlock（重点关注）</strong>==</li>
<li>==<strong>等待资源，Waiting on condition（重点关注）</strong>==</li>
<li>==<strong>等待获取监视器，Waiting on monitor entry（重点关注）</strong>==</li>
<li>==<strong>阻塞，Blocked（重点关注）</strong>==</li>
<li>执行中，Runnable</li>
<li>暂停，Suspended</li>
<li>对象等待中，Object.wait（）或TIMED_WAITING</li>
<li>停止，Parked</li>
</ul>
</blockquote>
<h5 id="b，基本语法-3"><a href="#b，基本语法-3" class="headerlink" title="b，基本语法"></a>b，基本语法</h5><blockquote>
<p>他的基本使用语法为：</p>
<p>jstack option pid</p>
<p>jstack管理远程进程的话，需要在 远程程序的启动参数中增加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Djava.rmi.server.hostname&#x3D;···..</span><br><span class="line">-Dcom.sun.management.jmxremote</span><br><span class="line">-Dcom.sun.management.jmxremote.port&#x3D;8888</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate&#x3D;false</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl&#x3D;false</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>option参数：</strong></p>
<blockquote>
<ul>
<li><code>-F</code>：当正常输出的请求不被响应时，强制输出线程堆栈</li>
<li><code>-l</code>：除堆栈外，显示关于锁的附加信息</li>
<li><code>-m</code>：如果调用到本地方法的话，可以显示C/C++的堆栈</li>
<li><code>-h</code>：帮助操作</li>
</ul>
</blockquote>
<h4 id="8，jcmd：多功能命令行"><a href="#8，jcmd：多功能命令行" class="headerlink" title="8，jcmd：多功能命令行"></a>8，jcmd：多功能命令行</h4><h5 id="a，基本情况-4"><a href="#a，基本情况-4" class="headerlink" title="a，基本情况"></a>a，基本情况</h5><blockquote>
<p>在JDK1.7以后，新增加了一个命令行工具jcmd</p>
<p>它是一个多功能的工具，可以用来实现前面除了jstat之外的所有命令的功能。比如：用它来导出堆，内存使用，查看Java进程，导出线程信息，执行GC，JVM运行时间等</p>
<p>jcmd拥有jmap的大部分功能，并且在Oracle的官方网站也推荐使用jcmd命令代jmap命令</p>
</blockquote>
<h5 id="b，基本语法-4"><a href="#b，基本语法-4" class="headerlink" title="b，基本语法"></a>b，基本语法</h5><blockquote>
<ul>
<li><p><code>jcmd -l</code>：列出所有JVM线程</p>
</li>
<li><p><code>jcmd pid help</code>：针对指定的进程，列出支持的所有命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JFR.stop</span><br><span class="line">JFR.start</span><br><span class="line">JFR.dump</span><br><span class="line">JFR.check</span><br><span class="line">VM.native_memory</span><br><span class="line">VM.check_commercial_features</span><br><span class="line">VM.unlock_commercial_features</span><br><span class="line">ManagementAgent.stop</span><br><span class="line">ManagementAgent.start_local</span><br><span class="line">ManagementAgent.start</span><br><span class="line">VM.classloader_stats</span><br><span class="line">GC.rotate_log</span><br><span class="line">Thread.print</span><br><span class="line">GC.class_stats</span><br><span class="line">GC.class_histogram</span><br><span class="line">GC.heap_dump</span><br><span class="line">GC.finalizer_info</span><br><span class="line">GC.heap_info</span><br><span class="line">GC.run_finalization</span><br><span class="line">GC.run</span><br><span class="line">VM.uptime</span><br><span class="line">VM.dynlibs</span><br><span class="line">VM.flags</span><br><span class="line">VM.system_properties</span><br><span class="line">VM.command_line</span><br><span class="line">VM.version</span><br><span class="line">help</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>jcmd pid 具体命令</code>：显示指定进程的指令命令的数据</p>
</li>
</ul>
</blockquote>
<h4 id="9，jstatd：远程主机信息收集"><a href="#9，jstatd：远程主机信息收集" class="headerlink" title="9，jstatd：远程主机信息收集"></a>9，jstatd：远程主机信息收集</h4><blockquote>
<p>之前的指令只涉及到监控本机的Java 应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如jps，jstat）。为了启动远程监控，则需要配合使用jstatd工具</p>
<p>命令jstatd是一个RMI服务端程序，他的作用相当于代理服务器，建立本地计算机与远程监控工具的通信，jstatd服务器将本机的Java应用程序信息传递到远程计算机</p>
<p><img src="/2021/04/05/jvm/180.png" alt="image-20210531183042562"></p>
</blockquote>
<h3 id="三，GUI篇"><a href="#三，GUI篇" class="headerlink" title="三，GUI篇"></a>三，GUI篇</h3><h4 id="1，概述-2"><a href="#1，概述-2" class="headerlink" title="1，概述"></a>1，概述</h4><h5 id="a，使用命令行工具的局限性："><a href="#a，使用命令行工具的局限性：" class="headerlink" title="a，使用命令行工具的局限性："></a>a，使用命令行工具的局限性：</h5><ul>
<li>无法获取方法级别的分析数据，如方法间的调用关系，各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）</li>
<li>要求用户登陆到目标Java应用所在的宿主机上，使用起来不是很方便</li>
<li>分析数据通过终端输出，结果展示不够直观</li>
</ul>
<p>为此，JDK提供了一些内存泄露的分析工具，如jconsole，jvisualvm等，用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求，所以这里我们介绍的工具相对多一些，丰富一些。</p>
<h5 id="b，图形化综合诊断工具"><a href="#b，图形化综合诊断工具" class="headerlink" title="b，图形化综合诊断工具"></a>b，图形化综合诊断工具</h5><ul>
<li><strong>JDK自带的工具</strong>：<ul>
<li><strong>jconsole</strong>：JDK自带的可视化监控工具，查看Java应用程序的运行概况，监控堆信息，永久区（或云空间）使用情况，类加载情况等<ul>
<li>位置：jdk\bin\jconsole.exe</li>
</ul>
</li>
<li><strong>Visual VM</strong>：Visual VM是一个工具，它提供了一个可视化界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息<ul>
<li>位置：jdk\bin\jvisualvm.exe</li>
</ul>
</li>
<li><strong>JMC</strong>：Java Mission Control，内置Java Flight Recorder。能够以极低的性能开销手机Java虚拟机的性能数据</li>
</ul>
</li>
<li><strong>第三方工具</strong><ul>
<li><strong>MAT</strong>：MAT（Memory Analyzer Tool）是基于Eclipse的内存分析工具，是一个快速，功能丰富的Java heap分析工具，它可以帮助我们查找内存泄露和减小少内存消耗<ul>
<li>Eclipse的插件形式</li>
</ul>
</li>
<li><strong>JProfiler</strong>：商业软件，需要付费，功能强大<ul>
<li>与VisualVM类似</li>
</ul>
</li>
<li><strong>Arthas</strong>：Alibaba开源的Java诊断工具</li>
<li><strong>Btrace</strong>：Java运行时追踪工具，可以在不停机的情况下，跟踪指定的方法调用，构造函数调用和系统内存等信息</li>
</ul>
</li>
</ul>
<h4 id="2，jconsole"><a href="#2，jconsole" class="headerlink" title="2，jconsole"></a>2，jconsole</h4><h5 id="a，基本概述："><a href="#a，基本概述：" class="headerlink" title="a，基本概述："></a>a，基本概述：</h5><ul>
<li>从Java5开始，在JDK中自带的Java监控和管理控制台</li>
<li>用于对JVM中内存、线程和类等的监控，是一个基于JMX（Java management extensions）的GUI性能监控工具</li>
<li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html" target="_blank" rel="noopener">官方文档</a></li>
</ul>
<h5 id="b，启动"><a href="#b，启动" class="headerlink" title="b，启动"></a>b，启动</h5><ul>
<li>jdk\bin目录下，启动jconsole.exe命令即可，不需要施使用jsp命令来查询<ul>
<li><img src="/2021/04/05/jvm/181.png" alt="image-20210708165523236"></li>
<li><img src="/2021/04/05/jvm/182.png" alt="image-20210708165614975" style="zoom:60%;">

</li>
</ul>
</li>
</ul>
<h5 id="c，连接方式："><a href="#c，连接方式：" class="headerlink" title="c，连接方式："></a>c，连接方式：</h5><ul>
<li><strong>Local</strong>：使用jconsole连接一个正在本地系统运行的JVM，并且执行程序的和运行jconsole的需要是同一个用户，jconsole使用文件系统的授权通过RMI连接器连接到平台的MBean服务器上，这种从本地连接的监控能力只有Sun的JDK具有</li>
<li><strong>Remote</strong>：使用下面的URL通过RMI连接器连接到一个JMX代理，service:jmx:rmi:///jndi/rmi://hostName:portNum/jmxrmi。jconsole为建立连接，需要在环境变量中设置mx.remote.credentials来指定用户名 和密码，从而进行授权</li>
<li><strong>Advanced</strong>：使用一个特殊的URL连接JMXdialing，一般情况使用自己定制的连接而不是RMI提供的连接器来连接JMXdialing，或者是一个使用JDK1.4的实现了JMX和JMX Rmote的应用</li>
</ul>
<h5 id="d，应用功能介绍"><a href="#d，应用功能介绍" class="headerlink" title="d，应用功能介绍"></a>d，应用功能介绍</h5><p><img src="/2021/04/05/jvm/183.png" alt="image-20210708170440471"></p>
<p><img src="/2021/04/05/jvm/184.png" alt="image-20210708171742978"></p>
<p><img src="/2021/04/05/jvm/185.png" alt="image-20210708172048407"></p>
<h4 id="3，Visual-VM"><a href="#3，Visual-VM" class="headerlink" title="3，Visual VM"></a>3，Visual VM</h4><h5 id="a，基本概述：-1"><a href="#a，基本概述：-1" class="headerlink" title="a，基本概述："></a>a，基本概述：</h5><ul>
<li>Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具</li>
<li>它集成了多个JDK命令行工具，使用Visual VM可用于显示虚拟机进程及进程的配置和环境信息（jps，jinfo），监视应用程序的CPU，GC，堆，方法区及线程的信息（jstat，jstack）等，甚至代理jconsole</li>
<li>在JDK 6 Update 7以后，Visual VM便作为JDK的一部分发布（VisualVM在JDK/bin目录下），即：它完全免费</li>
<li>此外，Visual VM也可以作为独立的软件安装；</li>
<li><a href="https://visualvm.github.io/index.html" target="_blank" rel="noopener">官方网站</a></li>
</ul>
<h5 id="b，插件安装："><a href="#b，插件安装：" class="headerlink" title="b，插件安装："></a>b，插件安装：</h5><ul>
<li><p>Visual VM的一大特点是支持插件扩展，并且插件安装非常方便，我们既可以通过离线下载插件文件*.nbm，然后在Plugin对话框的已下载页面下，添加已下载的插件，也可以在可用插件页面下在线安装插件（这里建议安装上：VisualGC）</p>
</li>
<li><p><a href="https://visualvm.github.io/pluginscenters.html" target="_blank" rel="noopener">插件地址</a></p>
</li>
<li><p><img src="/2021/04/05/jvm/187.png" alt="image-20210708173353483"></p>
</li>
<li><p><img src="/2021/04/05/jvm/186.png" alt="image-20210708173243786"></p>
</li>
<li><p>也可在IDEA里面按安装VisualVM运行插件</p>
<p><img src="/2021/04/05/jvm/188.png" alt="image-20210708173614954"></p>
</li>
</ul>
<h5 id="c，连接方式：-1"><a href="#c，连接方式：-1" class="headerlink" title="c，连接方式："></a>c，连接方式：</h5><ul>
<li>本地连接：监控本地Java进程的CPU，类，线程等</li>
<li>远程连接：<ul>
<li>确定远程服务器的ip地址</li>
<li>添加JMX（通过JMX技术具体监控远端服务器哪个Java进程）</li>
<li>修改bin/catalina.sh文件，连接远程的Tomcat</li>
<li>在../conf中添加jmxremote.access和jmxremote.password文件</li>
<li>将服务器地址改为公网ip地址</li>
<li>设置阿里云安全策略和防火墙策略</li>
<li>启动Tomcat，查看Tomcat启动日志和端口监听</li>
<li>JMX中输入端口号，用户名，密码登陆</li>
</ul>
</li>
</ul>
<h5 id="d，主要功能"><a href="#d，主要功能" class="headerlink" title="d，主要功能"></a>d，主要功能</h5><ul>
<li><p>生成/读取堆内存快照</p>
<p><img src="/2021/04/05/jvm/194.png" alt="image-20210708175901973"></p>
<p><img src="/2021/04/05/jvm/195.png" alt="image-20210708175945174"></p>
</li>
</ul>
<ul>
<li><p>查看JVM参数和系统属性</p>
<p><img src="/2021/04/05/jvm/190.png" alt="image-20210708175259345"></p>
</li>
<li><p>查看运行中的虚拟机进程</p>
<p><img src="/2021/04/05/jvm/189.png" alt="image-20210708175212579"></p>
</li>
<li><p>生成/读取线程快照</p>
<p><img src="/2021/04/05/jvm/196.png" alt="image-20210708180403931"></p>
</li>
<li><p>程序资源的实时监控</p>
<p><img src="/2021/04/05/jvm/191.png" alt="image-20210708175423357"></p>
<p><img src="/2021/04/05/jvm/192.png" alt="image-20210708175545074"></p>
<p><img src="/2021/04/05/jvm/193.png" alt="image-20210708175721036"></p>
</li>
<li><p>其他功能</p>
<ul>
<li>JMX代理连接</li>
<li>远程环境监控</li>
<li>CPU分析和内存分析</li>
</ul>
</li>
<li><p>运行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> ArryaList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> Picture(<span class="keyword">new</span> Random().nextInt(<span class="number">100</span>*<span class="number">50</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] pixels;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Picture</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pixels = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapInstanceTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span>*<span class="number">100</span>)];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HeapInstanceTest());</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h4 id="4，eclipse-MAT"><a href="#4，eclipse-MAT" class="headerlink" title="4，eclipse MAT"></a>4，eclipse MAT</h4><h5 id="a，基本概述：-2"><a href="#a，基本概述：-2" class="headerlink" title="a，基本概述："></a>a，基本概述：</h5><ul>
<li>MAT工具是一款功能强大的Java堆内存分析器，可以用于查找内存泄露以及查看内存消耗情况</li>
<li>MAT是基于Eclipse开发的，不仅可以单独使用，还可以作为插件的形式嵌入在Eclipse中使用，是一款免费的性能分析工具，使用起来非常方便，大家可以在<a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">官方网站</a>下载并使用MAT。</li>
</ul>
<h5 id="b，获取堆dump文件"><a href="#b，获取堆dump文件" class="headerlink" title="b，获取堆dump文件"></a>b，获取堆dump文件</h5><p><strong>dump文件内容</strong></p>
<blockquote>
<p>MAT可以分析heap dump文件，在进行内存分析时，只要获得了反映当前设备内存映像的hprof文件，通过MAT打开就可以直观地看到当前的内存信息</p>
<p>一般来说，这些内存信息包含：</p>
<ul>
<li>所有的对象信息，包括对象实例，成员变量，存储于栈中的基本类型值和存储于堆中的其他对象的引用值</li>
<li>所有的类信息，包括classloader，类名称，父类，静态变量等</li>
<li>GCRoot到所有的这些对象的引用路劲</li>
<li>线程信息，包括线程的调用栈以及此线程的线程局部变量（TLS）</li>
</ul>
</blockquote>
<p><strong>两点说明</strong></p>
<blockquote>
<p>说明1：缺点</p>
<p>MAT不是一个万能工具，它并不能处理所有类型的堆存储文件，但是比较主流的厂家和格式，例如SUN，HP，SAP所采用的HPROF二进制堆存储文件，以及IBM的PHD堆存储文件等都能被很好的解析</p>
<p>说明2：</p>
<p>最吸引人的还是能够快速为开发人员生成<strong>内存泄露报表</strong>，方便定位问题和分析问题，虽然MAT有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从MAT展现给我们的信息当中通过经验和直觉来判断才能发现</p>
</blockquote>
<h5 id="c，分析堆dump文件"><a href="#c，分析堆dump文件" class="headerlink" title="c，分析堆dump文件"></a>c，分析堆dump文件</h5><ul>
<li><p><strong>histogram：</strong></p>
<blockquote>
<p>MAT的直方图和jmap的-histo子命令一样，都能够展示各个类的实例数目以及这些实例的Shallow heap总和。但是，MAT的直方图还能够计算Retained heap，并支持基于实例数据或Retained heap的排序方式（默认为Shallow heap）</p>
<p>此外，MAT还可以将直方图中的类按照超类，类加载器或者包名分组。</p>
<p>当选中某个类时，MAT界面左上角的Inspector窗口将展示该类的Class实例的相关信息，如类加载器等</p>
</blockquote>
</li>
<li><p><strong>thread overview</strong></p>
<ul>
<li>查看系统中的Java线程</li>
<li>查看局部变量的信息</li>
</ul>
</li>
<li><p><strong>获得对象相互引用的关系</strong></p>
<ul>
<li>with outgoing references</li>
<li>with incoming references</li>
</ul>
</li>
<li><p><strong>浅堆和深堆</strong></p>
<ul>
<li><p>shallow heap</p>
<blockquote>
<p>浅堆（Shallow Heap）是指一个对象所消耗的内存，在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节，根据堆快照格式不同，对象的大小可能会向8字节进行对齐</p>
<p>以String为例：2个int值共占8字节，对象引用占用4字节，对象头8字节，合计20字节，向8字节对齐，故占24字节（JDK7）；这24字节为String对象的浅堆大小，它与String的value实际取值无关，无论字符串长度如何，浅堆大小始终是24字节。</p>
</blockquote>
</li>
<li><p>retained heap</p>
<blockquote>
<ul>
<li><strong>保留集（Retained Set）</strong>：</li>
</ul>
<p>对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合（包括对象A本身），即对象A的保留集可以被认为是<strong>只能通过</strong>对象A被直接或间接访问到的所有对象的集合，通俗地说，就是指仅被对象A所持有的对象的集合</p>
<ul>
<li><strong>深堆（Retained Heap）</strong>：</li>
</ul>
<p>深堆是指对象的保留集中所有的对象的浅堆大小之和</p>
<ul>
<li>注意；浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象 访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</li>
</ul>
</blockquote>
</li>
<li><p>补充：对象实际大小</p>
<blockquote>
<p>另外一个常用的概念是对象的实际代销，这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，这个概念和垃圾回收无关。</p>
<p>下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E，那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A,C,D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不再对象A的深堆范围内。</p>
<p><img src="/2021/04/05/jvm/197.png" alt="image-20210710170743357"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>支配树（Dominator Tree）：</p>
<blockquote>
<p>支配树的概念源自图论</p>
<p>MAT提供了一个称为支配树（Dominator Tree）对象图，支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A，则认为<strong>对象A支配对象B</strong>，如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的<strong>直接支配者</strong>。支配树是基于对象间的引用图所建立的，他有以下基本性质：</p>
<ul>
<li>对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set），即深堆。</li>
<li>如果对象A支配对象B，那么对象A的直接支配者也支配对象B</li>
<li>支配树的边与对象引用图的边不直接对应。</li>
</ul>
<p>如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A，也可以经过B，因此对象C的直接支配者也是根对象。对象F与对象D相互引用，因为到对象F的所有路径必然经过对象D，因此，对象D是对象F的直接支配者，而到对象D的所有路径中，必然经过对象C，即使是从对象F到对象D的因应该你，从根节点触发，也是经过对象C的，所以，对象D的直接支配者为对象C</p>
<p><img src="/2021/04/05/jvm/198.png" alt="image-20210710171913356"></p>
<p>同理，对象E支配对象G，到达对象H的可以通过对象D，也可以通过对象E，因此对象D和E都不能支配对象H，而经过对象C既可以到达D也可以到达E，因此对象C为对象H的直接支配者</p>
</blockquote>
</li>
</ul>
<h5 id="d，Tomcat堆溢出分析"><a href="#d，Tomcat堆溢出分析" class="headerlink" title="d，Tomcat堆溢出分析"></a>d，Tomcat堆溢出分析</h5><blockquote>
<p>Tomcat是最常用的JAVA Servlet容器之一，同时也可以当做单独的Web服务器使用，Tomcat本身使用Java实现，并运行于Java虚拟机之上，在大规模请求时，Tomcat有可能会因为无法承受压力而发生内存溢出错误，这里根据一个被压垮的Tomcat的堆快照文件来分析Tomcat在崩溃时的内部情况</p>
</blockquote>
<p><img src="/2021/04/05/jvm/199.png" alt="image-20210710173815848"></p>
<p><img src="/2021/04/05/jvm/200.png" alt="image-20210710174536256"></p>
<p><img src="/2021/04/05/jvm/201.png" alt="image-20210710174604247"></p>
<p><img src="/2021/04/05/jvm/202.png" alt="image-20210710174646957"></p>
<p><img src="/2021/04/05/jvm/203.png" alt="image-20210710174720374"></p>
<p><img src="/2021/04/05/jvm/204.png" alt="image-20210710174755474"></p>
<p><img src="/2021/04/05/jvm/205.png" alt="image-20210710174823233"></p>
<p><img src="/2021/04/05/jvm/206.png" alt="image-20210710174854792"></p>
<h4 id="5，补充1：再谈内存泄露"><a href="#5，补充1：再谈内存泄露" class="headerlink" title="5，补充1：再谈内存泄露"></a>5，补充1：再谈内存泄露</h4><h5 id="a，内存泄露的理解与分类"><a href="#a，内存泄露的理解与分类" class="headerlink" title="a，内存泄露的理解与分类"></a>a，内存泄露的理解与分类</h5><p><strong>何为内存泄露：</strong></p>
<blockquote>
<p><img src="/2021/04/05/jvm/207.png" alt="image-20210710175646774"></p>
<p>可达性分析算法类判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多内存泄露问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄露）</p>
<p>是否还被使用？是</p>
<p>是否还被需要？否</p>
<p>即发生了内存泄露</p>
</blockquote>
<p><strong>内存泄露（memory leak）的理解</strong></p>
<blockquote>
<p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄露。</p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄露”</p>
<p><img src="/2021/04/05/jvm/208.png" alt="image-20210710180203697"></p>
<p>对象X引用对象Y，X的生命周期比Y的生命周期长；</p>
<p>那么当Y生命周期结束的时候，X依然引用着Y，这时候，垃圾回收期是不会回收对象Y的；</p>
<p>如果对象X还引用着生命周期比较短的A,B,C，对象A又引用着对象a,b,c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄露，直到内存溢出</p>
</blockquote>
<p><strong>内存泄露与内存溢出的关系</strong>：</p>
<blockquote>
<ul>
<li><p>内存泄露（memory leak）：</p>
<p>申请了内存用完了不释放，比如一共有1024M的内存，分配了512M的内存一直不回收，那么可以用的内存就只有512M了，仿佛泄露掉了一部分</p>
<p>通俗一点讲，内存泄露就是【占着茅坑不拉屎】</p>
</li>
<li><p>内存溢出（out of memory）</p>
<p>申请内存时，没有足够的内存可以使用</p>
<p>通俗一点讲，厕所坑位供应小于需求，不够用了，内存泄露变成了内存溢出</p>
</li>
<li><p>泄露的分类：</p>
<ul>
<li>经常发生：发生内存泄露的代码会被多次执行，每次执行，泄露一块内幕才能</li>
<li>偶然发生：在某些特定情况下才会发生</li>
<li>一次性：发生内存泄露的方法只会执行一次</li>
<li>隐式泄露：一直占着内存不释放，直到执行结束；严格的来说这个不算内存泄露，因为最终释放掉了</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="b，Java中内存泄露的8种情况"><a href="#b，Java中内存泄露的8种情况" class="headerlink" title="b，Java中内存泄露的8种情况"></a>b，Java中内存泄露的8种情况</h5><ul>
<li><p><strong>静态集合类</strong></p>
<ul>
<li><p>静态集合类，如HashMap，LinkedList等等，如果这些容器为静态的，那么他们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄露，简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span></span>{
    <span class="keyword">static</span> List list = <span class="keyword">new</span> ArrayList();
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oomTests</span><span class="params">()</span></span>{
        Object obj = <span class="keyword">new</span> Object();<span class="comment">//局部变量</span>
        list.add(obj);
    }
}
&lt;!--￼<span class="number">114</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>变量不合理的作用域</strong></p>
<ul>
<li><p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄露。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄露的发生</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandom</span></span>{
    <span class="keyword">private</span> String msg;
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>{
        readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span>
        saveDB();<span class="comment">//把msg保存到数据库中</span>
    }
}
&lt;!--￼<span class="number">115</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>缓存泄露</strong></p>
<ul>
<li><p>内存泄露的另一常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据</p>
<p>对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用，那么此map会自动丢弃此值</p>
</li>
<li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span></span>{
    <span class="keyword">static</span> Map wMap = <span class="keyword">new</span> WeakHashMap();
    <span class="keyword">static</span> Map map = <span class="keyword">new</span> HashMap();
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{
        init();
        testWeakHashMap();
        testHashMap();
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{
        String ref1 = <span class="keyword">new</span> String(<span class="string">"Object1"</span>);
        String ref2 = <span class="keyword">new</span> String(<span class="string">"object2"</span>);
        String ref3 = <span class="keyword">new</span> String(<span class="string">"object3"</span>);
        String ref4 = <span class="keyword">new</span> String(<span class="string">"object4"</span>);
        wMap.put(ref1,<span class="string">"cacheObject1"</span>);
        wMap.put(ref2,<span class="string">"cacheObject2"</span>);
        map.put(ref3,<span class="string">"cacheObject3"</span>);
        map.put(ref4,<span class="string">"cacheObject4"</span>);
        System.out.println(<span class="string">"String引用了ref1,ref2,ref3,ref4消失"</span>)
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakHashMap</span><span class="params">()</span></span>{
        System.out.println(<span class="string">"WeakHashMap GC之前"</span>);
        <span class="keyword">for</span>(Object o : wMap.entrySet()){
            System.out.println(o);
        }
        <span class="keyword">try</span>{
            System.gc();
            TimeUnit.SECONDS.sleep(<span class="number">5</span>);
        }<span class="keyword">catch</span>(InterrupedException e){
            e.printStackTrace();
        }
        System.out.pringln(<span class="string">"WeakHash GC之后"</span>);
        <span class="keyword">for</span>(Object o : wMap.entrySet()){
            System.out.println(o);
        }
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHashMap</span><span class="params">()</span></span>{
        System.out.println(<span class="string">"HashMap GC之前"</span>);
        <span class="keyword">for</span>(Object o : Map.entrySet()){
            System.out.println(o);
        }
        <span class="keyword">try</span>{
            System.gc();
            TimeUnit.SECONDS.sleep(<span class="number">5</span>);
        }<span class="keyword">catch</span>(InterrupedException e){
            e.printStackTrace();
        }
        System.out.pringln(<span class="string">"Hash GC之后"</span>);
        <span class="keyword">for</span>(Object o : Map.entrySet()){
            System.out.println(o);
        }
    }
}
&lt;!--￼<span class="number">116</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>分析：</p>
<blockquote>
<p>上述程序并没有明显的错误，但是这段程序有一个内存泄露，随着GC活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄露，但是这种失败情况相对较少。</p>
<p>代码的主要问题在pop函数，下面通过这张图示展现</p>
<p>假设这个栈一直增长，增长后如下图所示</p>
<p><img src="/2021/04/05/jvm/210.png" alt="image-20210711150511019"></p>
<p>当进行大量的pop操作时，由于引用未进行置空，gc是不会释放的，如下图所示；</p>
<p><img src="/2021/04/05/jvm/211.png" alt="image-20210711150613539"></p>
<p>从上图中可以看出，如果栈先增长，在收缩，那么从栈中弹出的对象将不会被当做垃圾回收，即使程序不再使用栈中的这些对象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称<strong>过期引用</strong>，这个内存泄露很隐蔽</p>
</blockquote>
</li>
<li><p>案例代码2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object key = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(BUndle savedInstanceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;<span class="comment">//匿名线程</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (key)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        key.wati();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析2：</p>
<p><img src="/2021/04/05/jvm/212.png" alt="image-20210711151900110"></p>
<p><img src="/2021/04/05/jvm/213.png" alt="image-20210711151934224"></p>
</li>
<li><p>解决方法：</p>
<ul>
<li>使用线程时，一定要确保线程在周期性对象（如Activity）销毁时能正常结束，如能正常结束，但是Activity销毁后还需执行一段时间，也可能造成泄露，此时可采用WeakReference方法来解决，另外在使用Handler的时候，如存在Delay操作，也可以采用WeakReference</li>
<li>使用Handler + HandlerThread时，记住在周期性对象销毁时调用looper.quit()方法</li>
</ul>
</li>
</ul>
<h4 id="6，补充2：支持使用OOL语言查询对象信息"><a href="#6，补充2：支持使用OOL语言查询对象信息" class="headerlink" title="6，补充2：支持使用OOL语言查询对象信息"></a>6，补充2：支持使用OOL语言查询对象信息</h4><blockquote>
<p>MAT支持一种类似于SQL的查询语言OQL（Object Query Language）。OQL使用类SQL语法，可以在堆中进行对象的查找和筛选</p>
</blockquote>
<h5 id="a，SELECT子句："><a href="#a，SELECT子句：" class="headerlink" title="a，SELECT子句："></a>a，SELECT子句：</h5><blockquote>
<p>在MAT中，Select子句的格式与SQL基本一致，用于指定要显示的列，Select子句中可以使用“*”，查看结果对象的引用实例（相当于outgoing references）</p>
<p>SELECT * FROM java.util.Vector v</p>
<p>使用“OBJECTS”关键字，可以将返回结果集中的项以对象的形式显示</p>
<p>SELECT objects v.elementData FROM java.util.Vector v</p>
<p>SELECT OBJECTS s.value FROM java.lang.String s</p>
<p>在Select子句中，使用“AS RETAINED SET”关键字可以得到所得对象的保留集。</p>
<p>SELECT AS RETAINED SET * FROM com.atguigu.mat.Student</p>
<p>“DISTINCT”关键字用于在结果集中去除重复对象</p>
<p>SELECT DISTINCT OBJECTS classof(s) FROM java.lang.String s</p>
</blockquote>
<h5 id="b-FROM子句"><a href="#b-FROM子句" class="headerlink" title="b,FROM子句"></a>b,FROM子句</h5><blockquote>
<p>From子句用于指定查询方位，它可以指定类名，正则表达式或者对象地址</p>
<p>SELECT * FROM java.lang.String s</p>
<p>下列使用正则表达式，限定搜索方位，输出所有com.atguitu包下所有类的实例</p>
<p>SELECT * FROM “com\.atguigu\..*”</p>
<p>也可以直接使用类的地址进行搜索，使用类的地址的好处是可以区分被不同ClassLoader加载的同一种类型</p>
<p>SELECT * FROM 0x37a0b4d</p>
</blockquote>
<h5 id="c，WHERE子句"><a href="#c，WHERE子句" class="headerlink" title="c，WHERE子句"></a>c，WHERE子句</h5><blockquote>
<p>where子句用于指定OQL的查询条件，OQL查询将只返回满足where子句指定条件的对象。where子句的格式与传统SQL极为相似</p>
<p>下例返回长度大于10的char数组</p>
<p>SELECT * FROM char[] s WHERE s.@length&gt;10</p>
<p>下列返回包含”java”子字符串的所有字符串，使用“LIKE”操作符，“LIKE”操作符的操作参数为正则表达式</p>
<p>SELECT * FROM java.lang.String s WHERE toString(s) LIKE “.*java.*“</p>
<p>下列返回所有value域不为null的字符串，使用“=”操作符</p>
<p>SECLECT * FROM java.lang.String s where s.value != null</p>
<p>where子句支持多个条件的AND、OR运算，下列返回数组长度大于 15，并且深堆大于1000字节的素有Vector对象</p>
<p>SELECT * FROM java.util.Vector v WHERE v.elementData.@length&gt;15 AND v.@retainedHeapSize&gt;1000</p>
</blockquote>
<h5 id="d，内置对象与方法"><a href="#d，内置对象与方法" class="headerlink" title="d，内置对象与方法"></a>d，内置对象与方法</h5><blockquote>
<p>OQL中可以访问堆内对象的属性，也可以方位堆内代理对象的属性，访问堆内对象的属性时，格式如下：</p>
<p>[ <alias> .] <field> . <field> . <field></field></field></field></alias></p>
<p>其中alias为对象名称</p>
<p>访问java.ioFile对象的path属性，并进一步访问path的value属性：</p>
<p>SELECT toString(f.path.value) FROM java.io.File  f</p>
<p>下例显示了String对象的内容、objectid和objectAddress</p>
<p>SELECT s.toString()，s.@objectId，s.@objectAddress FROM java.lang.String s</p>
<p>下例显示java.util.Vector内部数组的长度</p>
<p>SELECT v.elementData.@length FROM java.util.Vector v</p>
<p>下例显示了所有的java.util.Vector对象以及其子类类型</p>
<p>SELECT * FROM INSTATNCEOF java.util.Vector     </p>
</blockquote>
<h4 id="7，JProfiler"><a href="#7，JProfiler" class="headerlink" title="7，JProfiler"></a>7，JProfiler</h4><h5 id="a，基本概述"><a href="#a，基本概述" class="headerlink" title="a，基本概述"></a>a，基本概述</h5><blockquote>
<p>在运行Java的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了，在eclipse里面有MAT插件可以测试，而在IDEA中也有这么一个插件，就是JProfiler</p>
<p><a href="https://www.ej-technologied.com/products/jprofiler/overview.html" target="_blank" rel="noopener">官方网站</a></p>
</blockquote>
<ul>
<li>特点：<ul>
<li>使用方便，界面操作友好（简单且强大）</li>
<li>对被分析的应用影响小</li>
<li>CPU,Thread,Memory分析功能尤其强大</li>
<li>支持对jdbc，noSql，jsp，servlet，socket等进行分析</li>
<li>支持多种模式（离线，在线）的分析</li>
<li>支持监控本地，远程的JVM</li>
<li>跨平台，拥有多种操作系统的安装版本</li>
</ul>
</li>
<li>主要功能：<ul>
<li>方法调用：对方法调用的肥西可以帮助你了解应用程序正在做什么，并找到提高其性能的方法</li>
<li>内存分配：通过分析堆上对象，引用链和垃圾收集能帮你修复内存泄露问题，优化内存使用</li>
<li>线程与锁：JProfiler提供多种针对线程和锁的分析视图助你发现多线程问题</li>
<li>高级子系统：许多性能问题都发生在更高的语义级别上，例如：对JDBC调用，你可能希望找出执行最慢的SQL语句，JProfiler支持对这些子系统进行集成分析</li>
</ul>
</li>
</ul>
<h5 id="b，具体使用"><a href="#b，具体使用" class="headerlink" title="b，具体使用"></a>b，具体使用</h5><ul>
<li><p><strong>数据采集方式</strong>：</p>
<ul>
<li><p><strong>Instumentation重构模式</strong></p>
<ul>
<li>这是JProfiler全功能模式，在class加载之前，JProfiler把相关功能代码写入到需要分析的class的bytecode中，对正在运行的jvm有一定影响</li>
<li>优点：功能强大，在此设置中，调用堆栈信息是准确的</li>
<li>缺点：若要分析的class较多，则对应用的性能影响较大，CPU开销可能很高（取决于Filter的控制），因此使用此模式一般配合Filter使用，只对特定的类或包进行分析</li>
</ul>
</li>
<li><p><strong>Sampling抽样模式</strong></p>
<ul>
<li>类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来</li>
<li>优点：对CPU的开销非常低，对应用影响小（即使你不配置任何Filter）</li>
<li>缺点：一些数据/特定不能提供（例如：方法的调用层次，执行时间）</li>
</ul>
</li>
<li><p>注：JProfiler本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型，因为JProfiler的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是JProfiler的数据采集类型。</p>
<p><img src="/2021/04/05/jvm/214.png" alt="image-20210711172027666"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>遥感监测Telemetries</strong></p>
<ul>
<li><strong>整体视图Overview</strong>：<ul>
<li>显示堆内存，CPU，线程以及GC等活动视图</li>
</ul>
</li>
<li><strong>内存Memory</strong>：<ul>
<li>显示一张关于内存变化的活动时间表</li>
</ul>
</li>
<li><strong>记录的对象Recorded objects</strong>：<ul>
<li>显示一张关于活动对象与数组的图表的活动时间表</li>
</ul>
</li>
<li><strong>记录吞吐量Record Throughput</strong>：<ul>
<li>显示一段时间累积的JVM生产和释放的活动时间表</li>
</ul>
</li>
<li><strong>垃圾回收活动GC Activity</strong>：<ul>
<li>显示一张关于垃圾回收活动的活动时间表</li>
</ul>
</li>
<li><strong>类Classes</strong>：<ul>
<li>显示一个与已装载类的图表的活动时间表</li>
</ul>
</li>
<li><strong>线程Threads</strong>：<ul>
<li>显示一个与动态线程的图表的活动时间表</li>
</ul>
</li>
<li><strong>CPU负载CPU Load</strong>：<ul>
<li>显示一段时间中CPU的负载图表</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>内存视图Live Memory</strong></p>
<blockquote>
<p>Live Memory内存剖析：class/class instance的相关信息，例如对象的个数，大小，对象创建的方法执行栈，对象创建的热点</p>
</blockquote>
<ul>
<li><p><strong>所有对象ALL object</strong></p>
<ul>
<li><p>显示所有加载的类的列表和在堆上分配的实例数。只有JAVA1.5才会显示此视图</p>
<p><img src="/2021/04/05/jvm/215.png" alt="image-20210711173100290"></p>
</li>
</ul>
</li>
<li><p><strong>记录对象Record Objects</strong></p>
<ul>
<li>查看特定时间段对象的分配，并记录分配的调用堆栈</li>
</ul>
</li>
<li><p><strong>分配访问树Allocation Call Tree</strong></p>
<ul>
<li>显示一颗请求树或者方法，类，包或对已选择类有带注释的分配信息的J2EE组件</li>
</ul>
</li>
<li><p><strong>分配热点Allocation Hot Spots</strong></p>
<ul>
<li>显示一个列表，包括方法，类，包或分配已选类的J2EE组件，你可以标注当前值并且显示差异值，对于每个热点都可以显示它的跟踪记录树</li>
</ul>
</li>
<li><p><strong>类追踪器Class Tracker</strong></p>
<ul>
<li>类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间</li>
</ul>
</li>
<li><p><strong>分析：内存中的对象的情况</strong></p>
<ul>
<li>频繁创建的Java对象：死循环，循环次数过多</li>
<li>存在大的对象：读取文件时，byte[]应该边读边写。 ——》如果长时间不写出的话，导致byte[]过大</li>
<li>存在内存泄露</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>堆遍历heap Walker</strong></p>
<ul>
<li><strong>类Classes</strong><ul>
<li>显示所有类和他们的实例，可以右击具体的类“Used Selected Instance”实现进一步跟踪</li>
</ul>
</li>
<li><strong>分配Allocations</strong><ul>
<li>为所有记录对象显示分配树和分配热点</li>
</ul>
</li>
<li><strong>索引References</strong><ul>
<li>为单个对象和“显示到垃圾回收根目录的路径”提供索引图的显示功能，还能提供合并输入视图和输出视图的功能</li>
</ul>
</li>
<li><strong>时间Time</strong><ul>
<li>显示一个对已记录对象的解决时间的柱状图</li>
</ul>
</li>
<li><strong>检查Inspections</strong><ul>
<li>显示了一个数量的操作，将分析当前对象集在某种条件下的子集，实质是一个筛选的过程</li>
</ul>
</li>
<li><strong>图表Graph</strong><ul>
<li>你需要在references视图和biggest视图手动添加对象到图表，它可以显示对象的传入和传出引用，能方便的找到垃圾收集器根源</li>
</ul>
</li>
<li>PS：在工具栏点击“Go To Start”可以使堆内存重新计数，也就是回到初始状态</li>
</ul>
</li>
<li><p><strong>CPU视图 cpu views</strong></p>
<blockquote>
<p>JProfiler提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择，所有的视图都可以聚集到方法，类，包或J2EE组件等不同层上</p>
</blockquote>
<ul>
<li><strong>访问树Call Tree</strong><ul>
<li>显示一个积累的自顶向下的树，树中包含所有在JVM中已记录的访问队列。JDBC，JMS和JNDE服务请求都被注释在请求树中，请求树可以根据Servlet和JSP对URL的不同需要进行拆分</li>
</ul>
</li>
<li><strong>热点Hot Spots</strong><ul>
<li>显示消耗时间最多的方法的列表，对每个热点都能够显示回溯树，该热点可以按照方法请求，JDBC，JMS和JNDI服务请求以及按照URL请求来进行计算</li>
</ul>
</li>
<li><strong>访问图Call Graph</strong><ul>
<li>显示一个从已选方法，类，包或J2EE组件开始的访问队列的图</li>
</ul>
</li>
<li><strong>方法统计Method Statistis</strong><ul>
<li>显示一段时间内记录的方法的调用时间细节</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线程视图threads</strong></p>
<blockquote>
<p>JProfiler通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程锁管理的方法以树状形势呈现，对线程剖析</p>
</blockquote>
<ul>
<li><strong>线程历史Thread History</strong><ul>
<li>显示一个与线程活动和线程状态在一起的活动时间表</li>
</ul>
</li>
<li><strong>线程监控Thread Monitor</strong><ul>
<li>显示一个列表，包括所有的活动线程以及他们目前的活动状况</li>
</ul>
</li>
<li><strong>线程转储Thread Dumps</strong><ul>
<li>显示所有线程的堆栈跟踪</li>
</ul>
</li>
<li><strong>线程分析主要关心三个方面：</strong><ul>
<li>web容器的线程最大数。比如：Tomcat的线程容量应该略大于最大并发数</li>
<li>线程阻塞</li>
<li>线程死锁</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>监控和锁 Monitor &amp; Locks</strong></p>
<blockquote>
<p>所有线程持有锁的情况以及锁的信息，观察JVM的内部线程并查看状态</p>
</blockquote>
<ul>
<li><strong>死锁探测图表Current Locking Graph</strong><ul>
<li>显示JVM中的当前死锁图表</li>
</ul>
</li>
<li><strong>目前使用的监测器Current Monitors</strong><ul>
<li>显示目前使用的监测器并且包括它们的关联线程</li>
</ul>
</li>
<li><strong>锁定历史图表Locking History Graph</strong><ul>
<li>显示记录在JVM中的锁定历史</li>
</ul>
</li>
<li><strong>历史检测记录Monitor History</strong><ul>
<li>显示重大的等待事件和阻塞事件的历史记录</li>
</ul>
</li>
<li><strong>监控器使用统计Monitor Usage Statistics</strong><ul>
<li>显示分组监测，线程和监测类的统计监测数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="c，案例分析："><a href="#c，案例分析：" class="headerlink" title="c，案例分析："></a>c，<strong>案例分析：</strong></h5><p><strong>正常情况下</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JProfilerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">                Data data = <span class="keyword">new</span> Data();</span><br><span class="line">                list.add(data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1mb</span></span><br><span class="line">    <span class="keyword">private</span> String info = <span class="string">"hello,atguigu"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存泄露的情况下</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ArrayList beanList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">                Bean data = <span class="keyword">new</span> Bean();</span><br><span class="line">                data.list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">10</span>]);<span class="comment">//10kb</span></span><br><span class="line">                beanList.add(data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">    String info = <span class="string">"hello,atguigu"</span>;</span><br><span class="line">     ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//    static ArrayList list = new ArrayList();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8，Arthas"><a href="#8，Arthas" class="headerlink" title="8，Arthas"></a>8，Arthas</h4><h5 id="a，基本概述-1"><a href="#a，基本概述-1" class="headerlink" title="a，基本概述"></a>a，基本概述</h5><ul>
<li><p><strong>背景</strong>：</p>
<blockquote>
<p>jvisulvm和jprofiler这两款工具在业界知名度也比较高，他们的优点是可以图形界面上看到各维度的性能数据，使用者根据这些数据进行综合分析，然后判断哪里出现了性能问题</p>
<p>但是这两款工具也有个缺点，都必须在服务器项目进程中配置相关的监控参数，然后工具通过远程连接到项目进程，获取相关的数据，这样就会带来一些不便，比如线上环境的网络是隔离的，本地的监控工具根本连不上线上环境，并且类似于Jprofiler这样的商业工具，是需要付费的</p>
<p>那么有没有一款工具不需要远程连接，也不需要配置监控参数，同时也提供了丰富的性能监控数据呢？</p>
<p>那就是阿里巴巴开源的性能分析神器Arthas(阿尔萨斯)</p>
</blockquote>
</li>
<li><p><strong>概述</strong>：</p>
<blockquote>
<p>Arthas是Alibaba开源的Java诊断工具，深受开发者喜爱，在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态</p>
<p>Arthas支持JDK6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的Tab自动补全功能，进一步方便进行问题的定位与诊断</p>
<p>当你遇到以下类似问题二束手无策时，arthas可以帮助你解决？</p>
<ul>
<li>这个类从哪个jar包加载的？为什么会报各种类相关的Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没commit？分支搞错了？</li>
<li>遇到问题无法再线上debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题， 但是线上同样无法debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到JVM的实时运行状态？</li>
<li>怎么快速定位应用的热点，生成火焰图？</li>
</ul>
</blockquote>
</li>
<li><p><a href="https://arthas.aliyun.com/zh-cn/" target="_blank" rel="noopener">官方文档</a></p>
</li>
</ul>
<h5 id="b，安装与使用"><a href="#b，安装与使用" class="headerlink" title="b，安装与使用"></a>b，安装与使用</h5><ul>
<li>工程目录：<ul>
<li>arthas-agent：基于JavaAgent技术的处理</li>
<li>bin：一些启动脚本</li>
<li>arthas-boot：Java版本的一键安装启动脚本</li>
<li>arthas-client：telnet client代码</li>
<li>arthas-common：一些共用的工具类和枚举类</li>
<li>arthas-core：核心库，各种arthas命令的交互和实现</li>
<li>arthas-demo：示例代码</li>
<li>arthas-memorycompiler：内存编译器代码，fork from <a href="https://github.com/skalogs/SkaETL/tree/master/compiler" target="_blank" rel="noopener">https://github.com/skalogs/SkaETL/tree/master/compiler</a></li>
<li>arthas-packaging：maven打包相关的</li>
<li>arthas-site：arthas站点</li>
<li>arthas-spy：编织到目标类中的各个切面</li>
<li>static：静态资源</li>
<li>arthas-testcase：测试</li>
</ul>
</li>
<li>启动：<ul>
<li>java -jar arthas-boot.jar [PID]</li>
</ul>
</li>
</ul>
<h5 id="c，相关诊断指令"><a href="#c，相关诊断指令" class="headerlink" title="c，相关诊断指令"></a>c，相关诊断指令</h5><ul>
<li><strong>基础命令</strong>：<ul>
<li><strong>help</strong>——查看命令帮助信息</li>
<li><strong>cat</strong>——打印文件内容，和Linux里的cat命令类似</li>
<li><strong>echo</strong>——打印参数，和Linux里的echo命令类似</li>
<li><strong>grep</strong>——匹配查找，和Linux里的grep命令类似</li>
<li><strong>base64</strong>——base64编码转换，和Linux里的base64命令类似</li>
<li><strong>tee</strong>——复制标准输入到标准输出和指定的文件，和Linux的tee命令类似</li>
<li><strong>pwd</strong>——返回当前的工作目录</li>
<li><strong>cls</strong>——清空当前屏幕区域</li>
<li><strong>session</strong>——查看当前会话的信息</li>
<li><strong>reset</strong>——重置增强类，将被arthas增强过的类全部还原，arthas服务端关闭时会重置所有增强过的类</li>
<li><strong>version</strong>——输出当前目标Java进程所加载的arthas版本号</li>
<li><strong>history</strong>——打印命令历史</li>
<li><strong>quit</strong>——退出当前arthas客户端，其他arthas客户端不受影响</li>
<li><strong>stop</strong>——关闭Arthas服务端，所有arthas客户端不受影响</li>
<li><strong>keymap</strong>——arthas快捷键列表及自定义快捷键</li>
</ul>
</li>
<li><strong>JVM相关</strong><ul>
<li><strong>dashboard</strong>——当前系统的实时数据面板</li>
<li><strong>thread</strong>——查看当前JVM的线程堆栈信息</li>
<li><strong>jvm</strong>——查看当前JVM的信息</li>
<li><strong>sysprop</strong>——查看和修改JVM的系统属性</li>
<li><strong>sysenv</strong>——查看JVM的环境变量</li>
<li><strong>vmoption</strong>——查看和修改JVM里诊断相关的option</li>
<li><strong>perfcounter</strong>——查看当前JVM的Perf Counter的信息</li>
<li><strong>logger</strong>——查看和修改logger</li>
<li><strong>getstatic</strong>——查看类的静态属性</li>
<li><strong>ognl</strong>——执行ognl表达式</li>
<li><strong>mbean</strong>——查看Mbean的信息</li>
<li><strong>heapdump</strong>——dump Java heap，类似jmap命令的heap dump功能</li>
<li><strong>vmtool</strong>——从jvm里查询对象，执行forceGC</li>
</ul>
</li>
<li><strong>class/classloader相关</strong><ul>
<li><strong>sc</strong>——查看JVM已加载的类信息</li>
<li><strong>sm</strong>——查看已加载类的方法信息</li>
<li><strong>jad</strong>——反编译指定已加载类的源码</li>
<li><strong>mc</strong>——内存编译器，内存编译.java文件为.class文件</li>
<li><strong>retransform</strong>——加载外部的.class文件，retransform到JVM里</li>
<li><strong>redefine</strong>——加载外部的.class文件，redefine到JVM里</li>
<li><strong>dump</strong>——dump已加载类的byte code到特定目录</li>
<li><strong>classloader</strong>——查看classloader的继承树，urls，类加载信息，施一公classloader去getResource</li>
</ul>
</li>
<li><strong>monitor/watch/trace相关</strong><ul>
<li><strong>monitor</strong>——方法执行监控</li>
<li><strong>watch</strong>——方法执行数据观测</li>
<li><strong>trace</strong>——方法内部调用路径，并输出方法路径上的每个节点上耗时</li>
<li><strong>stack</strong>——输出当前方法被调用的调用路径</li>
<li><strong>tt</strong>——方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</li>
</ul>
</li>
<li><strong>profiler/火焰图</strong><ul>
<li><strong>profiler</strong>——使用async_profiler对应用采样，生成火焰图</li>
</ul>
</li>
<li><strong>options</strong>：<ul>
<li><strong>options</strong>——查看或设置arthas全局开关</li>
</ul>
</li>
</ul>
<h4 id="9，Java-Mission-Control-JMC"><a href="#9，Java-Mission-Control-JMC" class="headerlink" title="9，Java Mission Control(JMC)"></a>9，Java Mission Control(JMC)</h4><h5 id="a，概述："><a href="#a，概述：" class="headerlink" title="a，概述："></a>a，概述：</h5><blockquote>
<p>Java Mission Control（简称JMV），Java官方提供的性能强劲的工具，是一个用于对Java应用程序进行管理，监视，概要分析和故障排除的工具套件</p>
<p>它包含一个GUI客户端，以及众多用来收集Java虚拟机性能数据的插件，如JMX Console（能够访问用来存放虚拟机各个子系统运行数据的MXBeans），以及虚拟机内置的高效profiling工具Java Flight Recorder（JFR）</p>
<p>JMC的另一个优点就是：采用取样，而不是传统的代码植入技术，对应用性能的影响非常小，完全可以开着JMV来做压测（唯一影响的可能是full gc多了）</p>
</blockquote>
<h5 id="b，功能：实时监控JVM运行时的状态"><a href="#b，功能：实时监控JVM运行时的状态" class="headerlink" title="b，功能：实时监控JVM运行时的状态"></a>b，功能：实时监控JVM运行时的状态</h5><blockquote>
<p>如果是远程服务器，使用前要开JMX</p>
<p>-Dcom.sun.management.jmxremote.port=${YOUR PORT}</p>
<p>-Dcom.sun.management.jmxremote</p>
<p>-Dcom.sun.management.jmxremote.authenticate=false</p>
<p>-Dcom.sun.management.jmxremote.ssl=false</p>
<p>-Djava.rmi.server.hostname=${YOUR HOST/IP}</p>
</blockquote>
<p>文件——》连接——》创建新连接，填入上面JMX参数的host和port</p>
<h5 id="c，Java-Flight-Recorder"><a href="#c，Java-Flight-Recorder" class="headerlink" title="c，Java Flight Recorder"></a>c，Java Flight Recorder</h5><blockquote>
<p>Java Flight Recorder是JMC的其中一个组件</p>
<p>Java Flight Recorder能够以极低的性能开销收集Java虚拟机的性能数据</p>
<p>JFR的性能开销很小，在默认配置下平均低于1%，与其他工具相比，JFR能够直接访问虚拟机内的数据，并且不会影响虚拟机的优化，因此，它非常适用于生产环境下满负荷运行的Java程序</p>
<p>Java Flight Recorder和JDK Mission Control共同创建了一个完整的工具链。JDK Mission Control可对Java Flight Recorder连接收集低水平和详细的运行时信息进行高效，详细分析</p>
</blockquote>
<ul>
<li><p><strong>事件类型</strong></p>
<ul>
<li>当启动时，JFR将记录运行过程中发生的一系列事件。其中包括Java层面的事件，如线程事件，锁事件以及Java虚拟机内部的时间，如新建对象，垃圾回收和即时编译事件</li>
<li>按照发生时机以及持续时间来划分，JFR的事件共有四种类型，它们分别为以下四种：<ul>
<li>瞬时事件（Instant Event），用户关系的是他们发生与否，例如异常，线程启动事件</li>
<li>持续事件（Duration Event）,用户关心的是他们的持续时间，例如垃圾回收时间</li>
<li>计时事件（Timed Event），是时长超过指定阈值的持续事件</li>
<li>取样事件（Sample Event）,是周期性取样的事件</li>
</ul>
</li>
<li>取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时间统计各个线程的栈轨迹，如果在这些抽样去的的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法。</li>
</ul>
</li>
<li><p><strong>启动方式：</strong></p>
<ul>
<li><p>方式一：使用-XX:StartFilghtRecording=参数</p>
<blockquote>
<p>第一种是在运行目标Java程序时添加-XX:StartFlightRecording=参数</p>
<p>比如：下面命令中，JFR将会在Java虚拟机启动5s后（对应delay=5s）收集数据，持续20s（对应duration=20s），当收集完毕后，JFR会将收集得到的数据保存至指定的文件中（对应filename=myrecording.jfr）</p>
<p>java -XX:StartFlightRecording=delay=5s,duration=20s,filename=myrecording,jfr，settings=profile MyApp</p>
<p>由于JFR将持续收集数据，如果不加以限制，那么JFR可能会填满硬盘的所有空间，因此，我们有必要对这种模式下所收集的数据进行限制</p>
<p>比如：</p>
<p>java -XX:StartFlightRecording=maxage=10m,maxsize=100m,name=SomeLabel MyApp</p>
</blockquote>
</li>
<li><p>方式二：使用jcmd的JFR.*子命令</p>
<blockquote>
<p>通过jcmd来让JFR开始收集数据，停止收集数据，或者保存所收集的数据，对应的子命令分贝为JFR.START，JFR.stop，以及JFR.dump</p>
<p>$ jcm <PID> JFR.start settings=profile maxage=10m maxsize=150m name=SomeLabel</PID></p>
<p>上述命令运行过后，目标进程中的JFR已经开始收集数据，此时，我们可以通过下述命令来导出已经收集到的数据：</p>
<p>$ jcmd <PID> JFR.dump name=SomeLabel filename=myrecording.jfr</PID></p>
<p>最后，我们可以通过下述命令关闭目标进程中的JFR：</p>
<p>$ jcmd <PID> JFR.stop name=SomeLabel</PID></p>
</blockquote>
</li>
<li><p>方式三：JMC的JFR插件</p>
<p><img src="/2021/04/05/jvm/218.png" alt="image-20210713001505810"></p>
</li>
</ul>
</li>
<li><p><strong>Java Flight Recorder取样分析：</strong></p>
<blockquote>
<p>要采用取样，必须先添加参数：</p>
<p>-XX:+UnlockCommercialFeatures</p>
<p>-XX:+FlightRecorder</p>
<p>否则：</p>
<p><img src="/2021/04/05/jvm/216.png" alt="image-20210712235445893"></p>
<p>取样时间默认1分钟，可自行按需调整，事件设置选为profiler，然后可以设置取样profiler那些信息，比如：</p>
<ul>
<li><p>加上对象数量的统计：Java Virtual Machine——》GC——》Detailed ——》 Object Count/OBject Count after GC</p>
</li>
<li><p>方法调用采样的间隔从10ms改为1ms（但不能低于1ms，否则会影响性能了）：Java Sampling Information</p>
</li>
<li><p>Socket与File采样，10ms太久，但即使改为1ms也未必能抓住什么，可以干脆取消掉：Java Application——》File Read/FilerWrite/Socket Read/Socket Write</p>
<p> <img src="/2021/04/05/jvm/jvm%5C217.png" alt="image-20210712235937585"></p>
<p>然后就开始profile，到时见后profile结束，会自动把记录下载回来，在JMC中展示</p>
<p><img src="/2021/04/05/jvm/219.png" alt="image-20210713001610448"></p>
<p>从展示信息中，我们大致可以读到内存和CPU信息，代码，线程和IO等比较重要的信息展示</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="10，其他工具"><a href="#10，其他工具" class="headerlink" title="10，其他工具"></a>10，其他工具</h4><h5 id="a，Flame-Graphs（火焰图）"><a href="#a，Flame-Graphs（火焰图）" class="headerlink" title="a，Flame Graphs（火焰图）"></a>a，Flame Graphs（火焰图）</h5><blockquote>
<p>在追求极致性能的场景下，了解你的程序运行过程中CPU在干什么很重要，火焰图就是一种非常直观的展示CPU在程序整个生命周期过程中时间分配的工具</p>
<p>火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用栈中的CPU消耗瓶颈</p>
<p>网上的关于Java火焰图的讲解大部分来自于Brendan Gregg的博客：</p>
<p><a href="http;//www.brendangregg.com/flamegraphs.html">Java火焰图</a></p>
<p><img src="/2021/04/05/jvm/220.png" alt="image-20210713002247792"></p>
<p>火焰图，简单通过x轴横条宽度来度量时间指标，y轴代表线程栈的层次</p>
</blockquote>
<h5 id="b，Tprofiler"><a href="#b，Tprofiler" class="headerlink" title="b，Tprofiler"></a>b，Tprofiler</h5><blockquote>
<p>案例：</p>
<p>使用JDK自身提供的工具进行JVM调优可以将TPS由2.5提升到20（提升了7倍），并准确定位系统瓶颈</p>
<p>系统瓶颈有：应用里静态对象不是太多，有大量的业务线程在频繁创建一些生命周期很长的临时对象，代码里有问题</p>
<p>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具TProfiler来定位这些性能代码，成功解决掉了GC过于频繁的性能瓶颈，并最终在上次优化的基础上将TPS再提升了4倍，即提升到100</p>
<ul>
<li>TProfiler配置部署，远程操作，日志阅读都不太复杂，操作还是很简单的，但是其却是能够起到一针见血，立竿见影的效果，帮我们解决了GC过于频繁的性能瓶颈</li>
<li>TProfiler最重要的特性就是能够统计出你指定时间内JVM的top method，这些top method极有可能就是造成你JVM性能瓶颈的元凶，这是其他大多数JVM调优工具所不具备的，包括JRockit Mission Control。JRokit首席开发者Marcus Hirt在其私人博客《Low Overhead Method Profiling with Java Mission Control》下的评论中曾明确指明JRMC并不支持TOP方法的统计</li>
<li>TProfiler的下载：<a href="https://github.com/alibaba/TProfiler" target="_blank" rel="noopener">https://github.com/alibaba/TProfiler</a></li>
</ul>
</blockquote>
<h5 id="c，Btrace"><a href="#c，Btrace" class="headerlink" title="c，Btrace"></a>c，Btrace</h5><blockquote>
<p>Java运行时追踪工具</p>
<p>常见的动态追踪工具有BTrace,HouseMD（该项目已经停止开发），Greys-Anatomy（国人开发，个人开发者），Byteman（JBoss出品），注意Java运行时追踪工具并不限于这几种，但是这几个是相对比较常见的</p>
<p>BTrace是SUN Kenai云计算开发平台下的一个开源项目，旨在为Java提供安全可靠的动态跟踪分析工具，先看一下BTrace的官方定义：</p>
<p>Java平台的安全的动态追踪工具，可以用来动态地追踪一个运行的Java程序BTrace动态调整目标应用程序的类以注入跟踪代码（“字节码跟踪”）</p>
</blockquote>
<h5 id="d，YourKit"><a href="#d，YourKit" class="headerlink" title="d，YourKit"></a>d，YourKit</h5><h5 id="e，JProde"><a href="#e，JProde" class="headerlink" title="e，JProde"></a>e，JProde</h5><h5 id="f，Spring-Insight"><a href="#f，Spring-Insight" class="headerlink" title="f，Spring Insight"></a>f，Spring Insight</h5><h3 id="四，JVM运行时命令"><a href="#四，JVM运行时命令" class="headerlink" title="四，JVM运行时命令"></a>四，JVM运行时命令</h3><h4 id="1，JVM参数选项"><a href="#1，JVM参数选项" class="headerlink" title="1，JVM参数选项"></a>1，JVM参数选项</h4><h5 id="a，类型一：标准参数选项"><a href="#a，类型一：标准参数选项" class="headerlink" title="a，类型一：标准参数选项"></a>a，类型一：标准参数选项</h5><ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>比较稳定，后续版本基本不会变化</li>
<li>以<code>-</code> 开头</li>
</ul>
</li>
<li><p><strong>各种选项</strong>：运行java或者java -help可以看到所有的标准选项</p>
<blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-d32</span>          使用 32 位数据模型 (如果可用)</span><br><span class="line"><span class="selector-tag">-d64</span>          使用 64 位数据模型 (如果可用)</span><br><span class="line"><span class="selector-tag">-server</span>       选择 "<span class="selector-tag">server</span>" <span class="selector-tag">VM</span></span><br><span class="line">              默认 <span class="selector-tag">VM</span> 是 <span class="selector-tag">server</span>.</span><br><span class="line"></span><br><span class="line">-cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">-classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">              用 ; 分隔的目录, <span class="selector-tag">JAR</span> 档案</span><br><span class="line">              和 <span class="selector-tag">ZIP</span> 档案列表, 用于搜索类文件。</span><br><span class="line">-D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line">              设置系统属性</span><br><span class="line"><span class="selector-tag">-verbose</span>:<span class="selector-attr">[class|gc|jni]</span></span><br><span class="line">              启用详细输出</span><br><span class="line"><span class="selector-tag">-version</span>      输出产品版本并退出</span><br><span class="line"><span class="selector-tag">-version</span>:&lt;值&gt;</span><br><span class="line">              警告: 此功能已过时, 将在</span><br><span class="line">              未来发行版中删除。</span><br><span class="line">              需要指定的版本才能运行</span><br><span class="line"><span class="selector-tag">-showversion</span>  输出产品版本并继续</span><br><span class="line">-jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">              警告: 此功能已过时, 将在</span><br><span class="line">              未来发行版中删除。</span><br><span class="line">              在版本搜索中包括/排除用户专用 JRE</span><br><span class="line"><span class="selector-tag">-</span>? <span class="selector-tag">-help</span>      输出此帮助消息</span><br><span class="line"><span class="selector-tag">-X</span>            输出非标准选项的帮助</span><br><span class="line"><span class="selector-tag">-ea</span><span class="selector-attr">[:&lt;packagename&gt;...|:&lt;classname&gt;]</span></span><br><span class="line"><span class="selector-tag">-enableassertions</span><span class="selector-attr">[:&lt;packagename&gt;...|:&lt;classname&gt;]</span></span><br><span class="line">              按指定的粒度启用断言</span><br><span class="line"><span class="selector-tag">-da</span><span class="selector-attr">[:&lt;packagename&gt;...|:&lt;classname&gt;]</span></span><br><span class="line"><span class="selector-tag">-disableassertions</span><span class="selector-attr">[:&lt;packagename&gt;...|:&lt;classname&gt;]</span></span><br><span class="line">              禁用具有指定粒度的断言</span><br><span class="line">-esa | -enablesystemassertions</span><br><span class="line">              启用系统断言</span><br><span class="line">-dsa | -disablesystemassertions</span><br><span class="line">              禁用系统断言</span><br><span class="line"><span class="selector-tag">-agentlib</span>:&lt;<span class="selector-tag">libname</span>&gt;<span class="selector-attr">[=&lt;选项&gt;]</span></span><br><span class="line">              加载本机代理库 &lt;<span class="selector-tag">libname</span>&gt;, 例如 <span class="selector-tag">-agentlib</span><span class="selector-pseudo">:hprof</span></span><br><span class="line">              另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help</span><br><span class="line"><span class="selector-tag">-agentpath</span>:&lt;<span class="selector-tag">pathname</span>&gt;<span class="selector-attr">[=&lt;选项&gt;]</span></span><br><span class="line">              按完整路径名加载本机代理库</span><br><span class="line"><span class="selector-tag">-javaagent</span>:&lt;<span class="selector-tag">jarpath</span>&gt;<span class="selector-attr">[=&lt;选项&gt;]</span></span><br><span class="line">              加载 <span class="selector-tag">Java</span> 编程语言代理, 请参阅 <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.instrument</span></span><br><span class="line"><span class="selector-tag">-splash</span>:&lt;<span class="selector-tag">imagepath</span>&gt;</span><br><span class="line">              使用指定的图像显示启动屏幕</span><br><span class="line">有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>补充内容</strong>：-server与-client</p>
<blockquote>
<p>Hotspot JVM有两种模式，分别是server和client，分别通过-server和-client模式设置：</p>
<ul>
<li>在32位Windows系统上，默认使用client类型的JVM，要想使用server模式，则机器配置至少有2个以上的CPU和2G以上的物理内存，client模式适用于对内存要求较小的桌面应用程序，默认使用serial串行垃圾收集器</li>
<li>64位机器上只支持server模式的JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器</li>
</ul>
<p>对于以上第2点，我们可以打开DOS窗口，输入java -version就可以看到64位机器上用的server模式，如下所示：</p>
<p><img src="/2021/04/05/jvm/221.png" alt="image-20210713005729459"></p>
</blockquote>
</li>
</ul>
<h5 id="b，类型二：-X参数选项"><a href="#b，类型二：-X参数选项" class="headerlink" title="b，类型二：-X参数选项"></a>b，类型二：-X参数选项</h5><ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>非标准化参数</li>
<li>功能还是比较稳定的，但官方说后续版本可能会变更</li>
<li>以 <code>-X</code> 开头</li>
</ul>
</li>
<li><p><strong>各种选项</strong>：运行java -X命令可以看到所有的X选项</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-Xmixed</span>           混合模式执行（默认）</span><br><span class="line"><span class="selector-tag">-Xint</span>             仅解释模式执行</span><br><span class="line">-Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                  设置引导类和资源的搜索路径</span><br><span class="line">-Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                  附加在引导类路径末尾</span><br><span class="line">-Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                  置于引导类路径之前</span><br><span class="line"><span class="selector-tag">-Xdiag</span>            显示附加诊断消息</span><br><span class="line"><span class="selector-tag">-Xnoclassgc</span>        禁用类垃圾收集</span><br><span class="line"><span class="selector-tag">-Xincgc</span>           启用增量垃圾收集</span><br><span class="line"><span class="selector-tag">-Xloggc</span>:&lt;<span class="selector-tag">file</span>&gt;    将 <span class="selector-tag">GC</span> 状态记录在文件中（带时间戳）</span><br><span class="line"><span class="selector-tag">-Xbatch</span>           禁用后台编译</span><br><span class="line"><span class="selector-tag">-Xms</span>&lt;<span class="selector-tag">size</span>&gt;        设置初始 <span class="selector-tag">Java</span> 堆大小</span><br><span class="line"><span class="selector-tag">-Xmx</span>&lt;<span class="selector-tag">size</span>&gt;        设置最大 <span class="selector-tag">Java</span> 堆大小</span><br><span class="line"><span class="selector-tag">-Xss</span>&lt;<span class="selector-tag">size</span>&gt;        设置 <span class="selector-tag">Java</span> 线程堆栈大小</span><br><span class="line"><span class="selector-tag">-Xprof</span>            输出 <span class="selector-tag">cpu</span> 分析数据</span><br><span class="line"><span class="selector-tag">-Xfuture</span>          启用最严格的检查，预计会成为将来的默认值</span><br><span class="line">-Xrs              减少 Java/VM 对操作系统信号的使用（请参阅文档）</span><br><span class="line"><span class="selector-tag">-Xcheck</span><span class="selector-pseudo">:jni</span>       对 <span class="selector-tag">JNI</span> 函数执行其他检查</span><br><span class="line"><span class="selector-tag">-Xshare</span><span class="selector-pseudo">:off</span>       不尝试使用共享类数据</span><br><span class="line"><span class="selector-tag">-Xshare</span><span class="selector-pseudo">:auto</span>      在可能的情况下使用共享类数据（默认）</span><br><span class="line"><span class="selector-tag">-Xshare</span><span class="selector-pseudo">:on</span>        要求使用共享类数据，否则将失败。</span><br><span class="line"><span class="selector-tag">-XshowSettings</span>    显示所有设置并继续</span><br><span class="line"><span class="selector-tag">-XshowSettings</span><span class="selector-pseudo">:system</span></span><br><span class="line">                  （仅限 <span class="selector-tag">Linux</span>）显示系统或容器</span><br><span class="line">                  配置并继续</span><br><span class="line"><span class="selector-tag">-XshowSettings</span><span class="selector-pseudo">:all</span></span><br><span class="line">                  显示所有设置并继续</span><br><span class="line"><span class="selector-tag">-XshowSettings</span><span class="selector-pseudo">:vm</span> 显示所有与 <span class="selector-tag">vm</span> 相关的设置并继续</span><br><span class="line"><span class="selector-tag">-XshowSettings</span><span class="selector-pseudo">:properties</span></span><br><span class="line">                  显示所有属性设置并继续</span><br><span class="line"><span class="selector-tag">-XshowSettings</span><span class="selector-pseudo">:locale</span></span><br><span class="line">                  显示所有与区域设置相关的设置并继续</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>JVM的JIT编译模式相关的选项</strong></p>
<ul>
<li><code>-Xint</code>：禁用JIT，所有字节码都被解释执行，这个模式的速度最慢的</li>
<li><code>-Xcomp</code>：所有字节码第一次使用就都被编译成本地代码，然后再执行</li>
<li><code>-Xmixed</code>：混合模式，默认模式，刚开始的时候使用解释器慢慢解释执行，后来让JIT即时编译器根据程序运行的情况，有选择地将某些热点代码提前编译并缓存在本地，在执行的时候效率就非常高了</li>
</ul>
</li>
<li><p><strong>特别地</strong>：</p>
<ul>
<li><code>-Xmx -Xms -Xss属于XX参数？</code>单位：k/K，m/M，g/G<ul>
<li><code>-Xms&lt;size&gt;</code>：设置初始Java堆大小，等价于<code>-XX:InitialHeapSize</code><ul>
<li>查看该参数值的时候，应该使用InitialHeapSize，例如：<code>jinfo flag InitialHeapSize 进程id</code></li>
</ul>
</li>
<li><code>-Xmx&lt;size&gt;</code>：设置最大Java堆大小，等价于<code>-XX:MaxHeapSize</code><ul>
<li>查看该参数值的时候，应该使用MaxHeapSize，例如：<code>jinfo flag MaxHeapSize 进程id</code></li>
</ul>
</li>
<li><code>-Xss</code>：设置Java线程堆栈大小，等价于<code>-XX：ThreadStackSize</code><ul>
<li>查看该参数值的时候，应该使用ThreadStackSize，例如：<code>jinfo flag ThreadStackSize 进程id</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="c，类型三：-XX参数选项"><a href="#c，类型三：-XX参数选项" class="headerlink" title="c，类型三：-XX参数选项"></a>c，类型三：-XX参数选项</h5><ul>
<li><p>特点：</p>
<ul>
<li>非标准化参数</li>
<li>使用的最多的参数类型</li>
<li>这类选项属于实验性，不稳定</li>
<li>以 <code>-XX</code> 开头</li>
</ul>
</li>
<li><p>作用：</p>
<ul>
<li>用于开发和调试JVM</li>
</ul>
</li>
<li><p>分类：</p>
<ul>
<li><p>Boolean类型格式</p>
<ul>
<li><code>-XX:+&lt;option&gt;</code>：表示启用option属性</li>
<li><code>-XX:-&lt;option&gt;</code>：表示禁用option属性</li>
<li>举例：<ul>
<li><code>-XX:+UseParallelGC</code>：选择垃圾收集器为并行收集器</li>
<li><code>-XX:+UseG1GC</code>：表示启用G1收集器</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：自动选择年轻代大小和相应的Survivor区比例</li>
</ul>
</li>
<li>说明：因为有的指令默认是开启的，所以可以使用<code>-</code>关闭</li>
</ul>
</li>
<li><p>非Boolean类型格式（key-value类型）</p>
<blockquote>
<p>number表示数值，number可以带上单位，比如：’m’，’M’表示兆，’k’，’K’表示Kb，’g’，‘G’表示g（例如32k跟32768是一样的效果）</p>
</blockquote>
<ul>
<li>子类型1：数值型格式：<code>-XX:&lt;option&gt;=&lt;number&gt;</code><ul>
<li><code>-XX:NewSize=1024m</code>：表示设置新生代初始大小为1024兆</li>
<li><code>-XX:MaxGCPauseMillis=500</code>：表示设置GC停顿时间：500毫秒</li>
<li><code>-XX:GCTimeRatio=19</code>“”：表示设置吞吐量</li>
<li><code>-XX:NewRatio=2</code>：表示新生代与老年代的比例</li>
</ul>
</li>
<li>子类型2：非数值型格式：<code>-XX:&lt;name&gt;=&lt;string&gt;</code><ul>
<li><code>-XX:HeapDumpPath=/usr/local/heapdump.hprof</code>：用来指定heap转存文件的存储路径</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特别地：</p>
<ul>
<li><p><code>-XX:+PrintFlagsFinal</code></p>
<ul>
<li>输出所有参数的名称和默认值</li>
<li>默认不包括Diagnostic和Experimental的参数</li>
<li>可以配合：<code>-XX:+UnlockDiagnosticVMOption</code>和<code>-XX:UnlockExperimentalVMOption</code>使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2，添加JVM参数选项"><a href="#2，添加JVM参数选项" class="headerlink" title="2，添加JVM参数选项"></a>2，添加JVM参数选项</h4><h5 id="a，Eclipse"><a href="#a，Eclipse" class="headerlink" title="a，Eclipse"></a>a，Eclipse</h5><h5 id="b，IDEA"><a href="#b，IDEA" class="headerlink" title="b，IDEA"></a>b，IDEA</h5><h5 id="c，运行jar包"><a href="#c，运行jar包" class="headerlink" title="c，运行jar包"></a>c，运行jar包</h5><ul>
<li><code>java -Xms50m -Xmx50m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -jar demo.jar</code>：这是在java -jar demo.jar中的java -jar之间添加了虚拟机配置信息</li>
</ul>
<h5 id="d，通过Tomcat运行war包"><a href="#d，通过Tomcat运行war包" class="headerlink" title="d，通过Tomcat运行war包"></a>d，通过Tomcat运行war包</h5><ul>
<li>Linux系统下可以在tomcat/bin/catalina.sh中添加类似如下配置：<code>JAVA_OPTS=&quot;-Xms512M -Xmx1024M&quot;</code></li>
<li>Windows系统下在catalina.bat中添加类似如下配置：<code>set &quot;JAVA_OPTS=-Xms512M -Xmx1024M&quot;</code></li>
</ul>
<h5 id="e，程序运行过程中"><a href="#e，程序运行过程中" class="headerlink" title="e，程序运行过程中"></a>e，程序运行过程中</h5><ul>
<li>使用<code>jinfo -flag&lt;name&gt;=&lt;value&gt; &lt;pid&gt;</code>设置非Boolean类型参数</li>
<li>使用<code>jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;</code>设置Boolean类型参数</li>
</ul>
<h4 id="3，常用的JVM参数选项"><a href="#3，常用的JVM参数选项" class="headerlink" title="3，常用的JVM参数选项"></a>3，常用的JVM参数选项</h4><h5 id="a，打印设置的XX选项及值"><a href="#a，打印设置的XX选项及值" class="headerlink" title="a，打印设置的XX选项及值"></a>a，打印设置的XX选项及值</h5><ul>
<li><code>-XX:+PrintCommandLineFlags</code>：可以让在程序运行前打印出用户手动设置或者JVM自动设置的XX选项</li>
<li><code>-XX:+PrintFlagsInitial</code>：表示打印出所有XX选项的默认值</li>
<li><code>-XX:+PrintFlagsFinal</code>：表示打印出XX选项在运行程序时生效的值</li>
<li><code>-XX:+PrintVMOptions</code>：打印JVM的参数</li>
</ul>
<h5 id="b，堆，栈，方法区等内存大小设置"><a href="#b，堆，栈，方法区等内存大小设置" class="headerlink" title="b，堆，栈，方法区等内存大小设置"></a>b，堆，栈，方法区等内存大小设置</h5><ul>
<li><strong>堆</strong>：<ul>
<li><code>-Xss128k</code>：等价于<code>-XX:ThreadStackSize=128k</code>，设置每个线程的栈大小为128k</li>
</ul>
</li>
<li><strong>堆内存</strong>：<ul>
<li><code>-Xms3550m</code>：等价于<code>-XX:InitialHeapSize</code>，设置JVM初始堆内存为3550M</li>
<li><code>-Xmx3550m</code>：等价于<code>-XX:MaxHeapSize</code>，设置JVM最大堆内存为3550M</li>
<li><code>-Xmn2g</code>：设置年轻代大小为2G，官方推荐配置为整个堆大小为3/8</li>
<li><code>-XX:NewSize=1024m</code>：设置年轻代初始值为1024M</li>
<li><code>-XX:MaxNewSize=1024m</code>：设置年轻代最大值为1024M</li>
<li><code>-XX:SurvivorRatio=8</code>：设置年轻代中Eden区与一个Survivor区的比值，默认为8</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：自动选择各区大小比例</li>
<li><code>-XX:NewRatio=4</code>：设置老年代与年轻代（包括1个Eden和2个Survivor区）比值</li>
<li><code>-XX:PretenureSizeThreadshold=1024</code>：设置让大于此阈值的对象直接分配在老年代，单位为字节，只对Serial，ParNew收集器有效</li>
<li><code>-XX:MaxTenuringThreadshold=15</code>：默认值为15，新生代每次MinorGC后，还存活的对象年龄+1，当对象的年龄大于设置的这个值时就进入老年代</li>
<li><code>-XX:+PrintTenuringDistribution</code>：让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布</li>
<li><code>-XX:TargetSurvivorRatio</code>：表示MinorGC结束后Survivor区域中占用空间的期望比例</li>
</ul>
</li>
<li><strong>方法区</strong>：<ul>
<li><strong>永久代</strong>：<ul>
<li><code>-XX:PermSize=256m</code>：设置永久代初始值为256M</li>
<li><code>-XX:MaxPermSize=256m</code>：设置永久代最大值为256M</li>
</ul>
</li>
<li><strong>元空间</strong>：<ul>
<li><code>-XX:MetaspaceSize</code>：初始空间大小</li>
<li><code>-XX:MaxMetaspaceSize</code>：最大空间，默认没有限制</li>
<li><code>-XX:+UseCompressedOops</code>：压缩对象指针</li>
<li><code>-XX:+UseCompressedClassPointers</code>：压缩类指针</li>
<li><code>-XX:CompressedClassSpaceSize</code>：设置Klass Metaspace的大小，默认为1G</li>
</ul>
</li>
<li><strong>直接内存</strong>：<ul>
<li><code>-XX:MaxDirectMemorySize</code>：指定DirectMemory容量，若未指定，则默认与Java堆最大值一样</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="c，OutOfMemory相关的选项"><a href="#c，OutOfMemory相关的选项" class="headerlink" title="c，OutOfMemory相关的选项"></a>c，OutOfMemory相关的选项</h5><ul>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：表示在内存出现OOM的时候，把Heap转存为dump文件以便后续分析</li>
<li><code>-XX:+HeapDumpBeforeFullGC</code>：表示在出现FullGC之前，生成Heap转储文件</li>
<li><code>-XX:HeapDumpPath=&lt;path&gt;</code>：指定heap转存文件的存储路径</li>
<li><code>-XX:OnOutOfMemoryError</code>：指定一个可执行程序或者脚本的路径，当发生OOM的时候，去执行这个脚本</li>
</ul>
<h5 id="d，垃圾收集器相关选项"><a href="#d，垃圾收集器相关选项" class="headerlink" title="d，垃圾收集器相关选项"></a>d，垃圾收集器相关选项</h5><blockquote>
<p><img src="/2021/04/05/jvm/222.png" alt="image-20210715002526704"></p>
<p><img src="/2021/04/05/jvm/223.png" alt="image-20210715002611874"></p>
</blockquote>
<ul>
<li><p><strong>查看默认垃圾收集器</strong></p>
<ul>
<li><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</li>
<li>使用命令行指令：<code>jinfo -flag 相关垃圾回收参数 进程ID</code></li>
</ul>
</li>
<li><p><strong>Serial回收器</strong></p>
<blockquote>
<p>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器，Serial Old是运行在Client模式下默认的老年代的垃圾回收器</p>
</blockquote>
<ul>
<li><code>-XX:+UseSerialGC</code>：指定年轻代和老年代都使用串行收集器，等价于新生代用Serial GC，且老年代用Serial OLd GC,可以获得最高的单线程收集效率</li>
</ul>
</li>
<li><p><strong>ParNew回收器</strong></p>
<ul>
<li><code>-XX:+UseParNewGC</code>：手动指定使用ParNew收集器执行内存回收任务，它表示年轻代使用并行收集器，不影响老年代</li>
<li><code>-XX:ParallelGCThreads=N</code>：限制线程数量，默认开启和CPU数据相同的线程数</li>
</ul>
</li>
<li><p><strong>Parallel回收器</strong></p>
<ul>
<li><code>-XX:+UseParallelGC</code>：手动指定年轻代使用Parallel并行收集器执行内存回收任务</li>
<li><code>-XX:+UseParallelOldGC</code>：手动指定老年代都是使用并行回收收集器<ul>
<li>分别适用于新生代和老年代，默认JDK8开启的</li>
<li>上面两个参数，默认开启一个，另一个也会被开启（相互激活）</li>
</ul>
</li>
<li><code>-XX:ParallelGCThreads</code>：设置年轻代并行收集器的线程数，一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能<ul>
<li>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量</li>
<li>当CPU数量大于8个，ParallelGCThreads的值等于<code>3+[5*CPU_Count]/8]</code></li>
</ul>
</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒<ul>
<li>为了尽可能地把停顿时间控制在MaxPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些 参数</li>
<li>对于用户来讲，停顿时间越短体验越好，但是在服务端，我们注重高并发，整体的吞吐量，所以服务端适合Parallel，进行控制</li>
<li>该参数使用需要谨慎</li>
</ul>
</li>
<li><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例（=1/(N+1））。用于衡量吞吐量的大小。<ul>
<li>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1%</li>
<li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性，暂停时间越长，Radio参数就容易超过设定的比例</li>
</ul>
</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong><ul>
<li>在这种模式下，年轻代的大小，Eden和Survivor的比例，晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小，吞吐量和停顿时间之间的平衡点</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆，目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>CMS回收器</strong></p>
<ul>
<li><code>-XX:+UseConcMarkSweepGC</code>：手动指定使用CMS收集器执行内存回收任务<ul>
<li>开启该参数后会自动将<code>-XX:+UseParNewGC</code>打开，即：<code>ParNew(Young区用)+CMS(old区用)+Serial Old</code>的组合</li>
</ul>
</li>
<li><code>-XX:CMSInitiatingOccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收<ul>
<li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。<strong>JDK6及以上版本默认值为92%</strong></li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能，反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器，因此<strong>通过该选项便可以有效减低Full GC的执行次数</strong></li>
</ul>
</li>
<li><code>-XX:UseCMSCompactAtFullCollection</code>：用于指定在执行完FullGC后对内存空间进行压缩整理，以此避免内存碎片的产生，不过由于内存压缩整理过程无法并发执行，所带来的的问题就是停顿时间变得更长了</li>
<li><code>-XX:CMSFullGCsBeforeCompaction</code>：设置在执行多少次FullGC后对内存空间进行压缩整理</li>
<li><code>-XX:ParallelCMSThreads</code>：设置CMS的线程数量<ul>
<li>CMS默认启动的线程数是（ParallelGCThreads + 3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕</li>
</ul>
</li>
<li><strong>补充参数</strong>：<ul>
<li><code>-XX:ConcGCThreads</code>：设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的</li>
<li><code>-XX:+UseCMSInitiatingOccupancyOnly</code>：是否动态可调，用这个参数可以使CNS一直按CMSInitiatingOccupancyFraction设定的值启动</li>
<li><code>-XX:+CMSScavengeBeforeRemark</code>：强制hotspot虚拟机在cms remark 阶段之前做一次minorgc，用于提高remark阶段的速度</li>
<li><code>-XX:+CMSClassUnloadingEnable</code>：如果有的话，启用回收Perm区（JDK8之前）</li>
<li><code>-XX:+CMSParallelInitialEnabled</code>：用于开启CMS initial-mark阶段采用多线程的方式进行标记，用于提高标记速度，在Java8开始已经默认开启</li>
<li><code>-XX:+CMSParallelRemarkEnabled</code>：用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启</li>
<li><code>-XX:+ExplicitGCInvokesConcurrent,-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code>：这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期</li>
<li><code>-XX:+CMSPrecleaningEnabled</code>：指定CMS是否需要进行Pre cleaning这个阶段</li>
</ul>
</li>
<li><strong>特别说明</strong>：<ul>
<li>JDK9新特性：CMS被标记为Deprecate了（JEP291）<ul>
<li>如果对JDK9及以上版本的HotSpot虚拟机使用参数<code>-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃</li>
</ul>
</li>
<li>JDK14新特性：删除CMS垃圾回收器（JEP363）<ul>
<li>移除了CMS垃圾收集器，如果在JDK14中使用<code>-XX:+UseConcMarkSweepGC</code>的话，JVM不会报错，只是给出一个warning信息，但是不会exit，JVM会自动回退以默认GC方式启动JVM</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>G1回收器</strong></p>
<ul>
<li><code>-XX:+UseG1GC</code>：手动指定使用G1收集器执行内存回收任务</li>
<li><code>-XX:G1HeapRegionSize</code>：设置每个Region的大小，值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域，默认值堆内存的1/200</li>
<li><code>-xx:MaxGCPauseMillis</code>：设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到），默认值是200ns</li>
<li><code>-XX:ParallelGCThread</code>：设置STW时GC线程数的值，最多设置为8</li>
<li><code>-XX:ConcGCThreads</code>：设置并发标记的线程数，将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置触发并发GC周期的Java堆占用率阈值，超过此值，就触发GC，默认值是45</li>
<li><code>-XX:G1NewSizePercent，-XX:G1MaxNewSizePercent</code>：新生代占用整个堆内存的最小百分比（默认5%），最大百分比（默认60%）</li>
<li><code>-XX:G1ReservePercent=10</code>：保留内存区域，防止to space（Survivor中的to区）溢出</li>
<li><strong>注意</strong>：G1收集器主要涉及到MixedGC，MixedGC会回收young区和部分old区</li>
<li><strong>G1关于MixedGC调优常用参数</strong>：<ul>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置堆占用率的百分比（0到100）达到这个数值的时候触发global concurrent marking（全局并发标记），默认为45%，值为0表示间断进行全局并发标记</li>
<li><code>-XX:G1MixedGCLiveThresholdPercent</code>：设置Old区的region被回收时候的对象占比，默认占用率为85%，只有Old区的region中存活的对象占用达到了这个百分比，才会在Mixed GC中被回收</li>
<li><code>-XX:G1HeapWastePercent</code>：在global concurrent marking（全局并发标记）结束之后，可以知道所有的区有多少空间要被回收，在每次young GC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生MixedGC</li>
<li><code>-XX:G1MixedGCCountTarget</code>：一次global concurrent marking（全局并发标记）之后，最多执行Mixed GC的次数，默认是8</li>
<li><code>-XX:G1OldCSetRegionThresholdPercent</code>：设置Mixed GC收集周期中要收集的Old region数的上限，默认值是Java堆的10%</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>怎么选择垃圾回收器？</strong></p>
<ul>
<li>优先调整堆的大小让JVM自适应完成</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核，单机程序，并且没有停顿时间的要求，串行收集器</li>
<li>如果是多CPU，需要高吞吐量，允许停顿时间超过1秒，选择并行或者JVM自己选择</li>
<li>如果是多CPU，追求低停顿时间，需要快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器，官方推荐G1，性能高。现在互联网的项目，基本都是使用G1</li>
<li>特别说明：<ul>
<li>没有最好的收集器，更没有万能的收集器</li>
<li>调优永远是针对特定场景，特定需求，不存在一劳永逸的收集器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="e，GC日志相关选项"><a href="#e，GC日志相关选项" class="headerlink" title="e，GC日志相关选项"></a>e，GC日志相关选项</h5><ul>
<li>常用参数<ul>
<li><code>-verbose:gc</code>：输出gc日志信息，默认输出到标准输出；可以独立使用</li>
<li><code>-XX:+PrintGC</code>：等同于<code>-verbose:gc</code>表示打开简化的GC日志；可以独立使用</li>
<li><code>-XX:+PrintGCDetails</code>：在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况；可以独立使用</li>
<li><code>-XX:+PrintGCTimeStamps</code>：输出GC发生时的时候戳；不可以独立使用，需要配合<code>-XX:+PrintGCDetails</code>使用</li>
<li><code>-XX:+PrintGCDateStamps</code>：输出GC发生时的时间戳（以日期的形式，如2013-05-04T21:53:59.234+0800）；不可以独立使用，需要配合<code>-XX:+PrintGCDetails</code>使用</li>
<li><code>-XX:+PrintHeapAtGC</code>：每一次GC前和GC后，都打印堆信息；可以独立使用</li>
<li><code>-Xloggc:&lt;file&gt;</code>：把GC日志写入到一个文件中去，而不是打印到标准输出中</li>
</ul>
</li>
<li>其他参数：<ul>
<li><code>-XX:+TraceClassLoading</code>：监控类的加载</li>
<li><code>-XX:+PrintGCApplicationStoppedTime</code>：打印GC时线程的停顿时间</li>
<li><code>-XX:+PrintGCApplicaionConcurrentTime</code>：垃圾收集之前打印出应用未中断的执行时间</li>
<li><code>-XX:+PrintReferenceGC</code>：记录回收了多少种不同引用类型的引用</li>
<li><code>-XX:+PrintTenuringDistribution</code>：让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布</li>
<li><code>-XX:+UseGCLogFileRotation</code>：启用GC日志文件的自动转储</li>
<li><code>-XX:NumberOfGCLogFiles=1</code>：GC日志文件的循环数目</li>
<li><code>-XX:GCLogFileSize=1M</code>：控制GC日志文件的大小</li>
</ul>
</li>
</ul>
<h5 id="f，其他参数"><a href="#f，其他参数" class="headerlink" title="f，其他参数"></a>f，其他参数</h5><ul>
<li><code>-XX:+DisableExplicitGC</code>：禁止Hotspot执行System.gc()，默认禁用</li>
<li><code>-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]，-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]</code>：指定代码缓存大小</li>
<li><code>-XX:+UseCodeCacheFlushing</code>：使用该参数让jvm放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</li>
<li><code>-XX:DoEscapeAnalysis</code>：开启逃逸分析</li>
<li><code>-XX:+UseBiasedLocking</code>：开启偏向锁</li>
<li><code>-XX:+UseLargePages</code>：开启使用大页面</li>
<li><code>-XX:+UseTLAB</code>：使用TLAB,默认打开</li>
<li><code>-XX:PrintTLAB</code>：打印TLAB的使用情况</li>
<li><code>-XX:TLABSize</code>：设置TLAB大小</li>
</ul>
<h4 id="4，通过Java代码获取JVM参数"><a href="#4，通过Java代码获取JVM参数" class="headerlink" title="4，通过Java代码获取JVM参数"></a>4，通过Java代码获取JVM参数</h4><ul>
<li><blockquote>
<p>Java提供了java.lang.management包用于监视和管理Java虚拟机和Java运行时中的其他组件，他允许本地和远程监控和管理运行的Java虚拟机，其中ManagementFactory这个类还是挺常用的，另外还有Runtime类也可以获取一些内存，CPU核数等相关的数据</p>
<p>通过这些api可以监控我们的应用服务器的堆内存使用情况，设置一些阈值进行报警等处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 监控我们的应用服务器的堆内存使用情况，设置一些阈值进行报警等处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 15:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryMonitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MemoryMXBean memorymbean = ManagementFactory.getMemoryMXBean();</span><br><span class="line">        MemoryUsage usage = memorymbean.getHeapMemoryUsage();</span><br><span class="line">        System.out.println(<span class="string">"INIT HEAP: "</span> + usage.getInit() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"m"</span>);</span><br><span class="line">        System.out.println(<span class="string">"MAX HEAP: "</span> + usage.getMax() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"m"</span>);</span><br><span class="line">        System.out.println(<span class="string">"USE HEAP: "</span> + usage.getUsed() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"m"</span>);</span><br><span class="line">        System.out.println(<span class="string">"\nFull Information:"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Heap Memory Usage: "</span> + memorymbean.getHeapMemoryUsage());</span><br><span class="line">        System.out.println(<span class="string">"Non-Heap Memory Usage: "</span> + memorymbean.getNonHeapMemoryUsage());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"=======================通过java来获取相关系统状态============================ "</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前堆内存大小totalMemory "</span> + (<span class="keyword">int</span>) Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"m"</span>);<span class="comment">// 当前堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">"空闲堆内存大小freeMemory "</span> + (<span class="keyword">int</span>) Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"m"</span>);<span class="comment">// 空闲堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">"最大可用总堆内存maxMemory "</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"m"</span>);<span class="comment">// 最大可用总堆内存大小</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h3 id="五，分析GC日志"><a href="#五，分析GC日志" class="headerlink" title="五，分析GC日志"></a>五，分析GC日志</h3><h4 id="1，GC日志参数"><a href="#1，GC日志参数" class="headerlink" title="1，GC日志参数"></a>1，GC日志参数</h4><ul>
<li>常用参数<ul>
<li><code>-verbose:gc</code>：输出gc日志信息，默认输出到标准输出；可以独立使用</li>
<li><code>-XX:+PrintGC</code>：等同于<code>-verbose:gc</code>表示打开简化的GC日志；可以独立使用</li>
<li><code>-XX:+PrintGCDetails</code>：在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况；可以独立使用</li>
<li><code>-XX:+PrintGCTimeStamps</code>：输出GC发生时的时候戳；不可以独立使用，需要配合<code>-XX:+PrintGCDetails</code>使用</li>
<li><code>-XX:+PrintGCDateStamps</code>：输出GC发生时的时间戳（以日期的形式，如2013-05-04T21:53:59.234+0800）；不可以独立使用，需要配合<code>-XX:+PrintGCDetails</code>使用</li>
<li><code>-XX:+PrintHeapAtGC</code>：每一次GC前和GC后，都打印堆信息；可以独立使用</li>
<li><code>-Xloggc:&lt;file&gt;</code>：把GC日志写入到一个文件中去，而不是打印到标准输出中</li>
</ul>
</li>
<li>其他参数：<ul>
<li><code>-XX:+TraceClassLoading</code>：监控类的加载</li>
<li><code>-XX:+PrintGCApplicationStoppedTime</code>：打印GC时线程的停顿时间</li>
<li><code>-XX:+PrintGCApplicaionConcurrentTime</code>：垃圾收集之前打印出应用未中断的执行时间</li>
<li><code>-XX:+PrintReferenceGC</code>：记录回收了多少种不同引用类型的引用</li>
<li><code>-XX:+PrintTenuringDistribution</code>：让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布</li>
<li><code>-XX:+UseGCLogFileRotation</code>：启用GC日志文件的自动转储</li>
<li><code>-XX:NumberOfGCLogFiles=1</code>：GC日志文件的循环数目</li>
<li><code>-XX:GCLogFileSize=1M</code>：控制GC日志文件的大小</li>
</ul>
</li>
</ul>
<h4 id="2，GC日志格式"><a href="#2，GC日志格式" class="headerlink" title="2，GC日志格式"></a>2，GC日志格式</h4><h5 id="a，GC的分类"><a href="#a，GC的分类" class="headerlink" title="a，GC的分类"></a>a，GC的分类</h5><blockquote>
<p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p>
</blockquote>
<ul>
<li>部分收集：不是完整收集整个Java堆的垃圾收集，其中又分为：<ul>
<li>新生代收集（Minor GC/Young GC）：只是新生代（Eden/S0，S1）的垃圾收集</li>
<li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为</li>
<li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收</li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</li>
<li><strong>哪行情况会触发Full GC?</strong><ul>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>显示调用System.gc();</li>
<li>Minor GC进入老年代的数据平均大小 大于 老年代的可用内存</li>
</ul>
</li>
</ul>
<h5 id="b，GC日志的分类"><a href="#b，GC日志的分类" class="headerlink" title="b，GC日志的分类"></a>b，GC日志的分类</h5><p><strong>Monitor GC日志分析：</strong></p>
<p><img src="/2021/04/05/jvm/96.png" alt="image-20210424141119962"></p>
<p><strong>Full GC日志分析</strong>：</p>
<p><img src="/2021/04/05/jvm/97.png" alt="image-20210424141223770"></p>
<h5 id="c，GC日志结构剖析"><a href="#c，GC日志结构剖析" class="headerlink" title="c，GC日志结构剖析"></a>c，GC日志结构剖析</h5><ul>
<li><strong>垃圾收集器</strong>：<ul>
<li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是：“[DefNew”</li>
<li>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是“Parallel New Generation”</li>
<li>使用Parallel Scaverge收集器在新生代的名字是”[PSYoungGen”，这里的JDK1.7使用的就是PSYoungGen</li>
<li>使用Parallel Old Generation收集器在老年代的名字是”[ParOldGen”</li>
<li>使用G1收集器的话，会显示为“garbage-first heap”</li>
<li><strong>Allocation Failure</strong><ul>
<li>表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了</li>
</ul>
</li>
</ul>
</li>
<li><strong>GC前后情况</strong>：<ul>
<li>通过图示，我们可以发现GC日志格式的规律一般都是：GC前内存占用——》GC后内存占用（该区域内存总大小）<code>[PSYoungGen:5986K--&gt; 696K(8704K)]5986K--&gt;704(9216K)</code><ul>
<li>中括号内，GC回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</li>
<li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
</li>
</ul>
</li>
<li><strong>CPU时间</strong>：<ul>
<li>GC日志中有是哪个时间：user,sys和real<ul>
<li>user - 进程执行用户态代码（核心之外）所使用的时间，<strong>这是执行次进程所使用的实际CPU时间，</strong>其他进程和次进程阻塞的时间并不包括在内，在垃圾收集的情况下，表示GC线程执行所使用的CPU总时间</li>
<li>sys - 进程在内核态消耗的CPU时间，即<strong>在内核执行系统调用或等待系统时间所使用的CPU时间</strong></li>
<li>real - 程序从开始到结束所用的时钟时间，这个事件包括其他进程使用的时间片和进程阻塞的时间（比如等待I/O完成），对于并行GC，这个数字应该接近（用户时间+系统时间）除以垃圾收集器使用的线程数</li>
</ul>
</li>
<li>由于多核的原因，一般的GC时间中，real time是小于sys + user time的，因为一般是多个线程并发的去做GC，所以real time是要小于sys + user time的，如果real &gt; sys + user 的话，则你的应用可能存在下列问题：<ul>
<li>IO负载非常重</li>
<li>CPU不够用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="d，MinorGC日志解析"><a href="#d，MinorGC日志解析" class="headerlink" title="d，MinorGC日志解析"></a>d，MinorGC日志解析</h5><blockquote>
<p><code>2020-11-20T17:19:43.265-0800:0.822:[GC(ALLOCATION FAILURE)[PSYOUNGGEN:76800K--&gt;8433K(89600K)]76800K--&gt;844K(294400K),0.0088371 SECS][TIMES:USER=0.02 YSY=0.01,REAL=0.01 SECS]</code></p>
</blockquote>
<ul>
<li><code>2020-11-20T17:19:43.265-0800</code>：日志打印时间：由<code>-XX:+PrintGCDateStamps,-XX:+PrintGCDetails</code>配合打印出来</li>
<li><code>0.822</code>：gc发生时，Java虚拟机启动以来经过的秒数：由<code>-XX:+PrintGCTimeStamps,-XX:+PrintGCDetails</code>配合打印出来</li>
<li><code>[GC(ALLOCATION FAILURE)</code>：发生一次垃圾回收，这是一次Minor GC，它不区分新生代GC还是老年代GC，括号里的内容是gc发生的原因，这里Allocation Failure的原因是新生代中没有足够区域能够存放需要分配的数据而失败</li>
<li><code>[PSYoungGen:76800K-&gt;8433K(89600K)</code><ul>
<li><code>PYoungGen</code>：表示GC发生的区域，区域名称与使用的GC收集器是密切相关的<ul>
<li>Serial收集器：Default New Generation 显示DefNew</li>
<li>ParNew收集器：ParNew</li>
<li>Parallel Scanvenge收集器：PSYoung</li>
<li>老年代和新生代同理，也是和收集器名称相关</li>
</ul>
</li>
<li><code>76800K--&gt;8433K(89600k)</code>：GC前该内存区域已使用容量–&gt; GC后该区域容量（该区域总容量）<ul>
<li>如果是新生代，总容量则会显示整个新生代内存的9/10，即eden + from/to区</li>
<li>如果是老年代，总容量则是全部内存大小，无变化</li>
</ul>
</li>
</ul>
</li>
<li><code>76800K--&gt;8449K(294400K)</code>：在显示完区域容量GC的情况后，会接着显示整个堆内存区域的GC情况：GC前堆内存已使用容量–&gt;GC堆内存容量（堆内存容量）堆内存总容量=9/10新生代+老年代 &lt; 初始化的内存大小</li>
<li><code>.0.0088371 secs]</code>：整个GC所花费的时间，单位是秒</li>
<li><code>[Times:user=0.02 sys=0.01 real=0.01 sece]</code>：<ul>
<li>user：指的是CPU工作中在用户态所花费的时间</li>
<li>sys：指的是CPU工作在内核态所花费的时间</li>
<li>real：指的是在此次GC事件中所花费的总时间</li>
</ul>
</li>
</ul>
<h5 id="e，Full-GC日志解析："><a href="#e，Full-GC日志解析：" class="headerlink" title="e，Full GC日志解析："></a>e，Full GC日志解析：</h5><blockquote>
<p><code>2020-11-20T17:19:43.794-0800:1.351:[FULL GC(METADATA GC THRESHOLD)[PSYOUNGGEN:10082K--&gt;0K(89600K)][PAROLDGEN：32K--&gt;9638K(204800K)][METASPACE:20158K--&gt;20156K(1067008K)],0.0285388 SECS][TIMES:USER=0.11 SYS-0.00 REAL-0.03 SECS]</code></p>
</blockquote>
<ul>
<li><p><code>2020-11-20T17:19:43.794-0800</code>：日志打印时间：由<code>-XX:+PrintGCDateStamps,-XX:+PrintGCDetails</code>配合打印出来</p>
</li>
<li><p><code>1.351</code>：gc发生时，Java虚拟机启动以来经过的秒数：由<code>-XX:+PrintGCTimeStamps,-XX:+PrintGCDetails</code>配合打印出来</p>
</li>
<li><p><code>[FULL GC(METADATA GC THRESHOLD)</code>：</p>
<ul>
<li>发生了一次垃圾回收，这是一次FULL GC，它不区分新生代GC还是老年代GC</li>
<li>括号里面的内容是gc发生的原因，这里的Metadata GC Threshold的原因是Metaspace区不够用了<ul>
<li>Full GC（Ergonomics）：JVM自适应调整导致的GC</li>
<li>Full GC（System）：调用了System.gc()方法</li>
</ul>
</li>
</ul>
</li>
<li><p><code>[PSYoungGen:10082K--&gt;0K(89600K)</code></p>
<ul>
<li><code>PYoungGen</code>：表示GC发生的区域，区域名称与使用的GC收集器是密切相关的<ul>
<li>Serial收集器：Default New Generation 显示DefNew</li>
<li>ParNew收集器：ParNew</li>
<li>Parallel Scanvenge收集器：PSYoung</li>
<li>老年代和新生代同理，也是和收集器名称相关</li>
</ul>
</li>
<li><code>10082K--&gt;0K(89600K)</code>：GC前该内存区域已使用容量–&gt; GC后该区域容量（该区域总容量）<ul>
<li>如果是新生代，总容量则会显示整个新生代内存的9/10，即eden + from/to区</li>
<li>如果是老年代，总容量则是全部内存大小，无变化</li>
</ul>
</li>
</ul>
</li>
<li><p><code>[PAROLDGEN：32K--&gt;9638K(204800K)]</code>：老年代区域没有发生GC，因为本次GC是metaspace引起的</p>
</li>
<li><p><code>10114K--&gt;9638k(294400k)</code>：在显示完区域容量GC的情况后，会接着显示整个堆内存区域的GC情况：GC前堆内存已使用容量 –&gt;GC堆内存容量（堆内存总容量），堆内容总容量=9/10新生代+老年代 &lt; 初始化的内存大小</p>
</li>
<li><p><code>[METASPACE:20158K--&gt;20156K(1067008K)]</code>：metaspace GC回收2K空间</p>
</li>
<li><p><code>0.0285388 SECS]</code>：整个GC所花费的时间，单位是秒</p>
</li>
<li><p><code>[TIMES:USER=0.11 SYS-0.00 REAL-0.03 SECS]</code>：</p>
<ul>
<li>user：指的是CPU工作中在用户态所花费的时间</li>
<li>sys：指的是CPU工作在内核态所花费的时间</li>
<li>real：指的是在此次GC事件中所花费的总时间</li>
</ul>
</li>
</ul>
<h4 id="3，GC日志分析工具"><a href="#3，GC日志分析工具" class="headerlink" title="3，GC日志分析工具"></a>3，GC日志分析工具</h4><ul>
<li>==<strong>GCeasy</strong>==</li>
<li>GCViewer</li>
<li>GChisto</li>
<li>HPjmeter</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/05/jvm/" data-id="cks69tgiq0007iwua6a0l5e0w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-docker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/05/docker/" class="article-date">
  <time datetime="2021-04-05T13:48:35.000Z" itemprop="datePublished">2021-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/05/docker/">docker</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/05/docker/" data-id="cks69tft40003iwuabi6xhzhz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-dubbo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/22/dubbo/" class="article-date">
  <time datetime="2021-02-22T05:42:15.000Z" itemprop="datePublished">2021-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/22/dubbo/">dubbo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><h2 id="一，基础知识"><a href="#一，基础知识" class="headerlink" title="一，基础知识"></a>一，基础知识</h2><h3 id="1，分布式基础理论"><a href="#1，分布式基础理论" class="headerlink" title="1，分布式基础理论"></a>1，分布式基础理论</h3><h4 id="a，什么是分布式系统？"><a href="#a，什么是分布式系统？" class="headerlink" title="a，什么是分布式系统？"></a>a，什么是分布式系统？</h4><ul>
<li>《分布式系统原理与范型》定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”，分布式系统是建立在网络之上的软件系统，随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</li>
</ul>
<h3 id="2，RPC"><a href="#2，RPC" class="headerlink" title="2，RPC"></a>2，RPC</h3><h4 id="a，RPC概述："><a href="#a，RPC概述：" class="headerlink" title="a，RPC概述："></a>a，RPC概述：</h4><ul>
<li>RPC（Remote Procedure Call）是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显示编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</li>
</ul>
<h4 id="b，RPC框架产品"><a href="#b，RPC框架产品" class="headerlink" title="b，RPC框架产品"></a>b，RPC框架产品</h4><ul>
<li>dubbo，gRPC，Thrift，HSF（High Speed Service Framework）</li>
</ul>
<h3 id="3，dubbo的概述"><a href="#3，dubbo的概述" class="headerlink" title="3，dubbo的概述"></a>3，dubbo的概述</h3><h4 id="a，简介："><a href="#a，简介：" class="headerlink" title="a，简介："></a>a，简介：</h4><ul>
<li>​    Apache Dubbo是一筐高性能，轻量级的开源JavaRPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</li>
<li><a href="http://dubbo.apache.org/" target="_blank" rel="noopener">dubbo官网</a></li>
</ul>
<h4 id="b，特性："><a href="#b，特性：" class="headerlink" title="b，特性："></a>b，特性：</h4><ul>
<li><strong>面向接口代理的高性能RPC调用</strong>：提供高性能的基于代理的远程调用能力，服务以及接口为粒度，为开发者屏蔽远程调用底层细节</li>
<li><strong>智能负载均衡</strong>：内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量</li>
<li><strong>服务自动注册与发现</strong>：支持多种注册中心服务，服务实例上下线实时感知</li>
<li><strong>高度可扩展能力</strong>：遵循微内核+插件的设计原则，所有核心能力如Protocol，Transport，Serialization被设计为扩展点，平等对待内置实现和第三方实现</li>
<li><strong>运行期流量调度</strong>：内置条件，脚本等路由策略，通过配置不同的路由规则，轻松实现灰度发布，同机房优先等功能</li>
<li><strong>可视化的服务治理与运维</strong>：提供丰富服务治理，运维工具；随时查询服务元数据，服务健康状态以及调用统计，实时下发路由策略，调整配置参数。</li>
</ul>
<h4 id="c，dubbo的架构"><a href="#c，dubbo的架构" class="headerlink" title="c，dubbo的架构"></a>c，dubbo的架构</h4><p><img src="/2021/02/22/dubbo/1.png" alt="image-20210222231024565"></p>
<h3 id="4，dubbo环境搭建"><a href="#4，dubbo环境搭建" class="headerlink" title="4，dubbo环境搭建"></a>4，dubbo环境搭建</h3><h4 id="a，搭建zookeeper：参考笔记Springcloud的内容"><a href="#a，搭建zookeeper：参考笔记Springcloud的内容" class="headerlink" title="a，搭建zookeeper：参考笔记Springcloud的内容"></a>a，搭建zookeeper：参考笔记Springcloud的内容</h4><ul>
<li>略。。。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/02/22/dubbo/" data-id="ckn4ncmcf000a54ua215g5433" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java异常处理机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/03/java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2021-02-03T14:52:39.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/03/java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/">java异常处理机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="你真的了解try-catch吗？"><a href="#你真的了解try-catch吗？" class="headerlink" title="你真的了解try-catch吗？"></a>你真的了解try-catch吗？</h1><h2 id="一，Java异常类型"><a href="#一，Java异常类型" class="headerlink" title="一，Java异常类型"></a>一，Java异常类型</h2><p><img src="/2021/02/03/java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/1.jpg" alt></p>
<ul>
<li><strong>Throwable（可抛出）</strong>：所有的异常的父类。Throwable指定代码可用异常传播机制通过Java应用程序传输的任何问题的共性。<ul>
<li><strong>Error（错误）</strong>：是程序无法处理的错误，表示运行应用程序中较严重问题，大部分时候表示运行时JVM出现了问题；例如Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</li>
<li><strong>Exception（异常）</strong>：是程序本身可以处理的异常。Exception 类有一个重要的子类RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException ArithmeticException）和 ArrayIndexOutOfBoundException。<ul>
<li><strong><em>运行时异常：</em></strong>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</li>
<li><strong><em>非运行时异常 （编译异常）：</em></strong>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二，异常处理机制：抛出异常，捕获异常"><a href="#二，异常处理机制：抛出异常，捕获异常" class="headerlink" title="二，异常处理机制：抛出异常，捕获异常"></a>二，异常处理机制：抛出异常，捕获异常</h2><ul>
<li><strong>抛出异常</strong>：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</li>
<li><strong>捕获异常</strong>：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</li>
<li><strong>一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。</strong></li>
</ul>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h4 id="1，try-catch"><a href="#1，try-catch" class="headerlink" title="1，try-catch"></a>1，try-catch</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会发生异常的程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Type1 id1)&#123;</span><br><span class="line">    <span class="comment">// 捕获并处置try抛出的异常类型Type1</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Type2 id2)&#123;</span><br><span class="line">     <span class="comment">//捕获并处置try抛出的异常类型Type2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>​    需要注意的是，<strong>一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。</strong></li>
</ul>
<h4 id="2，try-catch-finally"><a href="#2，try-catch-finally" class="headerlink" title="2，try-catch-finally"></a>2，try-catch-finally</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会发生异常的程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Type1 id1)&#123;</span><br><span class="line">    <span class="comment">// 捕获并处置try抛出的异常类型Type1</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Type2 id2)&#123;</span><br><span class="line">     <span class="comment">//捕获并处置try抛出的异常类型Type2</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">//无论是否发送异常，都将执行的语句块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特别说明：finally无论是否捕获或处理异常，finally块里的语句都会被执行。<strong>当在try或catch块中遇到return语句时，finally语句块将在方法返回之前被执行</strong>。在以下4中特殊情况下，finally块不会被执行：<ul>
<li>在finally语句块中发生了异常</li>
<li>在前面的代码中用了System.exit（）退出程序</li>
<li>程序所在的线程死亡</li>
<li>关闭CPU</li>
</ul>
</li>
</ul>
<h4 id="3，try，catch，finally语句块的执行顺序："><a href="#3，try，catch，finally语句块的执行顺序：" class="headerlink" title="*** 3，try，catch，finally语句块的执行顺序："></a>*** 3，try，catch，finally语句块的执行顺序：</h4><ul>
<li>当try没有捕获到异常时：<ul>
<li>try语句块中的语句逐一被执行，程序将跳过catch语句块，<strong>执行finally语句块和其后的语句</strong>；</li>
</ul>
</li>
<li>当try捕获到异常时：<ul>
<li>catch语句块没有处理此异常：try语句块出现异常后的语句不会被执行，并将异常抛给JVM处理，<strong>finally语句块的语句还是会被执行，但是finally语句块后的语句不会被执行</strong></li>
<li>catch语句块有处理此异常：try语句块出现异常后的语句同样不会被执行，程序将会跳到catch语句，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而catch语句块执行完毕后，<strong>执行finally语句块里面的语句，最后执行finally语句块后的语句；</strong></li>
</ul>
</li>
</ul>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><h4 id="1，throws"><a href="#1，throws" class="headerlink" title="1，throws"></a>1，throws</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">methodname <span class="keyword">throws</span> Exception1,Exception2,..,ExceptionN&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>throws抛出异常的规则：<ul>
<li>如果是不可查异常（unchecked exception），即Error，RuntimeException或者他们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但是在运行时会被系统抛出</li>
<li>必须声明方法可抛出的任何可查异常（checked exception），即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li>
<li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li>
<li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类</li>
</ul>
</li>
</ul>
<h4 id="2，throw"><a href="#2，throw" class="headerlink" title="2，throw"></a>2，throw</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> exceptionName;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<ul>
<li><strong>Throw （是 catch 中还是非 catch 中）后面不能再跟其他代码块了 ，否则编译不能通过</strong></li>
<li><strong>但可以在finally语句块有return语句,finally语句块成功骗过编译器让throw和return两者并存</strong></li>
<li><strong><em>finally如果有return会覆盖catch里的throw，同样如果finally里有throw会覆盖catch里的return。</em></strong></li>
</ul>
</li>
</ul>
<h3 id="异常链："><a href="#异常链：" class="headerlink" title="异常链："></a>异常链：</h3><ul>
<li>Java向上传递异常信息的处理机制，形成异常链：Java方法抛出的可查异常将依据调用栈、沿着方法调用的层次结构一直传递到具备处理能力的调用方法，最高层次到main方法为止。如果异常传递到main方法，而main不具备处理能力，也没有通过throws声明抛出该异常，将可能出现编译错误。</li>
</ul>
<h3 id="Throwable类中常用方法："><a href="#Throwable类中常用方法：" class="headerlink" title="Throwable类中常用方法："></a>Throwable类中常用方法：</h3><blockquote>
<p>getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。</p>
<p>getMeage()：返回异常的消息信息。</p>
<p>printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。</p>
</blockquote>
<h2 id="三，Java常见异常"><a href="#三，Java常见异常" class="headerlink" title="三，Java常见异常"></a>三，Java常见异常</h2><h3 id="1，-runtimeException子类"><a href="#1，-runtimeException子类" class="headerlink" title="1， runtimeException子类:"></a>1， runtimeException子类:</h3><blockquote>
<p>1、 java.lang.ArrayIndexOutOfBoundsException    数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p>
<p>2、java.lang.ArithmeticException    算术条件异常。譬如：整数除零等。</p>
<p>3、java.lang.NullPointerException    空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</p>
<p>4、java.lang.ClassNotFoundException    找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p>
<p>5、java.lang.NegativeArraySizeException    数组长度为负异常</p>
<p>6、java.lang.ArrayStoreException    数组中包含不兼容的值抛出的异常</p>
<p>7、java.lang.SecurityException    安全性异常</p>
<p>8、java.lang.IllegalArgumentException     非法参数异常</p>
</blockquote>
<h3 id="2，IOException"><a href="#2，IOException" class="headerlink" title="2，IOException:"></a>2，IOException:</h3><blockquote>
<p>1, IOException：操作输入流和输出流时可能出现的异常。</p>
<p>2, EOFException  文件已结束异常</p>
<p>3 ,FileNotFoundException  文件未找到异常</p>
</blockquote>
<h3 id="3，其他异常"><a href="#3，其他异常" class="headerlink" title="3，其他异常"></a>3，其他异常</h3><blockquote>
<p>1，ClassCastException   类型转换异常类</p>
<p>2，ArrayStoreException  数组中包含不兼容的值抛出的异常</p>
<p>3，SQLException  操作数据库异常类</p>
<p>4，NoSuchFieldException  字段未找到异常</p>
<p>5，NoSuchMethodException  方法未找到抛出的异常</p>
<p>6，NumberFormatException   字符串转换为数字抛出的异常</p>
<p>7，StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</p>
<p>8，IllegalAccessException  不允许访问某类异常</p>
<p>9，InstantiationException  当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</p>
</blockquote>
<h2 id="四，自定义异常"><a href="#四，自定义异常" class="headerlink" title="四，自定义异常"></a>四，自定义异常</h2><ol>
<li><strong>创建自定义异常类：</strong>一般会选择继承Exception和RuntimeException，如果不要求调用者一定要处理抛出的异常，就继承RuntimeException。</li>
<li><strong>抛出自定义异常</strong>：在方法中通过throw关键字抛出异常对象。</li>
<li><strong>捕获自定义异常</strong>：如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li>
<li><strong>在出现异常方法的调用者中捕获并处理异常</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">// 创建自定义异常类</span></span><br><span class="line">    String message; <span class="comment">// 定义String类型变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String ErrorMessagr)</span> </span>&#123; <span class="comment">// 父类方法</span></span><br><span class="line">        message = ErrorMessagr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123; <span class="comment">// 覆盖getMessage()方法</span></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五，try-catch-finally语句中有return情况："><a href="#五，try-catch-finally语句中有return情况：" class="headerlink" title="五，try-catch-finally语句中有return情况："></a>五，try-catch-finally语句中有return情况：</h2><h3 id="1，try中有return语句和最后有return语句："><a href="#1，try中有return语句和最后有return语句：" class="headerlink" title="1，try中有return语句和最后有return语句："></a>1，try中有return语句和最后有return语句：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExcReurn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a= a+b;	<span class="comment">//43</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch语句块"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally语句块"</span>);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testExcReurn t = <span class="keyword">new</span> testExcReurn();</span><br><span class="line">        System.out.println(<span class="string">"和="</span>+t.add(<span class="number">9</span>, <span class="number">34</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果：finally语句块 和=43</p>
<p>合理的解释是，在try中执行到return语句时，不会真正的return，即只是会计算return中的表达式，之后将结果保存在一个临时栈中，接着执行finally中的语句，最后才会从临时栈中取出之前的结果返回。</p>
</blockquote>
<h3 id="2，try和finally都有return语句："><a href="#2，try和finally都有return语句：" class="headerlink" title="2，try和finally都有return语句："></a>2，try和finally都有return语句：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExcReurn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch语句块"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally语句块"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testExcReurn t = <span class="keyword">new</span> testExcReurn();</span><br><span class="line">        System.out.println(<span class="string">"和="</span>+t.add(<span class="number">9</span>, <span class="number">34</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果：finally语句块和=0</p>
<p>原因是finally中的return会覆盖try语句块中的return</p>
</blockquote>
<h3 id="3，return的数据是引用数据类型"><a href="#3，return的数据是引用数据类型" class="headerlink" title="3，return的数据是引用数据类型"></a>3，return的数据是引用数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExcReurn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> testExcReurn <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.a  = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch语句块"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally语句块"</span>);</span><br><span class="line">            <span class="keyword">this</span>.a = <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testExcReurn t = <span class="keyword">new</span> testExcReurn();</span><br><span class="line">        t.set();</span><br><span class="line">        System.out.println(<span class="string">"a="</span>+ t.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果：finally语句块a=200 </p>
</blockquote>
<h2 id="六，重点小结："><a href="#六，重点小结：" class="headerlink" title="六，重点小结："></a>六，重点小结：</h2><blockquote>
<p><strong>1、finally覆盖catch（开头引子的例子）：</strong></p>
<pre><code>1）如果finally有return会覆盖catch里的throw，同样如果finally里有throw会覆盖catch里的return。
2）如果catch里和finally都有return， finally中的return会覆盖catch中的。throw也是如此。</code></pre><p><strong>2、catch有return而finally没有：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当 try 中抛出异常且catch 中有 return 语句，finally 中没有 return 语句， java 先执行 catch 中非 return 语句，再执行 finally 语句，最后执行 catch 中 return 语句。</span><br></pre></td></tr></table></figure>

<p><strong>3、try有return语句，后续还有return语句，分为以下三种情况：</strong></p>
<p>情况一：如果finally中有return语句，则会将try中的return语句”覆盖“掉，直接执行finally中的return语句，得到返回值，这样便无法得到try之前保留好的返回值。</p>
<p>情况二：如果finally中没有return语句，也没有改变要返回值，则执行完finally中的语句后，会接着执行try中的return语句，返回之前保留的值。</p>
<p>情况三：如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况，：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。</span><br><span class="line"></span><br><span class="line">2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>参考网址：<a href="https://guisu.blog.csdn.net/article/details/6155636?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.control" target="_blank" rel="noopener">java(3)-深入理解java异常处理机制</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/02/03/java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" data-id="ckn4ncmci000c54ua042497qj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3try-catch%E5%90%97%EF%BC%9F/" rel="tag">你真的了解try-catch吗？</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3try-catch%E5%90%97%EF%BC%9F/" rel="tag">你真的了解try-catch吗？</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3try-catch%E5%90%97%EF%BC%9F/" style="font-size: 10px;">你真的了解try-catch吗？</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/08/JUC/">JUC</a>
          </li>
        
          <li>
            <a href="/2021/07/28/rocketMQ/">rocketMQ</a>
          </li>
        
          <li>
            <a href="/2021/07/16/netty/">netty</a>
          </li>
        
          <li>
            <a href="/2021/05/29/DynamicProgramming/">Dynamic Programming</a>
          </li>
        
          <li>
            <a href="/2021/05/08/Greedy/">Greedy</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 It-fang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>