<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>It-fang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="A blog for discussing Java background development, which will regularly publish some bloggers in the learning process of their own experience and confusion, I hope that we can learn from each other he">
<meta property="og:type" content="website">
<meta property="og:title" content="It-fang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="It-fang">
<meta property="og:description" content="A blog for discussing Java background development, which will regularly publish some bloggers in the learning process of their own experience and confusion, I hope that we can learn from each other he">
<meta property="article:author" content="It-fang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="It-fang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">It-fang</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">It-fang</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java异常处理机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/03/java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2021-02-03T14:52:39.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/03/java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/">java异常处理机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="你真的了解try-catch吗？"><a href="#你真的了解try-catch吗？" class="headerlink" title="你真的了解try-catch吗？"></a>你真的了解try-catch吗？</h1><h2 id="一，Java异常类型"><a href="#一，Java异常类型" class="headerlink" title="一，Java异常类型"></a>一，Java异常类型</h2><p><img src="/2021/02/03/java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/1.jpg" alt></p>
<ul>
<li><strong>Throwable（可抛出）</strong>：所有的异常的父类。Throwable指定代码可用异常传播机制通过Java应用程序传输的任何问题的共性。<ul>
<li><strong>Error（错误）</strong>：是程序无法处理的错误，表示运行应用程序中较严重问题，大部分时候表示运行时JVM出现了问题；例如Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</li>
<li><strong>Exception（异常）</strong>：是程序本身可以处理的异常。Exception 类有一个重要的子类RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException ArithmeticException）和 ArrayIndexOutOfBoundException。<ul>
<li><strong><em>运行时异常：</em></strong>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</li>
<li><strong><em>非运行时异常 （编译异常）：</em></strong>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二，异常处理机制：抛出异常，捕获异常"><a href="#二，异常处理机制：抛出异常，捕获异常" class="headerlink" title="二，异常处理机制：抛出异常，捕获异常"></a>二，异常处理机制：抛出异常，捕获异常</h2><ul>
<li><strong>抛出异常</strong>：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</li>
<li><strong>捕获异常</strong>：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</li>
<li><strong>一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。</strong></li>
</ul>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h4 id="1，try-catch"><a href="#1，try-catch" class="headerlink" title="1，try-catch"></a>1，try-catch</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会发生异常的程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Type1 id1)&#123;</span><br><span class="line">    <span class="comment">// 捕获并处置try抛出的异常类型Type1</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Type2 id2)&#123;</span><br><span class="line">     <span class="comment">//捕获并处置try抛出的异常类型Type2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>​    需要注意的是，<strong>一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。</strong></li>
</ul>
<h4 id="2，try-catch-finally"><a href="#2，try-catch-finally" class="headerlink" title="2，try-catch-finally"></a>2，try-catch-finally</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会发生异常的程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Type1 id1)&#123;</span><br><span class="line">    <span class="comment">// 捕获并处置try抛出的异常类型Type1</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Type2 id2)&#123;</span><br><span class="line">     <span class="comment">//捕获并处置try抛出的异常类型Type2</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">//无论是否发送异常，都将执行的语句块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特别说明：finally无论是否捕获或处理异常，finally块里的语句都会被执行。<strong>当在try或catch块中遇到return语句时，finally语句块将在方法返回之前被执行</strong>。在以下4中特殊情况下，finally块不会被执行：<ul>
<li>在finally语句块中发生了异常</li>
<li>在前面的代码中用了System.exit（）退出程序</li>
<li>程序所在的线程死亡</li>
<li>关闭CPU</li>
</ul>
</li>
</ul>
<h4 id="3，try，catch，finally语句块的执行顺序："><a href="#3，try，catch，finally语句块的执行顺序：" class="headerlink" title="*** 3，try，catch，finally语句块的执行顺序："></a>*** 3，try，catch，finally语句块的执行顺序：</h4><ul>
<li>当try没有捕获到异常时：<ul>
<li>try语句块中的语句逐一被执行，程序将跳过catch语句块，<strong>执行finally语句块和其后的语句</strong>；</li>
</ul>
</li>
<li>当try捕获到异常时：<ul>
<li>catch语句块没有处理此异常：try语句块出现异常后的语句不会被执行，并将异常抛给JVM处理，<strong>finally语句块的语句还是会被执行，但是finally语句块后的语句不会被执行</strong></li>
<li>catch语句块有处理此异常：try语句块出现异常后的语句同样不会被执行，程序将会跳到catch语句，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而catch语句块执行完毕后，<strong>执行finally语句块里面的语句，最后执行finally语句块后的语句；</strong></li>
</ul>
</li>
</ul>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><h4 id="1，throws"><a href="#1，throws" class="headerlink" title="1，throws"></a>1，throws</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">methodname <span class="keyword">throws</span> Exception1,Exception2,..,ExceptionN&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>throws抛出异常的规则：<ul>
<li>如果是不可查异常（unchecked exception），即Error，RuntimeException或者他们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但是在运行时会被系统抛出</li>
<li>必须声明方法可抛出的任何可查异常（checked exception），即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li>
<li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li>
<li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类</li>
</ul>
</li>
</ul>
<h4 id="2，throw"><a href="#2，throw" class="headerlink" title="2，throw"></a>2，throw</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> exceptionName;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<ul>
<li><strong>Throw （是 catch 中还是非 catch 中）后面不能再跟其他代码块了 ，否则编译不能通过</strong></li>
<li><strong>但可以在finally语句块有return语句,finally语句块成功骗过编译器让throw和return两者并存</strong></li>
<li><strong><em>finally如果有return会覆盖catch里的throw，同样如果finally里有throw会覆盖catch里的return。</em></strong></li>
</ul>
</li>
</ul>
<h3 id="异常链："><a href="#异常链：" class="headerlink" title="异常链："></a>异常链：</h3><ul>
<li>Java向上传递异常信息的处理机制，形成异常链：Java方法抛出的可查异常将依据调用栈、沿着方法调用的层次结构一直传递到具备处理能力的调用方法，最高层次到main方法为止。如果异常传递到main方法，而main不具备处理能力，也没有通过throws声明抛出该异常，将可能出现编译错误。</li>
</ul>
<h3 id="Throwable类中常用方法："><a href="#Throwable类中常用方法：" class="headerlink" title="Throwable类中常用方法："></a>Throwable类中常用方法：</h3><blockquote>
<p>getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。</p>
<p>getMeage()：返回异常的消息信息。</p>
<p>printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。</p>
</blockquote>
<h2 id="三，Java常见异常"><a href="#三，Java常见异常" class="headerlink" title="三，Java常见异常"></a>三，Java常见异常</h2><h3 id="1，-runtimeException子类"><a href="#1，-runtimeException子类" class="headerlink" title="1， runtimeException子类:"></a>1， runtimeException子类:</h3><blockquote>
<p>1、 java.lang.ArrayIndexOutOfBoundsException    数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p>
<p>2、java.lang.ArithmeticException    算术条件异常。譬如：整数除零等。</p>
<p>3、java.lang.NullPointerException    空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</p>
<p>4、java.lang.ClassNotFoundException    找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p>
<p>5、java.lang.NegativeArraySizeException    数组长度为负异常</p>
<p>6、java.lang.ArrayStoreException    数组中包含不兼容的值抛出的异常</p>
<p>7、java.lang.SecurityException    安全性异常</p>
<p>8、java.lang.IllegalArgumentException     非法参数异常</p>
</blockquote>
<h3 id="2，IOException"><a href="#2，IOException" class="headerlink" title="2，IOException:"></a>2，IOException:</h3><blockquote>
<p>1, IOException：操作输入流和输出流时可能出现的异常。</p>
<p>2, EOFException  文件已结束异常</p>
<p>3 ,FileNotFoundException  文件未找到异常</p>
</blockquote>
<h3 id="3，其他异常"><a href="#3，其他异常" class="headerlink" title="3，其他异常"></a>3，其他异常</h3><blockquote>
<p>1，ClassCastException   类型转换异常类</p>
<p>2，ArrayStoreException  数组中包含不兼容的值抛出的异常</p>
<p>3，SQLException  操作数据库异常类</p>
<p>4，NoSuchFieldException  字段未找到异常</p>
<p>5，NoSuchMethodException  方法未找到抛出的异常</p>
<p>6，NumberFormatException   字符串转换为数字抛出的异常</p>
<p>7，StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</p>
<p>8，IllegalAccessException  不允许访问某类异常</p>
<p>9，InstantiationException  当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</p>
</blockquote>
<h2 id="四，自定义异常"><a href="#四，自定义异常" class="headerlink" title="四，自定义异常"></a>四，自定义异常</h2><ol>
<li><strong>创建自定义异常类：</strong>一般会选择继承Exception和RuntimeException，如果不要求调用者一定要处理抛出的异常，就继承RuntimeException。</li>
<li><strong>抛出自定义异常</strong>：在方法中通过throw关键字抛出异常对象。</li>
<li><strong>捕获自定义异常</strong>：如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li>
<li><strong>在出现异常方法的调用者中捕获并处理异常</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">// 创建自定义异常类</span></span><br><span class="line">    String message; <span class="comment">// 定义String类型变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String ErrorMessagr)</span> </span>&#123; <span class="comment">// 父类方法</span></span><br><span class="line">        message = ErrorMessagr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123; <span class="comment">// 覆盖getMessage()方法</span></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五，try-catch-finally语句中有return情况："><a href="#五，try-catch-finally语句中有return情况：" class="headerlink" title="五，try-catch-finally语句中有return情况："></a>五，try-catch-finally语句中有return情况：</h2><h3 id="1，try中有return语句和最后有return语句："><a href="#1，try中有return语句和最后有return语句：" class="headerlink" title="1，try中有return语句和最后有return语句："></a>1，try中有return语句和最后有return语句：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExcReurn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a= a+b;	<span class="comment">//43</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch语句块"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally语句块"</span>);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testExcReurn t = <span class="keyword">new</span> testExcReurn();</span><br><span class="line">        System.out.println(<span class="string">"和="</span>+t.add(<span class="number">9</span>, <span class="number">34</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果：finally语句块 和=43</p>
<p>合理的解释是，在try中执行到return语句时，不会真正的return，即只是会计算return中的表达式，之后将结果保存在一个临时栈中，接着执行finally中的语句，最后才会从临时栈中取出之前的结果返回。</p>
</blockquote>
<h3 id="2，try和finally都有return语句："><a href="#2，try和finally都有return语句：" class="headerlink" title="2，try和finally都有return语句："></a>2，try和finally都有return语句：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExcReurn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch语句块"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally语句块"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testExcReurn t = <span class="keyword">new</span> testExcReurn();</span><br><span class="line">        System.out.println(<span class="string">"和="</span>+t.add(<span class="number">9</span>, <span class="number">34</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果：finally语句块和=0</p>
<p>原因是finally中的return会覆盖try语句块中的return</p>
</blockquote>
<h3 id="3，return的数据是引用数据类型"><a href="#3，return的数据是引用数据类型" class="headerlink" title="3，return的数据是引用数据类型"></a>3，return的数据是引用数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExcReurn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> testExcReurn <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.a  = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch语句块"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally语句块"</span>);</span><br><span class="line">            <span class="keyword">this</span>.a = <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testExcReurn t = <span class="keyword">new</span> testExcReurn();</span><br><span class="line">        t.set();</span><br><span class="line">        System.out.println(<span class="string">"a="</span>+ t.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果：finally语句块a=200 </p>
</blockquote>
<h2 id="六，重点小结："><a href="#六，重点小结：" class="headerlink" title="六，重点小结："></a>六，重点小结：</h2><blockquote>
<p><strong>1、finally覆盖catch（开头引子的例子）：</strong></p>
<pre><code>1）如果finally有return会覆盖catch里的throw，同样如果finally里有throw会覆盖catch里的return。
2）如果catch里和finally都有return， finally中的return会覆盖catch中的。throw也是如此。</code></pre><p><strong>2、catch有return而finally没有：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当 try 中抛出异常且catch 中有 return 语句，finally 中没有 return 语句， java 先执行 catch 中非 return 语句，再执行 finally 语句，最后执行 catch 中 return 语句。</span><br></pre></td></tr></table></figure>

<p><strong>3、try有return语句，后续还有return语句，分为以下三种情况：</strong></p>
<p>情况一：如果finally中有return语句，则会将try中的return语句”覆盖“掉，直接执行finally中的return语句，得到返回值，这样便无法得到try之前保留好的返回值。</p>
<p>情况二：如果finally中没有return语句，也没有改变要返回值，则执行完finally中的语句后，会接着执行try中的return语句，返回之前保留的值。</p>
<p>情况三：如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况，：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。</span><br><span class="line"></span><br><span class="line">2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>参考网址：<a href="https://guisu.blog.csdn.net/article/details/6155636?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.control" target="_blank" rel="noopener">java(3)-深入理解java异常处理机制</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/02/03/java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" data-id="cklg57v0k000ab8ua1yyj9nyx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3try-catch%E5%90%97%EF%BC%9F/" rel="tag">你真的了解try-catch吗？</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-screen" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/30/screen/" class="article-date">
  <time datetime="2021-01-29T16:13:02.000Z" itemprop="datePublished">2021-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/30/screen/">screen</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Linux的screen命令的使用"><a href="#Linux的screen命令的使用" class="headerlink" title="Linux的screen命令的使用"></a>Linux的screen命令的使用</h1><h3 id="screen的基本命令"><a href="#screen的基本命令" class="headerlink" title="- screen的基本命令"></a>- screen的基本命令</h3><p><a href="https://blog.csdn.net/erdfty/article/details/89879173" target="_blank" rel="noopener">https://blog.csdn.net/erdfty/article/details/89879173</a></p>
<h3 id="使用screen命令的原因"><a href="#使用screen命令的原因" class="headerlink" title="- 使用screen命令的原因"></a>- 使用screen命令的原因</h3><p>答：如果你是通过jar的方式在Linux上部署项目的话，可能存在这样的一个问题：如果你在主屏幕（当你连接上Linux时使用的第一个屏幕）直接通过jar命令部署jar包的话，当你断开连接后，jar包也会被关闭掉而导致你无法访问接口；或者当你用jar命令部署jar包时，你的控制台会变成项目的控制台而导致你无法对Linux进行其他的操作。这个时候，你就可以通过screen命令创建一个新的屏幕，然后在新的屏幕里面通过jar命令部署项目，就可以完美解决上述存在的问题了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/01/30/screen/" data-id="cklg57v18000fb8ua47o04fji" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2021-01-24T11:55:02.000Z" itemprop="datePublished">2021-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/01/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="cklg57v1c000hb8uab2jnbrh5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SpringCloud" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/20/SpringCloud/" class="article-date">
  <time datetime="2021-01-20T02:52:27.000Z" itemprop="datePublished">2021-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/20/SpringCloud/">SpringCloud</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="一，什么是springCloud"><a href="#一，什么是springCloud" class="headerlink" title="一，什么是springCloud"></a><strong>一，什么是springCloud</strong></h2><ul>
<li><p>springCloud：分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶。</p>
<p><img src="/2021/01/20/SpringCloud/12.png" alt="image-20210128200621302"></p>
</li>
</ul>
<h2 id="二，微服务架构的维度"><a href="#二，微服务架构的维度" class="headerlink" title="二，微服务架构的维度"></a><strong>二，微服务架构的维度</strong></h2><ul>
<li><p>服务注册与发现</p>
</li>
<li><p>服务调用</p>
</li>
<li><p>服务熔断</p>
</li>
<li><p>负载均衡</p>
</li>
<li><p>服务降级</p>
</li>
<li><p>服务消息队列</p>
</li>
<li><p>配置中心管理</p>
</li>
<li><p>服务网关</p>
</li>
<li><p>服务监控</p>
</li>
<li><p>全链路追踪</p>
</li>
<li><p>自动化构建部署</p>
</li>
<li><p>服务定时任务调度操作</p>
</li>
</ul>
<h2 id="三，springCloud全家桶"><a href="#三，springCloud全家桶" class="headerlink" title="三，springCloud全家桶"></a><strong>三，springCloud全家桶</strong></h2><p><img src="/2021/01/20/SpringCloud/1.png" alt="1"></p>
<h2 id="四，springCloud升级"><a href="#四，springCloud升级" class="headerlink" title="四，springCloud升级"></a>四，springCloud升级</h2><p><img src="/2021/01/20/SpringCloud/2.png" alt="image-20210120205545434"></p>
<h2 id="五，服务注册中心"><a href="#五，服务注册中心" class="headerlink" title="五，服务注册中心"></a>五，服务注册中心</h2><h3 id="1，Eureka"><a href="#1，Eureka" class="headerlink" title="1，Eureka"></a>1，Eureka</h3><h4 id="a，什么是服务治理？"><a href="#a，什么是服务治理？" class="headerlink" title="a，什么是服务治理？"></a>a，什么是服务治理？</h4><ul>
<li>SpringCloud封装了Netflix公司开发的Eureka模块来实现服务治理。在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用，负载均衡，容错等，实现服务发现与注册。</li>
</ul>
<h4 id="b，什么是服务注册与发现"><a href="#b，什么是服务注册与发现" class="headerlink" title="b，什么是服务注册与发现"></a>b，什么是服务注册与发现</h4><ul>
<li><p>Eureka采用了CS的设计架构，Eureka Server作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。</p>
</li>
<li><p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息。比如服务地址，通讯地址等以别名方式注册到注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中兴管理每个服务与服务之间的一个依赖关系（服务治理概念）。在任何RPC远程框架中，都会有一个注册中心（存放服务地址相关信息（接口地址））</p>
<p><img src="/2021/01/20/SpringCloud/3.png" alt="image-20210121222548656"></p>
</li>
</ul>
<h4 id="c，Eureka包含两个组件：Eureka-Server和Eureka-Client"><a href="#c，Eureka包含两个组件：Eureka-Server和Eureka-Client" class="headerlink" title="c，Eureka包含两个组件：Eureka Server和Eureka Client"></a>c，Eureka包含两个组件：Eureka Server和Eureka Client</h4><ul>
<li>Eureka Server提供服务注册服务<ul>
<li>各个微服务节点通过配置启动后，会在Eureka Serve中进行注册，这样Eureka Serve中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到</li>
</ul>
</li>
<li>Eureka Client通过注册中心进行方位<ul>
<li>是一个Java客户端，用于简化Eureka Serve的交互，客户端同时也具备一个内置的，使用轮询（round-robin）负载算法的负载均衡器。在应用启动后，将会向Eureka Serve发送心跳（默认周期为30秒）。如果Eureka Serve在多个心跳周期内没有接收到某个节点的心跳，Eureka Serve将会从服务注册表中把这个服务节点移除（默认90秒 ）</li>
</ul>
</li>
</ul>
<h4 id="d，单机版Eureka服务端的配置"><a href="#d，单机版Eureka服务端的配置" class="headerlink" title="d，单机版Eureka服务端的配置"></a>d，单机版Eureka服务端的配置</h4><p><strong>eureka server模块：</strong>服务注册中心</p>
<ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-eureka-server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>​        application.yml:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span>  <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-register:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">    <span class="comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>​        在启动类上加上注解：<strong>@EnableEurekaServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaMain7001</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(EurekaMain7001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>eureka-clien</strong>t：服务提供者|服务消费者——入驻服务注册中心</p>
<ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-eureka-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span> <span class="comment">#配置入驻到服务注册中兴的名字</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进Eureka Server默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从Eureka Server抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>​    在启动类上加上注解：<strong>@EnableEurekaClient</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain9004</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain9004<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h4 id="e，Eureka集群实现：多个Eureka要两两相互注册，每个微服务都要入驻进所有的Eureka中"><a href="#e，Eureka集群实现：多个Eureka要两两相互注册，每个微服务都要入驻进所有的Eureka中" class="headerlink" title="e，Eureka集群实现：多个Eureka要两两相互注册，每个微服务都要入驻进所有的Eureka中"></a>e，Eureka集群实现：多个Eureka要两两相互注册，每个微服务都要入驻进所有的Eureka中</h4><p><img src="/2021/01/20/SpringCloud/4.png" alt="image-20210122213459233"></p>
<ul>
<li>微服务RPC远程服务调用最核心的是什么？<ul>
<li><strong>高可用</strong>，试想你的注册中心只有一个，它出故障会导致整个微服务环境不可用</li>
<li>解决办法；搭建Eureka注册中心集群，实现负载均衡+故障容错</li>
</ul>
</li>
</ul>
<h4 id="f，actuator微服务信息完善"><a href="#f，actuator微服务信息完善" class="headerlink" title="f，actuator微服务信息完善"></a>f，actuator微服务信息完善</h4><ul>
<li><p>修改服务注册中心显示的主机名称和访问信息有IP信息提示</p>
<ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span> </span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8002</span>  <span class="comment">#修改后的主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>  <span class="comment">#访问路径可以显示IP地址</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h4 id="g，服务发现Discovery"><a href="#g，服务发现Discovery" class="headerlink" title="g，服务发现Discovery"></a>g，服务发现Discovery</h4><ul>
<li><p>服务发现：对于注册进Eureka里面的微服务，可以通过服务发现来获得该服务的信息</p>
<ul>
<li><p>注入服务发现客户端对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在服务发现客户端的启动类上添加注解:<strong>@EnableDiscoveryClient</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain8001</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写测试类接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/payment/discovery"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">discovery</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	获得服务注册中心中所有服务的服务名称    </span></span><br><span class="line">    List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line">    <span class="keyword">for</span>(String servicesName:services)&#123;</span><br><span class="line">        log.info(<span class="string">"*****serviceName:"</span> + serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//	获得服务名称对应的所有实例化服务的信息</span></span><br><span class="line">    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">"CLOUD-PAYMENT-SERVICE"</span>);</span><br><span class="line">    <span class="keyword">for</span>(ServiceInstance instance:instances)&#123;</span><br><span class="line">        log.info(instance.getServiceId()+<span class="string">"\t"</span>+instance.getHost()+<span class="string">"\t"</span>+instance.getPort()+<span class="string">"\t"</span>+instance.getUri());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.discoveryClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h4 id="i，Eureka自我保护"><a href="#i，Eureka自我保护" class="headerlink" title="i，Eureka自我保护"></a>i，Eureka自我保护</h4><ul>
<li><p><strong>概述</strong>：保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试波阿虎器服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。即：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保护。Eureka自我保护属于CAP里面的AP分支。</p>
<ul>
<li>如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式：</li>
</ul>
<p><img src="/2021/01/20/SpringCloud/5.png" alt="image-20210123195522378"></p>
</li>
<li><p>为什么会产生Eureka自我保护机制？</p>
<ul>
<li>为了防止Eureka Client可以正常运行，但是与Eureka Server网络不通情况下，Eureka Server不会立刻将Eureka Client服务剔除</li>
</ul>
</li>
<li><p>什么是自我保护模式？</p>
<ul>
<li><p>默认情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例（默认90秒）。但是当网络分区故障发生（延时，卡顿，拥挤）时，微服务与Eureka Server之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区障碍），那么这个节点就会进入自我保护模式。</p>
<p><img src="/2021/01/20/SpringCloud/6.png" alt="image-20210123215230021"></p>
</li>
<li><p>在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。</p>
</li>
<li><p>它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。</p>
</li>
<li><p>综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮，稳定。</p>
</li>
</ul>
</li>
</ul>
<h4 id="j，Eureka如何禁止自我保护"><a href="#j，Eureka如何禁止自我保护" class="headerlink" title="j，Eureka如何禁止自我保护"></a>j，Eureka如何禁止自我保护</h4><ul>
<li><p>Eureka Server（服务注册中心）：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment">#关闭自我保护机制，保证不可用服务被及时剔除</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Eureka Client（服务提供者）：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="comment">#心跳检测与续约时间</span></span><br><span class="line">  <span class="comment">#开发时设置小些，保证服务关闭后注册中心能及时剔除服务 </span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#Eureka客户端向服务端发送心跳的时间间隔，单位为秒（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">#Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒（默认是90秒），超时将剔除服务</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
<h3 id="2，zookeeper"><a href="#2，zookeeper" class="headerlink" title="2，zookeeper"></a>2，zookeeper</h3><h4 id="a，服务注册"><a href="#a，服务注册" class="headerlink" title="a，服务注册"></a>a，服务注册</h4><ul>
<li><p>开启zookeeper服务中心：在Linux服务器上安装并启动zookeeper服务器</p>
</li>
<li><p>将服务注册进zookeeper中：</p>
<ul>
<li><p>pom.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot整合zookeeper客户端：导入的版本要与Linux服务器上的zookeeper服务器版本一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--先排除自带的zookeeper3.5.3--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>application.yml:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#服务别名————注册zookeeper到注册中心的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-payment</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zoopkeeper:</span></span><br><span class="line">     <span class="attr">connect-string:</span> <span class="string">$&#123;zookeeper.ip&#125;:$&#123;zookeeper.port&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span>   <span class="comment">//该注解用于向使用consul或者zookeeper作为注册中心时注册服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain9090</span>  </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain9090<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="b，zookeeper的服务节点是临时节点：当服务宕机后，zookeeper会在一定心跳时间后将服务剔除"><a href="#b，zookeeper的服务节点是临时节点：当服务宕机后，zookeeper会在一定心跳时间后将服务剔除" class="headerlink" title="b，zookeeper的服务节点是临时节点：当服务宕机后，zookeeper会在一定心跳时间后将服务剔除"></a>b，zookeeper的服务节点是临时节点：当服务宕机后，zookeeper会在一定心跳时间后将服务剔除</h4><h3 id="3，consul"><a href="#3，consul" class="headerlink" title="3，consul"></a>3，consul</h3><h4 id="a，consul的简介"><a href="#a，consul的简介" class="headerlink" title="a，consul的简介"></a>a，consul的简介</h4><ul>
<li>consul是一套开源的分布式服务发现和配置管理系统，由HashiCorp公司用Go语言开发。</li>
<li>提供了微服务系统汇总的服务治理，配置中心，控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之consul提供了一种完整的服务网格解决方案。</li>
<li>它具有很多优点。包括：基于raft协议，比较简介；支持健康检查，同时支持HTTP和DNS协议，支持跨数据中心的WAN集群，提供图形界面，跨平台，支持Linux，Mac，Windows</li>
</ul>
<h4 id="b，consul的作用："><a href="#b，consul的作用：" class="headerlink" title="b，consul的作用："></a>b，consul的作用：</h4><ul>
<li>服务发现：提供HTTP和DNS两种发现方式；</li>
<li>健康监测：支持多种方式，HTTP，TCP，Docker，Shell脚本定制化；</li>
<li>KV存储：Key，Value的存储方式；</li>
<li>多数据中心：consul支持多数据中心</li>
<li>可视化Web界面</li>
</ul>
<h3 id="4，三个服务注册中心的异同点"><a href="#4，三个服务注册中心的异同点" class="headerlink" title="4，三个服务注册中心的异同点"></a>4，三个服务注册中心的异同点</h3><h4 id="a，三个服务注册中心的异同点"><a href="#a，三个服务注册中心的异同点" class="headerlink" title="a，三个服务注册中心的异同点"></a>a，三个服务注册中心的异同点</h4><p><img src="/2021/01/20/SpringCloud/7.png" alt="image-20210124143930915"></p>
<h4 id="b，CAP图"><a href="#b，CAP图" class="headerlink" title="b，CAP图"></a>b，CAP图</h4><p><img src="/2021/01/20/SpringCloud/8.png" alt="image-20210124144029682"></p>
<ul>
<li>最多只能同时较好的满足两个。</li>
<li>CPA理论关注粒度是数据，而不是整体系统设计</li>
<li>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这个三个需求。因此，根据CAP原理将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类：<ul>
<li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强</li>
<li>AP（Eureka） - 满足可用性，分区容错性的系统，通常对一致性的要求较低</li>
<li>CP（zookeeper/consul） - 满足一致性，分区容错性的系统，通常性能不是特别高</li>
</ul>
</li>
</ul>
<h2 id="六，负载均衡服务调用"><a href="#六，负载均衡服务调用" class="headerlink" title="六，负载均衡服务调用"></a>六，负载均衡服务调用</h2><h3 id="1，LB负载均衡（Load-Balance）"><a href="#1，LB负载均衡（Load-Balance）" class="headerlink" title="1，LB负载均衡（Load Balance）"></a>1，LB负载均衡（Load Balance）</h3><h4 id="a-概述："><a href="#a-概述：" class="headerlink" title="a.概述："></a>a.概述：</h4><ul>
<li>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）。常见的负载均衡软件有Nginx,LVS，硬件F5等。</li>
</ul>
<h4 id="b，LB负载均衡的分类："><a href="#b，LB负载均衡的分类：" class="headerlink" title="b，LB负载均衡的分类："></a>b，LB负载均衡的分类：</h4><ul>
<li>集中式LB：即在服务的消费方和提供方之间使用独立的LB实施（可以是硬件，如F5，也可以是软件，如Nginx），由该设施负责把访问请求通过某种策略转发至服务的提供方。</li>
<li>进程内LB：将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些中选择出一个合适的服务器 。Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</li>
</ul>
<h4 id="c，Ribbon本地负载均衡客户端与Nginx服务端负载均衡区别："><a href="#c，Ribbon本地负载均衡客户端与Nginx服务端负载均衡区别：" class="headerlink" title="c，Ribbon本地负载均衡客户端与Nginx服务端负载均衡区别："></a>c，Ribbon本地负载均衡客户端与Nginx服务端负载均衡区别：</h4><ul>
<li>Nginx是服务器负载均衡，客户端所有请求都会交给Nginx，然后由Nginx实现转发请求。即负载均衡是由服务端实现的。</li>
<li>Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。</li>
</ul>
<h3 id="2，Ribbon"><a href="#2，Ribbon" class="headerlink" title="2，Ribbon"></a>2，Ribbon</h3><h4 id="a，概述："><a href="#a，概述：" class="headerlink" title="a，概述："></a>a，概述：</h4><ul>
<li>​    Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。简单地说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</li>
</ul>
<h4 id="b-Ribbon的使用：负载均衡-RestTemplate"><a href="#b-Ribbon的使用：负载均衡-RestTemplate" class="headerlink" title="b,Ribbon的使用：负载均衡+RestTemplate"></a>b,Ribbon的使用：负载均衡+RestTemplate</h4><ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.netflix.ribbon/ribbon --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置config</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写转发请求的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/create"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(Payment payment)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(<span class="string">"http://localhost:8080/payment/create"</span>,payment,CommonResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="c-Ribbon核心组件IRule默认自带的负载规则"><a href="#c-Ribbon核心组件IRule默认自带的负载规则" class="headerlink" title="c,Ribbon核心组件IRule默认自带的负载规则"></a>c,Ribbon核心组件IRule默认自带的负载规则</h4><ul>
<li>RoundRobinRule：轮询</li>
<li>RandomRule：随机</li>
<li>RetryRule：先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务</li>
<li>WeightedResponseTimeRule：对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择</li>
<li>BestAvailableRule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</li>
<li>AvailabilityFilteringRule：先过滤掉故障实例，再选择并发较小的实例</li>
<li>ZoneAvoidanceRule：默认规则，复合判断server所在区域的性能和server的可用性选择服务器。</li>
</ul>
<h4 id="d，如何替换负载规则"><a href="#d，如何替换负载规则" class="headerlink" title="d，如何替换负载规则"></a>d，如何替换负载规则</h4><ul>
<li><p>自定义规则配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下（即启动类同个包及其子包下），否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了。</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();<span class="comment">//定义为随机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动类加注解：@RibbonClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ol<span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//name ：服务名；configuration：规则配置类</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>,configuration=MySelfRule<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">OrderMain80</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(OrderMain80<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="七，服务接口调用"><a href="#七，服务接口调用" class="headerlink" title="七，服务接口调用"></a>七，服务接口调用</h2><h3 id="1，openFeign"><a href="#1，openFeign" class="headerlink" title="1，openFeign"></a>1，openFeign</h3><h4 id="a，概述：-1"><a href="#a，概述：-1" class="headerlink" title="a，概述："></a>a，概述：</h4><ul>
<li>Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。它的使用方法是<strong>定义一个服务接口然后在上面添加注解</strong>。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Fegin可以与Eureka和Ribbon组合使用以支持负载均衡。</li>
</ul>
<h4 id="b-Feign的作用："><a href="#b-Feign的作用：" class="headerlink" title="b,Feign的作用："></a>b,Feign的作用：</h4><ul>
<li>Feign意在使编写Java HTTP客户单变得更加容易。前面在使用Ribbon+RestTemplate时，利用RestTemplate对HTTP请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的是线下，我们只需要创建一个接口并使用注解的方式来配置他（以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可），即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。</li>
<li>Feign集成了Ribbon，利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。</li>
</ul>
<h4 id="c，openfeign服务调用"><a href="#c，openfeign服务调用" class="headerlink" title="c，openfeign服务调用"></a>c，openfeign服务调用</h4><ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-openfeign --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动类上面加注解：@EnableFeignClients</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignMain80</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(OrderFeignMain80<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写接口并加上@FeignClient注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentFeignService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写controller层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/consumer/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="d，openfeign的超时控制"><a href="#d，openfeign的超时控制" class="headerlink" title="d，openfeign的超时控制"></a>d，openfeign的超时控制</h4><ul>
<li><p>默认feign客户端只等待一秒钟，但是服务端处理需要超多1秒钟，导致feign客户端不想等待了，直接返回报错。为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。</p>
</li>
<li><p>可以在yml配置文件中开启</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置feign客户端超时时间（openfeign默认支持ribbon）</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="comment">#指的是建立连接后从服务器读取到可用资源所的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="comment">#指的是建立连接所用的时间，适用于网络状况正常的情况下，两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="e，openfeign的日志打印功能"><a href="#e，openfeign的日志打印功能" class="headerlink" title="e，openfeign的日志打印功能"></a>e，openfeign的日志打印功能</h4><ul>
<li><p>feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解feign中HTTP请求的细节。说白了就是对feign接口的调用情况进行监控和输出。</p>
</li>
<li><p>日志级别：</p>
<ul>
<li>NOEN：默认的，不显示任何日志</li>
<li>BASIC：仅记录请求方法，URL，响应状态码以及执行时间。</li>
<li>HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息。</li>
<li>FULL：除了HEADERS中定义的信息之外，还有请求的响应和正文以及元数据。</li>
</ul>
</li>
<li><p>启动：</p>
<ul>
<li><p>配置日志类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置文件yml中开启日志功能：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment">#feign日志以什么级别监控哪个接口</span></span><br><span class="line">    <span class="attr">com.itfang.www.servicer.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
<h2 id="八，服务降级-熔断-限流"><a href="#八，服务降级-熔断-限流" class="headerlink" title="八，服务降级|熔断|限流"></a>八，服务降级|熔断|限流</h2><h3 id="1，Hystrix"><a href="#1，Hystrix" class="headerlink" title="1，Hystrix"></a>1，Hystrix</h3><h4 id="a，分布式系统面临的问题——服务雪崩："><a href="#a，分布式系统面临的问题——服务雪崩：" class="headerlink" title="a，分布式系统面临的问题——服务雪崩："></a>a，分布式系统面临的问题——服务雪崩：</h4><ul>
<li>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”</li>
<li>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。所以通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。</li>
</ul>
<h4 id="b，概述："><a href="#b，概述：" class="headerlink" title="b，概述："></a>b，概述：</h4><ul>
<li>Hystrix是一个用于处理分布式系统的<strong>延迟</strong>和<strong>容错</strong>的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下，<strong>不会导致整个服务失败，避免级联故障，以提高分布式系统的弹性。</strong></li>
<li>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），<strong>向调用方返回一个符合预期的，可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常</strong>，这样就保证了服务调用方的线程不会被长时间，不必要地占用，从而避免了故障在分布式系统中蔓延，乃至雪崩。</li>
</ul>
<h4 id="c，Hystrix的作用："><a href="#c，Hystrix的作用：" class="headerlink" title="c，Hystrix的作用："></a>c，Hystrix的作用：</h4><ul>
<li>服务降级；</li>
<li>服务熔断；</li>
<li>接近实时的监控；</li>
</ul>
<h4 id="d，三个重要概念"><a href="#d，三个重要概念" class="headerlink" title="d，三个重要概念"></a>d，三个重要概念</h4><ul>
<li><p><strong>服务降级</strong>：</p>
<ul>
<li>服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback；</li>
<li>触发服务降级的情况：<ul>
<li>程序运行异常</li>
<li>超时</li>
<li>服务熔断触发服务降级</li>
<li>线程池/信号量打满也会导致服务降级</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务熔断</strong>：</p>
<ul>
<li>类似保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。</li>
<li>服务降级 –》进而熔断 –》恢复调用链路</li>
</ul>
</li>
<li><p><strong>服务限流</strong></p>
<ul>
<li>秒杀高并发等操作，严禁一蜂窝的拥挤过来，大家排队，一秒钟Nge，有序进行</li>
</ul>
</li>
</ul>
<h4 id="e，服务降级："><a href="#e，服务降级：" class="headerlink" title="e，服务降级："></a>e，服务降级：</h4><ul>
<li><p>解决的要求：</p>
<ul>
<li>超时导致服务器变慢（转圈）——超时不再等待</li>
<li>出错（宕机或程序运行出错）——出错要有兜底</li>
</ul>
</li>
<li><p>解决方式：</p>
<ul>
<li>对方服务（8001）超时了，调用者（80）不能一直卡死等待，必须有服务降级</li>
<li>对方服务（8001）宕机了，调用者（80）不能一直卡死等待，必须有服务降级</li>
<li>对方服务（8001）OK，调用者（80）自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级。</li>
</ul>
</li>
<li><p>服务降级——服务提供者  || 服务消费者</p>
<ul>
<li><p>情景1（服务提供者）：设置自身调用超时时间的峰值，峰值内可以正常运行，超过了必须要有fallback的方法处理，（或者自身程序的运行出错），作服务降级fallback</p>
</li>
<li><p>在启动类上加注解：<strong>@EnableCircuitBreaker</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(PaymentHystrixMain8001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在业务类上加注解：<strong>@HystrixCommand</strong>，并且编写fallback方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@HystrixCommand：一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法</span></span><br><span class="line"><span class="comment">//@HystrixProperty：配置该业务方法的属性；这个业务方法上的注解表示该业务方法的最大响应时间</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod=<span class="string">"paymentInfo_TimeOutHandler"</span>,commandProperties = &#123;<span class="meta">@HystrixProperty</span>(name=<span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value=<span class="string">"3000"</span>)&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> timeNumber = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//int age = 10/0;</span></span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(timeNumber); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"线程池:  "</span>+Thread.currentThread().getName()+<span class="string">" id:  "</span>+id+<span class="string">"\t"</span>+<span class="string">"O(∩_∩)O哈哈~"</span>+<span class="string">"  耗时(秒): "</span>+timeNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"线程池:  "</span>+Thread.currentThread().getName()+<span class="string">"  8001系统繁忙或者运行报错，请稍后再试,id:  "</span>+id+<span class="string">"\t"</span>+<span class="string">"o(╥﹏╥)o"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>情景2（服务消费者）：当自身等待时间小于调用服务提供者的时间，则在自身进行服务降级</p>
</li>
<li><p>在配置文件yml中开启Hystrix</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span> </span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动类上加注解：<strong>@EnableHystrix</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixMain80</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain80<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在接口上面加注解：<strong>@HystrixCommand</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/hystrix/timeout/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentTimeOutFallbackMethod"</span>,commandProperties = &#123;</span><br><span class="line"><span class="meta">@HystrixProperty</span>(name=<span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value=<span class="string">"1500"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeOutFallbackMethod</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>全局的服务降级：</p>
<ul>
<li><p>在controller上面加上：<strong>@DefaultProperties</strong>并指定全局fallback方法；并只在接口上面添加注解：<strong>@HystrixCommand</strong>即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@DefaultProperties</span>(defaultFallback = <span class="string">"payment_Global_FallbackMethod"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystirxController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1，当只是添加 @HystrixCommand注解而不指定具体fallback方法，则使用全局fallback方法</span></span><br><span class="line">    <span class="comment">//2，当添加 @HystrixCommand并指定具体的fallback方法时，则使用具体的fallback方法</span></span><br><span class="line">    <span class="comment">//3, 当不添加 @HystrixCommand时，则不使用任何fallback方法</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面是全局fallback方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">payment_Global_FallbackMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通配的服务降级：</p>
<ul>
<li><p>在服务消费者的调用的服务的业务接口注解<strong>@FeignClient</strong>添加fallback属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PROVIDER-HYSTRIX-PAYMENT"</span> ,fallback = PaymentFallbackService<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">PaymentHystrixService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/hystrix/ok/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/hystrix/timeout/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个业务实现类继承业务接口，在其中重写调用服务的业务接口的实现，该实现就是fallback方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentHystrixService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-----PaymentFallbackService fall back-paymentInfo_OK ,o(╥﹏╥)o"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-----PaymentFallbackService fall back-paymentInfo_TimeOut ,o(╥﹏╥)o"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h4 id="f，服务熔断"><a href="#f，服务熔断" class="headerlink" title="f，服务熔断"></a>f，服务熔断</h4><ul>
<li><p>概述：</p>
<ul>
<li>熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。<strong>当检测到该节点微服务调用响应正常后，恢复调用链路。</strong></li>
<li><strong>服务降级 –》进而熔断 –》恢复调用链路</strong></li>
<li>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解时@HystrixCommand</li>
</ul>
</li>
<li><p>服务熔断——服务提供者：</p>
<ul>
<li>在业务方法上面加注解<strong>@HystrixCommand</strong>并在该注解里面配置几个属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=====服务熔断</span></span><br><span class="line"><span class="comment">//快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒</span></span><br><span class="line"><span class="comment">//请求总数阈值：在快照时间窗内，必须满足请求总数阈值才有资格熔断。默认为20，意味在10秒内，如果该hystirx命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开</span></span><br><span class="line"><span class="comment">//错误百分比阈值：当请求总数在快照时间窗内超过了阈值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阈值情况下，这时候就会将断路器打开</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentCircuitBreaker_fallback"</span>,commandProperties = &#123;</span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.enabled"</span>,value = <span class="string">"true"</span>),<span class="comment">// 是否开启断路器</span></span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.requestVolumeThreshold"</span>,value = <span class="string">"10"</span>),<span class="comment">// 请求总数阈值</span></span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.sleepWindowInMilliseconds"</span>,value = <span class="string">"10000"</span>), <span class="comment">// 快照时间窗</span></span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.errorThresholdPercentage"</span>,value = <span class="string">"60"</span>),<span class="comment">// 错误百分比阈值</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(id &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"******id 不能负数"</span>);</span><br><span class="line">&#125;</span><br><span class="line">String serialNumber = IdUtil.simpleUUID();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">"\t"</span>+<span class="string">"调用成功，流水号: "</span> + serialNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker_fallback</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: "</span> +id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hystrix配置属性的扩展：</p>
<ul>
<li>strategy：设置隔离策略，THREAD表示线程池；SEMAPHORE；信号池隔离</li>
<li>maxConcurrentRequests：当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发量）</li>
<li>timeoutinMilliseconds：配置命令执行的超时时间</li>
<li>enabled：是否启用超时时间</li>
<li>interruptOnTimeout：执行超时的时候是否中断</li>
<li>interruptOnCancel：执行被取消的时候是否中断</li>
<li>maxConcurrentRequests：允许回调方法执行的最大并发数</li>
<li>fallback.enabled：服务降级是否启用，是否执行回调函数</li>
<li>circuitBreaker.enabled：是否启用断路器</li>
<li>circuitBreaker.requestVolumeThreshold：如果滚动时间窗（默认10秒）内仅收到了19个请求，即使这19个请求都失败了，断路器也不会打开</li>
<li>circuitBreaker.errorThresholdPercentage：该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过circuitBreaker.requestVolumeThreshold的情况下，如果错误请求数的百分比超过50，就把断路器设置为“打开”状态，否则就设置为“关闭“状态</li>
<li>circuitBreaker.sleepWindowinMilliseconds：该属性用来设置当断路器打开之后的休眠时间窗。休眠时间窗结束之后，会将断路器置为‘半开’状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为“打开”状态，如果成功就设置为“关闭”状态</li>
<li>circuitBreaker.forceOpen：断路器强制打开</li>
<li>circuitBreaker.forceClosed：断路器强制关闭</li>
<li>metrics.rollingStats.timeinMilliseconds：滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间</li>
<li>metrics.rollingStats.numBuckets：该属性用来设置滚动时间窗统计指标信息时划分“桶”的数量，断路器在收集指标信息的时候会根据设置的时间窗长度拆分成多个“桶”来累计各度量值，每个‘桶’记录了一段时间内的采集指标，比如10秒内拆分成10个”桶”收集这样，所以timeMilliseconds必须能被numBuckets整除。否则会抛异常</li>
<li>metrics.rollingPercentile.enabled：该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为false，那么所有的概要统计都将返回-1</li>
</ul>
</li>
<li><p><img src="/2021/01/20/SpringCloud/9.png" alt="image-20210126193442596"></p>
<ul>
<li><strong>熔断打开</strong>：请求不再进行调用当前服务，内部设置时钟一般为MTTR（平均故障处理时间），当打开时长达到所设时钟则进入半熔断状态</li>
<li><strong>熔断关闭</strong>：熔断关闭不会对服务进行熔断</li>
<li><strong>熔断半开</strong>：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭容熔断</li>
</ul>
</li>
</ul>
<h4 id="g，服务监控"><a href="#g，服务监控" class="headerlink" title="g，服务监控"></a>g，服务监控</h4><ul>
<li><p>概述：除了隔离依赖服务的调用以外，hystrix还提供了准实时的调用监控（hystrix dashboard），hystrix会持续地记录所有桶过hystrix发起的请求的执行信息，并以统计报表 和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。</p>
</li>
<li><p>启动：</p>
<ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-hystrix-dashboard --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动类上加注解：<strong>@EnableHystrixDashboard</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardMain9001</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(HystrixDashboardMain9001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在被监控的微服务的启动类中加配置（springcloud升级后的版本）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(PaymentHystrixMain8001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment">     *ServletRegistrationBean因为springboot的默认路径不是"/hystrix.stream"，</span></span><br><span class="line"><span class="comment">     *只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">        ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">"/hystrix.stream"</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">"HystrixMetricsStreamServlet"</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>流量图形说明</p>
<p><img src="/2021/01/20/SpringCloud/11.png" alt="image-20210127233043118"></p>
<p><img src="/2021/01/20/SpringCloud/10.png" alt="image-20210127232959541"></p>
</li>
</ul>
</li>
</ul>
<h2 id="九，微服务网关"><a href="#九，微服务网关" class="headerlink" title="九，微服务网关"></a>九，微服务网关</h2><h3 id="1，GateWay"><a href="#1，GateWay" class="headerlink" title="1，GateWay"></a>1，GateWay</h3><h4 id="a，概述：-2"><a href="#a，概述：-2" class="headerlink" title="a，概述："></a>a，概述：</h4><ul>
<li>SpringCloud GateWay是SpringCloud的一个全新项目，基于spring5.0+spring boot2.0和project reactor等技术开发的网关，它意在为微服务架构提供一种简单有效的统一的API路由管理方式</li>
<li>springCloud GateWay作为springcloud生态系统中的网关，目标是替代Zuul，在springcloud2.0以上版本中，没有对新版本的zuul2.0以上最新高性能版本进行集成，仍然还是使用zuul1.x非reactor模式的老版本。而为了提升网关的性能，<strong>springcloud GateWay是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的reactor模式通信框架netty</strong></li>
<li>springcloud GateWay的目标提供同一的路由方式且基于filter链方式提供了网关基本的功能，例如：安全，监控/指标，和限流。</li>
</ul>
<h4 id="b，作用："><a href="#b，作用：" class="headerlink" title="b，作用："></a>b，作用：</h4><ul>
<li>反向代理</li>
<li>鉴权</li>
<li>流量控制</li>
<li>熔断</li>
<li>日志监控</li>
</ul>
<h4 id="c，springcloud的特性："><a href="#c，springcloud的特性：" class="headerlink" title="c，springcloud的特性："></a>c，springcloud的特性：</h4><ul>
<li>基于springFramework 5，Project Reactor和springboot2.0进行构建</li>
<li>动态路由：能够匹配任何请求属性；</li>
<li>可以对路由指定predicate（断言）和filter（过滤器）</li>
<li>集成hystrix的断路器功能</li>
<li>集成springcloud服务发现功能</li>
<li>易于编写的predicate（断言）和filter（过滤器）</li>
<li>请求限流功能</li>
<li>支持路径重写</li>
</ul>
<h4 id="d，springcloud-gateway和zuul的区别："><a href="#d，springcloud-gateway和zuul的区别：" class="headerlink" title="d，springcloud gateway和zuul的区别："></a>d，springcloud gateway和zuul的区别：</h4><ul>
<li>zuul1.x是一个基于阻塞I/O的API gateway</li>
<li>zuul1.x基于servlet2.5使用阻塞架构，它不支持任何长连接（如webSocket）zuul的设计模式和Nginx较像，每次I/O操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx是用C++实现，zuul用Java实现，而jvm本身会有第一次加载较慢的情况，使得zuul的性能相对较差。</li>
<li>springcloud gateway建立在springframework5，project reactor和Springboot2之上，使用异步非阻塞API</li>
<li>springcloud gateway还支持webSocket，并且与spring紧密集成拥有更好的开发体验。</li>
</ul>
<h4 id="e，springcloud-gateway的非阻塞异步模型说明"><a href="#e，springcloud-gateway的非阻塞异步模型说明" class="headerlink" title="e，springcloud gateway的非阻塞异步模型说明"></a>e，springcloud gateway的非阻塞异步模型说明</h4><ul>
<li>传统的web框架，比如说：Struts2，springMVC等都是基于servlet API与servlet容器基础之上运行的但是在servlet3.1之后有了异步非阻塞的支持。而WebFlux是一个典型非阻塞异步的框架，它的核心是基于reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如netty，undertow以及支持servlet3.1的容器上。非阻塞式+函数式编程（spring5必须让你使用Java8）</li>
<li>spring webFlux是spring5.0引入的新的响应式框架，区别于springMVC，它不需要依赖servlet API，它是完全异步非阻塞的，并且基于reactor来实现响应式流规范。</li>
</ul>
<h4 id="f，三个核心概念："><a href="#f，三个核心概念：" class="headerlink" title="f，三个核心概念："></a>f，三个核心概念：</h4><ul>
<li>route（路由）：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true，则匹配该路由</li>
<li>predicate（断言）：参考Java8的Predicate，开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由</li>
<li>filter（过滤）：指的是spring框架中GateWayFilter实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改</li>
</ul>
<h4 id="g，springGateWay的工作流程"><a href="#g，springGateWay的工作流程" class="headerlink" title="g，springGateWay的工作流程"></a>g，springGateWay的工作流程</h4><ul>
<li>客户端想springCloudGateway发出请求，然后在Gateway Handler Mapping中找到与请求相匹配的路由，将其发送到Gateway Web Handler</li>
<li>Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回，过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（pre）或之后（post）执行业务逻辑</li>
<li>Filter在“pre”类型的过滤器可以做参数校验，权限校验，流量监控，日志输出，协议转换等，在“post”类型的过滤器中可以做响应内容，响应头的修改，日志的输出，流量监控等有着非常重要的作用。</li>
</ul>
<h4 id="h，配置网关微服务"><a href="#h，配置网关微服务" class="headerlink" title="h，配置网关微服务"></a>h，配置网关微服务</h4><ul>
<li><p>pom.xml：比之前的微服务要移除web和actuator坐标</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-gateway --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>          <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>          <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#服务提供者provider注册进eureka服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>或不用yml配置，通过config编写配置类配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GateWayConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder routeLocatorBuilder)</span></span>&#123;</span><br><span class="line">        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> routes.route(<span class="string">"path_route_atguigu"</span>,</span><br><span class="line">                r -&gt; r.path(<span class="string">"/guonei"</span>)</span><br><span class="line">                        .uri(<span class="string">"http://news.baidu.com/guonei"</span>)).build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="i，配置动态路由"><a href="#i，配置动态路由" class="headerlink" title="i，配置动态路由"></a>i，配置动态路由</h4><ul>
<li><p>默认情况下，Gateway会根据注册中心注册的服务列表，以注册中心上微服务名我路径创建动态路由进行转发，从而实现动态路由的功能。</p>
</li>
<li><p>application.yml：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="j，springcloud的断言（predicate）"><a href="#j，springcloud的断言（predicate）" class="headerlink" title="j，springcloud的断言（predicate）"></a>j，springcloud的断言（predicate）</h4><ul>
<li>概述：<ul>
<li>springcloud Gateway将路由匹配作为SpringWebFlux HandlerMapping基础架构的一部分。springcloud Gateway包括许多内置的route predicate工厂。所有这些predicate都与HTTP请去的不同属性匹配。多个route  predicate工厂可以进行组合。</li>
<li>springcloud Gateway创建route对象时，使用RoutePredicateFactory创建Predicate对象，Predicate对象可以赋值给Route。springcloud Gateway包含许多内置的RoutePredicateFactories。</li>
<li>所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and。</li>
</ul>
</li>
<li>种类：<ul>
<li>After Route Predicate</li>
<li>Before Route Predicate</li>
<li>Between Route Predicate</li>
<li>Cookie Route Predicate</li>
<li>Header Route Predicate</li>
<li>Host Route Predicate</li>
<li>Method Route Predicate</li>
<li>Path Route Predicate</li>
<li>Query Route Predicate</li>
</ul>
</li>
</ul>
<h4 id="k，springcloud的过滤器（Filter）"><a href="#k，springcloud的过滤器（Filter）" class="headerlink" title="k，springcloud的过滤器（Filter）"></a>k，springcloud的过滤器（Filter）</h4><ul>
<li><p>概述：</p>
<ul>
<li>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用</li>
<li>springcloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生。</li>
</ul>
</li>
<li><p>常见类型的过滤器：自行查看官网</p>
</li>
<li><p>自定义全局过滤器：</p>
<ul>
<li><p>作用：</p>
<ul>
<li>全局日志记录</li>
<li>统一网关鉴权 </li>
</ul>
</li>
<li><p>编写过滤器类并继承GlobalFilter，Ordered接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>,<span class="title">Ordered</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//过滤器拦截后进行拦截判断</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        log.info(<span class="string">"***********come in MyLogGateWayFilter:  "</span>+<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">"uname"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uname == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log.info(<span class="string">"*******用户名为null，非法用户，o(╥﹏╥)o"</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果通过拦截判断，则将exchange传递到过滤器链中的下一个过滤器</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置该过滤器在过滤器链中的优先级</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
<h2 id="十，分布式配置中心"><a href="#十，分布式配置中心" class="headerlink" title="十，分布式配置中心"></a>十，分布式配置中心</h2><h3 id="1，config"><a href="#1，config" class="headerlink" title="1，config"></a>1，config</h3><h4 id="a，概述"><a href="#a，概述" class="headerlink" title="a，概述"></a>a，概述</h4><ul>
<li>springcloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。</li>
<li>springcloud  Config分为服务端和客户端两部分<ul>
<li>服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口</li>
<li>客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息服务器默认采用Git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。</li>
</ul>
</li>
</ul>
<h4 id="b，作用：-1"><a href="#b，作用：-1" class="headerlink" title="b，作用："></a>b，作用：</h4><ul>
<li>集中管理配置文件</li>
<li>不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release</li>
<li>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</li>
<li>当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置</li>
<li>将配置信息以REST接口的形式暴露</li>
</ul>
<h4 id="c，配置服务端配置控制中心"><a href="#c，配置服务端配置控制中心" class="headerlink" title="c，配置服务端配置控制中心"></a>c，配置服务端配置控制中心</h4><ul>
<li><p>将所有微服务的配置文件放到Git仓库中</p>
</li>
<li><p>pom.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-config-server --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span>  <span class="string">cloud-config-center</span> <span class="comment">#注册进Eureka服务器的微服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@github.com:itfang/springcloud-config.git</span> <span class="comment">#GitHub上面的git仓库名字</span></span><br><span class="line">        <span class="comment">####搜索目录</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">      <span class="comment">####读取分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动类上加注解：<strong>@EnableConfigServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterMain3344</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(ConfigCenterMain3344<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="d，配置读取规则"><a href="#d，配置读取规则" class="headerlink" title="d，配置读取规则"></a>d，配置读取规则</h4><ul>
<li><p>/{application}/{profile}[/{label}]</p>
</li>
<li><p>/{application}-{profile}.yml</p>
</li>
<li><p>/{label}/{application}-{profile}.yml</p>
</li>
<li><p>/{application}-{profile}.properties</p>
</li>
<li><p>/{label}/{application}-{profile}.properties</p>
<p>例如：<a href="http://localhost:3344/master/config-dev.yml" target="_blank" rel="noopener">http://localhost:3344/master/config-dev.yml</a></p>
</li>
</ul>
<h4 id="e，bootstrap-yml"><a href="#e，bootstrap-yml" class="headerlink" title="e，bootstrap.yml"></a>e，bootstrap.yml</h4><ul>
<li>概述：<ul>
<li>application.yml是用户级的资源配置项；bootstrap.yml是系统级的，优先级更高</li>
<li>springcloud会创建一个”Bootstrap Context”，作为Spring应用的”Application Context”的父上下文。初始化的时候，”Bootstrap Context”负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的“Environment”</li>
<li>“Bootsrap”属性有高优先级，默认情况下，它们不会被本地配置覆盖。“Bootstrap Context”和“Applicaiton Context”有着不同的约定，所以新增了一个“bootstrap.yml”文件，保证“Bootstrap Context”和“Applicaiton Context“配置的分离</li>
<li>要将Client模块下的application.yml文件改为bootstrap.yml这是很关键的，因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml</li>
</ul>
</li>
</ul>
<h4 id="f，配置客户端配置控制中心"><a href="#f，配置客户端配置控制中心" class="headerlink" title="f，配置客户端配置控制中心"></a>f，配置客户端配置控制中心</h4><ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-config --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bootstrap.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://localhost:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在主启动类上加注解：<strong>@EnableConfigServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientMain3355</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(ConfigClientMain3355<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在controller暴露接口供用户访问配置文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.info&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/configInfo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h4 id="g，config动态刷新（根据上面环境进行修改）"><a href="#g，config动态刷新（根据上面环境进行修改）" class="headerlink" title="g，config动态刷新（根据上面环境进行修改）"></a>g，config动态刷新（根据上面环境进行修改）</h4><ul>
<li><p>pom.xml：添加actuator和web的坐标</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuator --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改yml文件，暴露监控接口</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在controller层添加注解：<strong>@RefreshScope</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.info&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/configInfo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="十一，消息总线"><a href="#十一，消息总线" class="headerlink" title="十一，消息总线"></a>十一，消息总线</h2><h3 id="1，Bus"><a href="#1，Bus" class="headerlink" title="1，Bus"></a>1，Bus</h3><h4 id="a，概述：-3"><a href="#a，概述：-3" class="headerlink" title="a，概述："></a>a，概述：</h4><ul>
<li><p>在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个公用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。</p>
</li>
<li><p>springcloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的时间处理机制和消息中间件的功能。springcloud Bus目前支持rabbitMQ和Kafka</p>
</li>
</ul>
<h4 id="b，作用：-2"><a href="#b，作用：-2" class="headerlink" title="b，作用："></a>b，作用：</h4><ul>
<li><p>springcloud Bud能管理和传播分布式系统间的消息，就像一个分布式执行器，可以用于广播状态更改，事件推送等，也可以当作微服务键的通信通道。</p>
</li>
<li><p>springcloud Bus配合springcloud Config使用可以实现配置的动态刷新；ConfigClient实例都监听MQ中同一个topic（默认是springcloud Bus），当一个服务刷新数据的时候，他会把这个消息放入到topic中，这样其他监听同一个topic的服务就能得到通知，然后去更新自身的配置。</p>
<p><img src="/2021/01/20/SpringCloud/13.png" alt="image-20210131113346254"></p>
</li>
</ul>
<h4 id="c，消息总线的设计思想"><a href="#c，消息总线的设计思想" class="headerlink" title="c，消息总线的设计思想"></a>c，消息总线的设计思想</h4><ul>
<li><p>利用消息总线触发一个客户端/bus/refresh，而刷新所有客户端的配置</p>
<ul>
<li>相比下面方法，这个方法不适合：<ul>
<li>打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。</li>
<li>破坏了微服务各节点的对等性。</li>
<li>有一定的局限性。例如：微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。</li>
</ul>
</li>
</ul>
<p><img src="/2021/01/20/SpringCloud/14.png" alt="image-20210131114630476"></p>
</li>
<li><p>利用消息总线触发一服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置</p>
<p><img src="/2021/01/20/SpringCloud/15.png" alt="image-20210131114841034"></p>
</li>
</ul>
<h4 id="d，配置Bus动态刷新全局广播"><a href="#d，配置Bus动态刷新全局广播" class="headerlink" title="d，配置Bus动态刷新全局广播"></a>d，配置Bus动态刷新全局广播</h4><ul>
<li><p>pom.xml（配置控制中心）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-bus-amqp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml（配置控制中心）：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rabbitmq相关配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">##rabbitmq相关配置,暴露bus刷新配置的端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span> <span class="comment">#暴露bus刷新配置的端点</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'bus-refresh'</span></span><br></pre></td></tr></table></figure>




</li>
</ul>
<h4 id="e，动态刷新定点通知"><a href="#e，动态刷新定点通知" class="headerlink" title="e，动态刷新定点通知"></a>e，动态刷新定点通知</h4><ul>
<li><p>指定具体某一个实例生效而不是全部</p>
</li>
<li><p>公式：<a href="http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}">http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}</a></p>
</li>
<li><p>/bus/refresh请求不再发送到具体的服务实例上，而是发给config server并通过destination参数类指定需要更新配置的服务或实例。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST &quot;http:&#x2F;&#x2F;localhost:3344&#x2F;actuator&#x2F;bus-refresh&#x2F;config-client:3355&quot;</span><br></pre></td></tr></table></figure>







<h2 id="十二，消息驱动"><a href="#十二，消息驱动" class="headerlink" title="十二，消息驱动"></a>十二，消息驱动</h2><h3 id="1，Stream"><a href="#1，Stream" class="headerlink" title="1，Stream"></a>1，Stream</h3><h4 id="a，概述：-4"><a href="#a，概述：-4" class="headerlink" title="a，概述："></a>a，概述：</h4><ul>
<li>屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型</li>
<li>官方定义springcloud Stream是一个构建消息驱动微服务的框架，应用程序通过inputs或者outputs来与Springcloud Stream中binder对象交互通过我们配置来bingding（绑定），而Springcloud Stream的binder对象负责与消息中间件交互。所以我只需要搞清楚如何与Springcloud Stream交互就可以方便使用消息驱动的方式</li>
<li>通过使用Spring Intergration来连接消息代理中间件以实现消息事件驱动。Springcloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅，消费组，分区的三个核心概念。</li>
<li>目前仅支持RabbitMQ，Kafka。</li>
</ul>
<h4 id="b，设计思想"><a href="#b，设计思想" class="headerlink" title="b，设计思想"></a>b，设计思想</h4><ul>
<li><p>在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行消息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性，通过定义绑定器作为中间层，完美地实现了<strong>应用程序域消息中间件细节之间的隔离</strong>。通过向应用程序暴露同意的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。<strong>通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。</strong></p>
</li>
<li><p>Stream中的消息通信方式遵循了发布-订阅模式</p>
<p><img src="/2021/01/20/SpringCloud/16.png" alt="image-20210201222153101"></p>
</li>
<li><p>Binder：很方便的连接中间件，屏蔽差异</p>
</li>
<li><p>Channel：通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置</p>
</li>
<li><p>Source/Sink：简单的可理解为参照对象时Springcloud Stream自身，从Stream发布消息就是输出，接收消息就是输入。</p>
<p><img src="/2021/01/20/SpringCloud/18.png" alt="image-20210201231119726"></p>
</li>
</ul>
<h4 id="c，Stream常用的编码和注解："><a href="#c，Stream常用的编码和注解：" class="headerlink" title="c，Stream常用的编码和注解："></a>c，Stream常用的编码和注解：</h4><p><img src="/2021/01/20/SpringCloud/17.png" alt="image-20210201230130126"></p>
<h4 id="d，配置消息驱动生产者"><a href="#d，配置消息驱动生产者" class="headerlink" title="d，配置消息驱动生产者"></a>d，配置消息驱动生产者</h4><ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-stream-rabbit --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">      <span class="attr">stream:</span></span><br><span class="line">        <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">          <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">            <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">              <span class="attr">spring:</span></span><br><span class="line">                <span class="attr">rabbitmq:</span></span><br><span class="line">                  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                  <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                  <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                  <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">        <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">          <span class="attr">output:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">            <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">            <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">            <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写发送消息到rabbitMQ的业务类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Source<span class="class">.<span class="keyword">class</span>) //定义消息的推送管道</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MessageProviderImpl</span> <span class="keyword">implements</span> <span class="title">IMessageProvider</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output; <span class="comment">// 消息发送管道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String serial = UUID.randomUUID().toString();</span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        System.out.println(<span class="string">"*****serial: "</span>+serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写调用业务类的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IMessageProvider messageProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/sendMessage"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageProvider.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="e，配置消息驱动消费者"><a href="#e，配置消息驱动消费者" class="headerlink" title="e，配置消息驱动消费者"></a>e，配置消息驱动消费者</h4><ul>
<li><p>pom.xml：跟生产者一致</p>
</li>
<li><p>application.yml：将生产者output改为inputs</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">bindings:</span></span><br><span class="line">      <span class="attr">input:</span> </span><br><span class="line">      	<span class="string">...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写接收消息的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@EnableBinding</span>(Sink<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ReceiveMessageListenerController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Message&lt;String&gt; message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者1号,-----&gt;接受到的消息: "</span>+message.getPayload()+<span class="string">"\t  port: "</span>+serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="f，消息重复消费："><a href="#f，消息重复消费：" class="headerlink" title="f，消息重复消费："></a>f，消息重复消费：</h4><ul>
<li>比如在如下场景下，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时别两个服务获取到，那么就会造成数据错误，我得避免这种情况。这时我们就可以使用Stream中的消息分组来解决</li>
<li>注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。<strong>不同组是可以全面消费的（重复消费）；同一组内会发生竞争关系，只有其中一个可以消费。</strong></li>
</ul>
<h4 id="g，消费者分组："><a href="#g，消费者分组：" class="headerlink" title="g，消费者分组："></a>g，消费者分组：</h4><ul>
<li><p>原理：微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。<strong>不同的组是可以消费的，同一个组会发生竞争关系，只有其中一个可以消费。</strong></p>
</li>
<li><p>修改消费者的配置文件yml实现自定义：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">bindings:</span></span><br><span class="line">      <span class="attr">input:</span> </span><br><span class="line">      	<span class="attr">group:</span> <span class="string">consumerA</span></span><br><span class="line">      	<span class="string">...</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="十三，分布式请求链路跟踪"><a href="#十三，分布式请求链路跟踪" class="headerlink" title="十三，分布式请求链路跟踪"></a>十三，分布式请求链路跟踪</h2><h3 id="1，Sleuth"><a href="#1，Sleuth" class="headerlink" title="1，Sleuth"></a>1，Sleuth</h3><h4 id="a，概述：-5"><a href="#a，概述：-5" class="headerlink" title="a，概述："></a>a，概述：</h4><ul>
<li>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协调产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。</li>
<li>Springcloud Sleuth提供了一套完整的服务跟踪的解决方案，在分布式系统中提供了追踪解决方案并且兼容支持了zipkin。</li>
</ul>
<h4 id="b，几个相关术语："><a href="#b，几个相关术语：" class="headerlink" title="b，几个相关术语："></a>b，几个相关术语：</h4><ul>
<li><p>完整的调用链路：表示一请求链路，一条链路通过Trace Id唯一标识，Span标识发起的请求信息，各Span通过parent Id关联起来。</p>
<ul>
<li>Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识</li>
<li>Span：表示调用链路来源，通俗的理解span就是一次请求信息</li>
</ul>
<p><img src="/2021/01/20/SpringCloud/19.png" alt="image-20210202000705768"></p>
</li>
</ul>
<h4 id="c，环境搭建："><a href="#c，环境搭建：" class="headerlink" title="c，环境搭建："></a>c，环境搭建：</h4><ul>
<li><p>下载zipkin的jar并通过java -jar的命令运行zipkin-server，并通过<a href="http://localhost:9411/zipkin访问" target="_blank" rel="noopener">http://localhost:9411/zipkin访问</a></p>
</li>
<li><p>服务提供者：</p>
<ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zipkin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">  	<span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">    <span class="comment">#采样率值介于0到1之间，1则表示全部采集,一般使用0.5就够了</span></span><br><span class="line">    <span class="attr">probability:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>controller：随便一个接口供服务消费者调用即可</p>
</li>
</ul>
</li>
<li><p>服务消费者：跟服务提供者的配置完全一致，只需要提供个接口去调用服务提供者的接口即可</p>
</li>
</ul>
<h2 id="十四，SpringCloud-Alibaba"><a href="#十四，SpringCloud-Alibaba" class="headerlink" title="十四，SpringCloud Alibaba"></a>十四，SpringCloud Alibaba</h2><h3 id="1，概述："><a href="#1，概述：" class="headerlink" title="1，概述："></a>1，概述：</h3><ul>
<li>springcloud for Alibaba，它是由一些阿里巴巴的开源组件和云产品组成的。这个项目的目的是为了让大家所熟知的Spring框架，其优秀的设计模式和抽象概念，以给使用阿里巴巴产品的Java开发者带来使用spring boot和springcloud的更多便利</li>
<li>springcloud Alibaba 致力于提供微服务开发的一站式解决方法，此项目包开发分布式应用微服务的必需组件，方便开发者通过springcloud编程模型轻松使用这些组件来开发分布式应用服务。</li>
<li>依托springcloud Alibaba ，您只需要添加一些注解和少量配置，就可以将springcloud应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</li>
</ul>
<h3 id="2，作用："><a href="#2，作用：" class="headerlink" title="2，作用："></a>2，作用：</h3><ul>
<li><strong>服务限流降级</strong>：默认支持servlet,Feign,RestTemplate,Dubbo和RocketMQ限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级Metrics监控</li>
<li><strong>服务注册与发现</strong>：适配Springcloud 服务注册与发现标准，默认集成了ribbon的支持</li>
<li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新</li>
<li><strong>消息驱动能力</strong>：基于springcloud stream为微服务应用构建消息驱动能力</li>
<li><strong>阿里云对象存储</strong>：阿里云提供的海量，安全，低成本，高可靠的云存储服务，支持在任何应用，任何时间，任何地点存储和访问任意类型的数据。</li>
<li><strong>分布式任务调度</strong>：提供秒级，精准，高可靠，高可用的定时（基于Cron表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有worker（scheduler-client）上执行。</li>
</ul>
<h3 id="3，产品："><a href="#3，产品：" class="headerlink" title="3，产品："></a>3，产品：</h3><ul>
<li><strong>Sentinel</strong>：阿里巴巴开源产品，把流量作为切入点，从流量控制，熔断降级，系统负载保护等多个维度保护服务的稳定性。</li>
<li><strong>Nacos</strong>：阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现，配置管理和服务管理平台。</li>
<li><strong>RocketMQ</strong>：Apache RocketMQ基于Java高性能，高吞吐量的分布式消息和流计算平台</li>
<li><strong>Dubbo</strong>：Apache Dubbo：是一款高性能Java RPC框架</li>
<li><strong>Seata</strong>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li>
<li><strong>Alibaba Cloud OSS</strong>：阿里云对象存储服务（Object Storage Service，简称OSS），是阿里云提供的海量，安全，低成本，高可靠的云存储服务。您可以在任何应用，任何时间，任何地点存储和访问任意类型的数据。</li>
<li><strong>Alibaba Cloud ScheduleX</strong>：阿里中间件团队开发的一款分布式任务调度产品，支持周期性的任务与固定时间点触发任务。</li>
</ul>
<h3 id="4，Nacos——服务注册和配置中心："><a href="#4，Nacos——服务注册和配置中心：" class="headerlink" title="4，Nacos——服务注册和配置中心："></a>4，Nacos——服务注册和配置中心：</h3><h4 id="a，环境搭建："><a href="#a，环境搭建：" class="headerlink" title="a，环境搭建："></a>a，环境搭建：</h4><ul>
<li>从官网下载nacos的tar包并解压</li>
<li>在bin目录下运行startup.sh</li>
<li>运行成功后直接访问<a href="http://localhost:8848/nacos，默认账号密码都是nacos" target="_blank" rel="noopener">http://localhost:8848/nacos，默认账号密码都是nacos</a></li>
</ul>
<h4 id="b，配置服务提供者"><a href="#b，配置服务提供者" class="headerlink" title="b，配置服务提供者"></a>b，配置服务提供者</h4><ul>
<li><p>父pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自身pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置Nacos地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain9001</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(PaymentMain9001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写提供服务的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/payment/nacos/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPayment</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"nacos registry, serverPort: "</span>+ serverPort+<span class="string">"\t id"</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h4 id="c，配置服务消费者"><a href="#c，配置服务消费者" class="headerlink" title="c，配置服务消费者"></a>c，配置服务消费者</h4><ul>
<li><p>​    pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml’</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosMain83</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain83<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注入RestTemplate依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写消费者接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;service-url.nacos-user-service&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverURL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/consumer/payment/nacos/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(serverURL+<span class="string">"/payment/nacos/"</span>+id,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="d，nacos和其他服务注册中心的对比"><a href="#d，nacos和其他服务注册中心的对比" class="headerlink" title="d，nacos和其他服务注册中心的对比"></a>d，nacos和其他服务注册中心的对比</h4><p><img src="/2021/01/20/SpringCloud/20.png" alt="image-20210215092814637"></p>
<h4 id="e，nacos支持CP和AP的切换"><a href="#e，nacos支持CP和AP的切换" class="headerlink" title="e，nacos支持CP和AP的切换"></a>e，nacos支持CP和AP的切换</h4><ul>
<li><p>C：强一致性，是所有节点在同一试驾看到的数据是一致的</p>
</li>
<li><p>A：可用性，是所有的请求都会收到响应</p>
</li>
<li><p>P：分区容错性性</p>
</li>
<li><p><strong>何时选择使用何种模式</strong>：</p>
<ul>
<li>如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如Spring cloud和Dubbo服务，都适用于AP模式，AP模式为了服务的可能性而减弱了一致性 ，因此AP模式下只支持服务临时实例。</li>
<li>如果需要在服务级别编辑或者存储配置信息，那么CP是必须，K8s服务和DNS服务则适用于CP模式。CP模式下则支持服务持久化实例，此时则是以Raft协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。</li>
</ul>
</li>
<li><p><strong>CP和AP的切换</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT &#39;$NACOS_SERVER:8848&#x2F;nacos&#x2F;v1&#x2F;ns&#x2F;operator&#x2F;switches?entry&#x3D;serverMode&amp;value&#x3D;CP&#39;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h3 id="5，Nacos——服务配置中心："><a href="#5，Nacos——服务配置中心：" class="headerlink" title="5，Nacos——服务配置中心："></a>5，Nacos——服务配置中心：</h3><h4 id="a，nacos的匹配规则"><a href="#a，nacos的匹配规则" class="headerlink" title="a，nacos的匹配规则"></a>a，nacos的匹配规则</h4><ul>
<li><p>nacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>prefix：默认我spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix</li>
<li>spring.profile.active：即为当前环境对应的profile；注意：当spring.profile.active为空时，对应的连接符 - 也将不存在，dataId的拼接格式变成${prefix}.${file-extension}</li>
<li>file-extension：为配置内容的数据格式，可以通过配置项spring.cloud.nacos.config.file-extension来配置。目前只支持properties和yaml类型；</li>
</ul>
</li>
</ul>
<h4 id="b，基础配置"><a href="#b，基础配置" class="headerlink" title="b，基础配置"></a>b，基础配置</h4><ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-config --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bootstrap.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># nacos-config-client-dev.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nacos-config-client-test.yaml   ----&gt; config.info</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosConfigClientMain3377</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NacosConfigClientMain3377<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取配置文件的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//支持Nacos的动态刷新功能。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.info&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/config/info"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据上述的nacos的匹配规则，在nacos服务注册中心页面中的配置列表中添加dataid为上述匹配规则格式的名称的配置中心，如：nacos-config-client-dev.yaml</p>
</li>
</ul>
<h4 id="c，分类配置"><a href="#c，分类配置" class="headerlink" title="c，分类配置"></a>c，分类配置</h4><ul>
<li><p>Namespace+Group+DataID</p>
<ul>
<li><p>类似Java里面的package名和类名，最外层的namespace是可以用于区分部署环境的，Group和DateID逻辑上区分两个目标对象</p>
</li>
<li><p>三者关系：</p>
<p><img src="/2021/01/20/SpringCloud/21.png" alt="image-20210216115716895"></p>
<blockquote>
<p>Nacos默认的命名空格是public，Namespace主要用来实现隔离。比方说我们现在由三个环境：开发，测试，生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。</p>
<p>Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去</p>
<p>Service就是微服务；一个Service可以包含多个Cluster（集群），Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分；比方说为了容灾，将Service微服务分别部署在杭州机房和广州机房，这时就可以给杭州机房的Service微服务起一个集群名称（HZ），给广州机房的Service微服务起一个集群名称（GZ），还可以尽量让同一个机房的微服务互相调用，以提升性能。</p>
<p>最后就是Instance，就是微服务的实例。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>默认情况：</p>
<ul>
<li>NameSpace=public，Group=DEFAULT_GROUP，默认Cluster是DEFAULT</li>
</ul>
</li>
</ul>
<ul>
<li><p>DataID方案：</p>
<ul>
<li><p>在nacos配置中心添加两个的DataID：nacos-config-client-test.yaml；nacos-config-client-dev.yaml</p>
</li>
<li><p>修改application.yaml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br><span class="line">    <span class="comment">#active: test # 表示测试环境</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>Group分组方案</p>
<ul>
<li><p>在nacos配置中心添加两个相同DataID：nacos-config-client-info.yaml；两个分组的Group分别为：TEST_GROUP，DEV_GROUP；</p>
</li>
<li><p>修改application.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">info</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改bootstrap.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEV_GROUP</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># nacos-config-client-dev.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nacos-config-client-test.yaml   ----&gt; config.info</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>namespace方案：</p>
<ul>
<li><p>在nacos配置中心命名空间增加一个命名空间</p>
</li>
<li><p>将命名空间的命名空间ID复制到boostrap.yml并在新增的命名空间中添加DataID</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEV_GROUP</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">7d8f0f5a-6a53-4785-9686-dd460158e5d4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># nacos-config-client-dev.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nacos-config-client-test.yaml   ----&gt; config.info</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
<h3 id="6，Nacos——集群架构和持久化配置"><a href="#6，Nacos——集群架构和持久化配置" class="headerlink" title="6，Nacos——集群架构和持久化配置"></a>6，Nacos——集群架构和持久化配置</h3><h4 id="a，集群部署架构图"><a href="#a，集群部署架构图" class="headerlink" title="a，集群部署架构图"></a>a，集群部署架构图</h4><p><img src="/2021/01/20/SpringCloud/22.png" alt="image-20210217231744730"></p>
<ul>
<li>默认Nacos使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的Nacos节点，数据粗糙你是存在一致性问题的。为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySQL的存储。</li>
<li>Nacos支持三种部署：<ul>
<li>单级模式 ——用于测试和单级试用</li>
<li>集群模式——用于生产环境，确保高可用</li>
<li>多集群模式——用于多数据中心场景</li>
</ul>
</li>
</ul>
<h4 id="b，Nacos持久化切换配置"><a href="#b，Nacos持久化切换配置" class="headerlink" title="b，Nacos持久化切换配置"></a>b，Nacos持久化切换配置</h4><ul>
<li><p>Nacos默认自带的是嵌入式数据库derby，需要配置将derby切换为MySQL数据库</p>
</li>
<li><p>在nacos-server-1.1.4\nacos\conf目录下找到sql脚本：nacos-mysql.sql，并在你的MySQL中执行脚本</p>
</li>
<li><p>在nacos-server-1.1.4\nacos\conf目录下找到application.properties文件，在文件最末尾添加以下配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">itfang</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">fang12345</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：mysql8.0+的：需要下载一个mysql-connector-java-8.0.17.jar并放在nacos\plugins\mysql目录下</p>
</li>
</ul>
<h4 id="c，Linux安装nacos"><a href="#c，Linux安装nacos" class="headerlink" title="c，Linux安装nacos"></a>c，Linux安装nacos</h4><ul>
<li><pre><code class="properties"><span class="comment">#在nacos官网上下载tar包</span>
<span class="attr">https</span>:<span class="string">//github.com/alibaba/nacos/releases/tag/1.4.1</span>
<span class="attr"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;properties</span><br><span class="line">  tar -zxvf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure></span>


</code></pre>
</li>
</ul>
<h4 id="d，nacos的集群配置"><a href="#d，nacos的集群配置" class="headerlink" title="d，nacos的集群配置"></a>d，nacos的集群配置</h4><ul>
<li><p>在Linux上安装完nacos</p>
</li>
<li><p>对nacos进行一个持久化切换配置，将nacos的嵌入式数据库切换成Linux下的MySQL数据库</p>
</li>
<li><p>将cluster.conf.example复制出一份并命名为cluster.conf</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cp</span> <span class="string">cluster.conf.example cluster.conf</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改cluster.conf，在里面添加nacos需要识别的ip和端口号</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这个IP不能写127.0.0.1，必须是Linux命令hostname -i能够识别的IP</span></span><br><span class="line"><span class="meta">172.30.121.178</span>:<span class="string">3333</span></span><br><span class="line"><span class="meta">172.30.121.178</span>:<span class="string">4444</span></span><br><span class="line"><span class="meta">172.30.121.178</span>:<span class="string">5555</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>先备份一份nacos启动脚本startup.sh. bk</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cp</span> <span class="string">startup.sh startup.sh.bk</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑nacos启动脚本startup.sh，使他能够接受不同的启动端口</p>
<p><img src="/2021/01/20/SpringCloud/23.png" alt="image-20210218175903661"></p>
</li>
<li><p>使用不同的端口启动nacos</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#平时单机版的启动都是./startup.sh，但是集群启动，我们希望可以类似其他软件的shell命令，传递不同的端口号启动不同的nacos实例</span></span><br><span class="line"><span class="comment">#命令：./startup.sh -p 3333表示启动端口号为3333的nacos服务器实例，和上一步的cluster.conf配置的一致</span></span><br><span class="line"><span class="meta">./startup.sh</span> <span class="string">-p 3333</span></span><br><span class="line"><span class="meta">./startup.sh</span> <span class="string">-p 4444</span></span><br><span class="line"><span class="meta">./startup.sh</span> <span class="string">-p 5555</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Nginx作为负载均衡器</p>
<p><img src="/2021/01/20/SpringCloud/24.png" alt="image-20210218180955278"></p>
</li>
<li><p>指定配置文件启动Nginx</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">./nginx</span> <span class="string">-c /usr/local/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure>






</li>
</ul>
<h3 id="7，Sentinel——分布式系统的流量防卫兵"><a href="#7，Sentinel——分布式系统的流量防卫兵" class="headerlink" title="7，Sentinel——分布式系统的流量防卫兵"></a>7，Sentinel——分布式系统的流量防卫兵</h3><h4 id="a，sentinel的特征："><a href="#a，sentinel的特征：" class="headerlink" title="a，sentinel的特征："></a>a，sentinel的特征：</h4><ul>
<li><strong>丰富的应用场景</strong>：sentinel承接了阿里巴巴近10年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围），消息削峰填谷，集群流量控制，实时熔断下游不可用应用等。</li>
<li><strong>完备的实时监控</strong>：sentinel同时提供实时的监控功能。您可以在控制台总看到接入应用的单台机器秒级数据，甚至500台以下规模的集群的汇总运行情况。</li>
<li><strong>广泛的开源生态</strong>：sentinel提供开箱即用的与其它开源框架/库的整合模块，例如与springcloud，Dubbo，gRPC的整合。您只需要引入相应的依赖并进行简单的配置既可以快速地接入sentinel。</li>
<li><strong>完善的SPI扩展点</strong>：sentinel提供简单易用，完善的SPI扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理，适配动态数据源等。</li>
</ul>
<h4 id="b，sentinel的主要特点"><a href="#b，sentinel的主要特点" class="headerlink" title="b，sentinel的主要特点"></a>b，sentinel的主要特点</h4><p><img src="/2021/01/20/SpringCloud/25.png" alt="image-20210219172653601"></p>
<h4 id="c，sentinel分为两个部分："><a href="#c，sentinel分为两个部分：" class="headerlink" title="c，sentinel分为两个部分："></a>c，sentinel分为两个部分：</h4><ul>
<li>核心库（Java客户端）：不依赖任何框架/库，能够运行于所有Java运行时环境，同时对Dubbo/Spring Cloud等框架也有较好的支持。</li>
<li>控制台（Dashboard）：基于Spring Boot开发，打包后可以直接运行，不需要额外Tomcat等应用容器。</li>
</ul>
<h4 id="d，sentinel控制台安装"><a href="#d，sentinel控制台安装" class="headerlink" title="d，sentinel控制台安装"></a>d，sentinel控制台安装</h4><ul>
<li><p>在官网下载sentinel的jar包</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="string">//github.com/alibaba/Sentinel/releases</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行下载的jar包</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切记sentinel的默认端口是8080</span></span><br><span class="line"><span class="attr">java</span> <span class="string">-jar sentinel-dashboard-1.7.0.jar</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问sentinel控制台</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="string">//47.119.125.16:8080</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="e，sentinel的初始化监控"><a href="#e，sentinel的初始化监控" class="headerlink" title="e，sentinel的初始化监控"></a>e，sentinel的初始化监控</h4><ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写主启动类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp8401</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApp8401<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写被监控的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/testA"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"------testA"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/testB"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        log.info(Thread.currentThread().getName()+<span class="string">"\t"</span>+<span class="string">"...testB"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"------testB"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="f，流控规则"><a href="#f，流控规则" class="headerlink" title="f，流控规则"></a>f，流控规则</h4><ul>
<li>基本介绍：<ul>
<li>资源名：唯一名称，默认请求路径</li>
<li>针对来源：sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）</li>
<li>阈值类型/单机类型：<ul>
<li>QPS（每秒钟的请求数量）：当调用该api的QPS达到阈值的时候，进行限流</li>
<li>线程数：当调用该api的线程数达到阈值的时候，进行限流</li>
</ul>
</li>
<li>流控模式：<ul>
<li>直接：api达到限流条件时，直接限流</li>
<li>关联：当关联的资源达到阈值时，就限流自己</li>
<li>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）【api级别的针对来源】</li>
</ul>
</li>
<li>流控效果：<ul>
<li>快速失败：直接失败，抛异常</li>
<li>Warm Up：根据codeFactor（冷加载因子，默认3）的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值</li>
<li>排队等待：匀速排毒，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>流控模式：<ul>
<li>直接模式（默认）：<ul>
<li>直接 ——》快速失败：当单机阈值设置为1，阈值类型设置为QPS时，表示1秒钟内查询1次就是OK，若1秒内超过次数1，则直接-快速失败，报错。</li>
<li>直接——》快速失败：当单机阈值设置为1，阈值类型设置为线程数时，表示该API每次只能处理一个线程任务，第二个线程访问失败。</li>
</ul>
</li>
<li>关联模式：<ul>
<li>当关联资源/testB的QPS超过设定阈值时，就限流/testA的Rest访问地址，当关联资源到阈值后限制配置好的资源名。</li>
</ul>
</li>
<li>链路模式：<ul>
<li>当从某个接口过来的资源达到限流条件时，开启限流。它的功能有点类似于针对来源配置项，区别在于：<strong>针对来源是针对上级微服务，而链路流控是针对上级接口，也就是说它的粒度更细。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>流控效果；<ul>
<li>快速失败（默认）:直接失败，抛出异常</li>
<li>预热：<ul>
<li>Warm Up方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过“冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热时间，避免冷系统被压垮。</li>
<li>预热公式：阈值除以coldFactor（默认值为3），经过预热时长后才会达到阈值</li>
<li>案例：在阈值类型为QPS下，阈值设置为10，预热时间设置为5秒，则系统初始化的阈值为10/3约等于3，即阈值刚开始为3，然后过了5秒后阈值才慢慢升高恢复到10</li>
<li>应用场景：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是为了保护系统，可以慢慢的把流量放进来，慢慢的把阈值增长到设置的阈值。</li>
</ul>
</li>
<li>匀速排队：<ul>
<li>匀速排队方式会严格控制请求通过的间隔时间，也既是让请求以匀速的速度通过，对应的是漏桶算法。</li>
<li>效果：让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效</li>
<li>应用场景：这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间主键处理这些请求，而不是在第一秒直接拒绝多余的请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="g，降级规则"><a href="#g，降级规则" class="headerlink" title="g，降级规则"></a>g，降级规则</h4><ul>
<li><p><strong>概述</strong>：除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。由于调用关系的复杂性，如果调用链路中的某个资源不稳定，最终会导致请求发生堆积。Sentinel熔断降级会在调用链路汇总某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其他的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出DegradeException）</p>
</li>
<li><p>基本介绍：</p>
<ul>
<li><strong>RT（平均响应时间，秒级）</strong>：平均响应时间超出阈值且在时间窗口内通过的请求&gt;=5，两个条件同时满足后触发降级窗口期过后关闭断路器。RT最大4900（更大的需要通过 -Dcsp.sentinel.statistic.max.rt=xxxx才能生效）</li>
<li><strong>异常比例（秒级）</strong>：QPS &gt;= 5且异常比例（秒级统计）超过阈值时，触发降级；时间窗口结束后，关闭降级</li>
<li><strong>异常数（分钟级）</strong>：异常数（分钟统计）超过阈值时，触发降级；时间窗口结束后，关闭降级。</li>
</ul>
</li>
<li><p>降级策略：</p>
<ul>
<li><p><strong>平均响应时间（DEGRADE_GRADE_RT）</strong>：当1s内持续进入5个请求（或大于5个请求），对应时刻的平均响应时间（秒级）均超过阈值（count，以ms单位），那么在接下的时间窗口（DegradeRule中的timeWindow，以s为单位）之内，对这个方法的调用都会自动地熔断（抛出DegradeException）。注意：Sentinel默认统计的RT上限是4900ms，超过此阈值的都会算作4900ms，若需要变更此上限可以通过启动配置项：</p>
<p> -Dcsp.sentinel.statistic.max.rt=xxxx来配置</p>
</li>
<li><p><strong>异常比例（DEGRADE_GRADE_EXCEPTION_RATIO）</strong>：当资源的每秒请求量 &gt;= 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule中count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule中的timeWindow，以s为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是[0.0,1.0]，代表0%-100%</p>
</li>
<li><p><strong>异常数（DEGRADE_GRADE_EXCEPTION_COUNT）</strong>：当资源近1分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若timeWindow小于60s，则结束熔断状态后仍可能再进入熔断状态。</p>
</li>
</ul>
</li>
</ul>
<h4 id="h，热点规则"><a href="#h，热点规则" class="headerlink" title="h，热点规则"></a>h，热点规则</h4><ul>
<li><p><strong>概述</strong>：热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的Top K数据，并对其访问进行限制。比如</p>
<ul>
<li>商品ID为参数，统计一段时间内最常购买的商品ID并进行限制</li>
<li>用户ID为参数，针对一段时间内频繁访问的用户ID进行限制</li>
</ul>
<p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。Sentinel利用LRU策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式。</p>
</li>
<li><p>参数例外项：</p>
<ul>
<li>作用：当我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样</li>
<li>配置注意：参数类型只支持八种基本数据类型和java.lang.String类型</li>
</ul>
</li>
</ul>
<h4 id="i，系统限流"><a href="#i，系统限流" class="headerlink" title="i，系统限流"></a>i，系统限流</h4><ul>
<li>概述：<ul>
<li>sentinel系统自适应限流从整体维度对应用入口流量进行控制，结合应用的Load,CPU使用率，总体平均RT，入口QPS和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</li>
<li>系统保护规则是应用整体维度，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量（EntryType.IN），比如Web服务或Dubbo服务端接收的请求，都属于入口流量。</li>
</ul>
</li>
<li>系统规则：<ul>
<li><strong>Load自适应（仅对Linux/Unix-like 机器生效）</strong>：系统的load1作为启动指标，进行自适应系统保护。当系统load1超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR阶段）。系统容量由系统的maxQPSminRT估算得出。设定参考值一般是CPUcores2.5</li>
<li><strong>CPU usage（1.5.0+版本）</strong>：当系统CPU使用率超过阈值即触发系统保护（取值范围0.0-1.0），比较灵敏。</li>
<li><strong>平均RT</strong>：当单台机器上所有入口流量的平均RT达到阈值即触发系统保护，单位是毫秒。</li>
<li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li><strong>入口QPS</strong>：当单台机器上所有入口流量的QPS达到阈值即触发系统保护。</li>
</ul>
</li>
</ul>
<h4 id="j，-SentinelResource"><a href="#j，-SentinelResource" class="headerlink" title="j，@SentinelResource"></a>j，@SentinelResource</h4><ul>
<li><p><strong>按资源名称限流</strong>：根据@SentinelResource（value=”realValue”），在sentinel控制台添加流控规则的资源名可以写成realValue的值</p>
</li>
<li><p><strong>按URL地址限流</strong>：根据@GetMapping（”/url”），在sentinel控制台添加流控规则的资源名时可以写/url的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/byResource"</span>)</span><br><span class="line">    <span class="comment">//如果@SentinelResource有blockHandler属性，则当不满足流控规则时采用自己编写的兜底方法</span></span><br><span class="line">    <span class="meta">@SentinelResource</span>(value = <span class="string">"byResource"</span>, blockHandler = <span class="string">"handleException"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">byResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">"按资源名称限流测试OK"</span>, <span class="keyword">new</span> Payment(<span class="number">2020L</span>, <span class="string">"serial001"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">handleException</span><span class="params">(BlockException exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>, exception.getClass().getCanonicalName() + <span class="string">"\t 服务不可用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/rateLimit/byUrl"</span>)</span><br><span class="line">    <span class="comment">//如果@SentinelResource没有blockHandler属性，则当不满足流控规则时，返回sentinel自带的提示</span></span><br><span class="line">    <span class="meta">@SentinelResource</span>(value = <span class="string">"byUrl"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">byUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">"按url限流测试OK"</span>, <span class="keyword">new</span> Payment(<span class="number">2020L</span>, <span class="string">"serial002"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>自定义限流处理逻辑</p>
<ul>
<li><p>编写兜底方法的handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerBlockHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title">handlerException</span><span class="params">(BlockException exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>, <span class="string">"按客戶自定义,global handlerException----1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title">handlerException2</span><span class="params">(BlockException exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>, <span class="string">"按客戶自定义,global handlerException----2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写调用handler方法作为兜底方法的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/rateLimit/customerBlockHandler"</span>)</span><br><span class="line">    <span class="meta">@SentinelResource</span>(value = <span class="string">"customerBlockHandler"</span>,</span><br><span class="line">            blockHandlerClass = CustomerBlockHandler<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">            <span class="title">blockHandler</span> </span>= <span class="string">"handlerException2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">customerBlockHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">"按客戶自定义"</span>, <span class="keyword">new</span> Payment(<span class="number">2020L</span>, <span class="string">"serial003"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>@SentinelResource其他属性：<strong>blockHandler管配置规则，fallback管运行异常</strong></p>
<blockquote>
<p><code>@SentinelResource</code> 用于定义资源，并提供可选的异常处理和 fallback 配置项。 <code>@SentinelResource</code> 注解包含以下属性：</p>
<ul>
<li><p><code>value</code>：资源名称，必需项（不能为空）</p>
</li>
<li><p><code>entryType</code>：entry 类型，可选项（默认为 <code>EntryType.OUT</code>）</p>
</li>
<li><p><code>blockHandler</code> / <code>blockHandlerClass</code>: <code>blockHandler</code> 对应处理 <code>BlockException</code> 的函数名称，可选项。blockHandler 函数访问范围需要是 <code>public</code>，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 <code>BlockException</code>。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>blockHandlerClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</p>
</li>
<li><p><code>fallback</code> / <code>fallbackClass</code>：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了 <code>exceptionsToIgnore</code> 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：</p>
<ul>
<li>返回值类型必须与原函数返回值类型一致；</li>
<li>方法参数列表需要和原函数一致，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常。</li>
<li>fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li>
</ul>
</li>
<li><p><code>defaultFallback</code>（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了 <code>exceptionsToIgnore</code> 里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：</p>
<ul>
<li>返回值类型必须与原函数返回值类型一致；</li>
<li>方法参数列表需要为空，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常。</li>
<li>defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li>
</ul>
</li>
<li><p>1.8.0 版本开始，<code>defaultFallback</code> 支持在类级别进行配置。</p>
<blockquote>
<p>注：1.6.0 之前的版本 fallback 函数只针对降级异常（<code>DegradeException</code>）进行处理，<strong>不能针对业务异常进行处理</strong>。</p>
</blockquote>
<p>特别地，若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 <code>BlockException</code> 时只会进入 <code>blockHandler</code> 处理逻辑。若未配置 <code>blockHandler</code>、<code>fallback</code> 和 <code>defaultFallback</code>，则被限流降级时会将 <code>BlockException</code> <strong>直接抛出</strong>（若方法本身未定义 throws BlockException 则会被 JVM 包装一层 <code>UndeclaredThrowableException</code>）。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="k，服务熔断"><a href="#k，服务熔断" class="headerlink" title="k，服务熔断"></a>k，服务熔断</h4><ul>
<li><p>如果@SentinelResource只配置value属性，则直接将异常抛到前端页面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/consumer/fallback/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@SentinelResource</span>(value = <span class="string">"fallback"</span>) <span class="comment">//没有配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">fallback</span><span class="params">(@PathVariable Long id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">"/paymentSQL/"</span>+id,CommonResult<span class="class">.<span class="keyword">class</span>,<span class="title">id</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException (<span class="string">"IllegalArgumentException,非法参数异常...."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException (<span class="string">"NullPointerException,该ID没有对应记录,空指针异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果@SentinelResource只配置value和fallback属性，则运行兜底方法，进行服务降级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/consumer/fallback/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@SentinelResource</span>(value = <span class="string">"fallback"</span>,fallback = <span class="string">"handlerFallback"</span>) <span class="comment">//fallback只负责业务异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">fallback</span><span class="params">(@PathVariable Long id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">"/paymentSQL/"</span>+id,CommonResult<span class="class">.<span class="keyword">class</span>,<span class="title">id</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException (<span class="string">"IllegalArgumentException,非法参数异常...."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException (<span class="string">"NullPointerException,该ID没有对应记录,空指针异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本例是fallback</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">handlerFallback</span><span class="params">(@PathVariable  Long id,Throwable e)</span> </span>&#123;</span><br><span class="line">    Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">"null"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>,<span class="string">"兜底异常handlerFallback,exception内容  "</span>+e.getMessage(),payment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果@SentinelResource只配置value和blockHandler属性，则如果为运行异常则直接抛到前端页面，如果是违背控制中心配置，则运行blockHandler指定的兜底方法，进行服务降级。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/consumer/fallback/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@SentinelResource</span>(value = <span class="string">"fallback"</span>,blockHandler = <span class="string">"blockHandler"</span>) <span class="comment">//blockHandler只负责sentinel控制台配置违规</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">fallback</span><span class="params">(@PathVariable Long id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">"/paymentSQL/"</span>+id,CommonResult<span class="class">.<span class="keyword">class</span>,<span class="title">id</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException (<span class="string">"IllegalArgumentException,非法参数异常...."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException (<span class="string">"NullPointerException,该ID没有对应记录,空指针异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本例是blockHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">blockHandler</span><span class="params">(@PathVariable  Long id,BlockException blockException)</span> </span>&#123;</span><br><span class="line">    Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">"null"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">445</span>,<span class="string">"blockHandler-sentinel限流,无此流水: blockException  "</span>+blockException.getMessage(),payment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果@SentinelResource配置value和fallback以及blockHandler属性，则如果出现运行时异常，则通过fallback指定的兜底方法进行服务降级，如果出现了违背控制中心配置，则通过blockHandler指定的兜底方法进行服务降级；而当两种情况同时出现时，优先通过blockHandler指定的兜底方法进行服务降级。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/consumer/fallback/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@SentinelResource</span>(value = <span class="string">"fallback"</span>,fallback = <span class="string">"handlerFallback"</span>,blockHandler = <span class="string">"blockHandler"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">fallback</span><span class="params">(@PathVariable Long id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">"/paymentSQL/"</span>+id,CommonResult<span class="class">.<span class="keyword">class</span>,<span class="title">id</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException (<span class="string">"IllegalArgumentException,非法参数异常...."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException (<span class="string">"NullPointerException,该ID没有对应记录,空指针异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本例是fallback</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">handlerFallback</span><span class="params">(@PathVariable  Long id,Throwable e)</span> </span>&#123;</span><br><span class="line">    Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">"null"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>,<span class="string">"兜底异常handlerFallback,exception内容  "</span>+e.getMessage(),payment);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本例是blockHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">blockHandler</span><span class="params">(@PathVariable  Long id,BlockException blockException)</span> </span>&#123;</span><br><span class="line">    Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">"null"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">445</span>,<span class="string">"blockHandler-sentinel限流,无此流水: blockException  "</span>+blockException.getMessage(),payment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果@SentinelResource配置了exceptionsToIgnore，则如果报该属性所包含的异常，则不再通过fallback指定的兜底方法进行服务降级，而是直接将异常抛到前端页面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/consumer/fallback/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@SentinelResource</span>(value = <span class="string">"fallback"</span>,fallback = <span class="string">"handlerFallback"</span>,blockHandler = <span class="string">"blockHandler"</span>,</span><br><span class="line">                  exceptionsToIgnore = &#123;IllegalArgumentException<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">CommonResult</span>&lt;<span class="title">Payment</span>&gt; <span class="title">fallback</span>(@<span class="title">PathVariable</span> <span class="title">Long</span> <span class="title">id</span>)</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">"/paymentSQL/"</span>+id,CommonResult<span class="class">.<span class="keyword">class</span>,<span class="title">id</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException (<span class="string">"IllegalArgumentException,非法参数异常...."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException (<span class="string">"NullPointerException,该ID没有对应记录,空指针异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本例是fallback</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">handlerFallback</span><span class="params">(@PathVariable  Long id,Throwable e)</span> </span>&#123;</span><br><span class="line">    Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">"null"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>,<span class="string">"兜底异常handlerFallback,exception内容  "</span>+e.getMessage(),payment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Sentinel整合openFeign</p>
<ul>
<li><p>只需要在application.yml中开启sentinel对openfeign的支持，其他步骤与openFeign服务接口调用过程一致</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活Sentinel对Feign的支持</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>熔断框架的比较</p>
<p><img src="/2021/01/20/SpringCloud/26.png" alt="image-20210221115634770"></p>
</li>
</ul>
<h4 id="l，规则持久化"><a href="#l，规则持久化" class="headerlink" title="l，规则持久化"></a>l，规则持久化</h4><ul>
<li><p>目的：一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化。</p>
</li>
<li><p>application.yml：添加nacos数据源配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">ds1:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">cloudalibaba-sentinel-service</span>	<span class="comment">#要与服务注册号中心的服务名称一致</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加nacos业务规则配置</p>
<p><img src="/2021/01/20/SpringCloud/27.png" alt="image-20210221202046539"></p>
<ul>
<li>resource：资源名称</li>
<li>limitApp：来源应用</li>
<li>grade：阈值类型，0表示线程数，1表示QPS</li>
<li>count：单级阈值</li>
<li>strategy：流控模式，0表示直接，1表示关联，2表示链路</li>
<li>controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待</li>
<li>clusterMode：是否集群</li>
</ul>
</li>
</ul>
<h3 id="8，Seata——分布式事务"><a href="#8，Seata——分布式事务" class="headerlink" title="8，Seata——分布式事务"></a>8，Seata——分布式事务</h3><h4 id="a，分布式事务问题的由来："><a href="#a，分布式事务问题的由来：" class="headerlink" title="a，分布式事务问题的由来："></a>a，分布式事务问题的由来：</h4><ul>
<li><p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源，业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没法保证。</p>
<p><img src="/2021/01/20/SpringCloud/28.png" alt="image-20210221203824980"></p>
<ul>
<li>一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务。】</li>
</ul>
</li>
</ul>
<h4 id="b，Seata概述："><a href="#b，Seata概述：" class="headerlink" title="b，Seata概述："></a>b，Seata概述：</h4><ul>
<li><p>简介：Seata是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata将为用户提供了AT，TCC，SAGA和XA事务模式，为用户打造一站式的分布式解决方案。</p>
</li>
<li><p>术语：</p>
<ul>
<li><strong>TC——事务协调者</strong>：维护全局和分支事务的状态，驱动全局事务提交或回滚。</li>
<li><strong>TM——事务管理器</strong>：定义全局事务的范围，开始全局事务，提交或回滚全局事务。</li>
<li><strong>RM——资源管理器</strong>：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
</li>
<li><p>处理过程：</p>
<p><img src="/2021/01/20/SpringCloud/29.png" alt="image-20210221232017924"></p>
<blockquote>
<ol>
<li>TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID</li>
<li>XID在微服务调用链路的上下文中传播</li>
<li>RM向TC注册分支事务，将其纳入XID对应全局事务的管辖</li>
<li>TM向TC发起针对XID的全局提交或回滚协议</li>
<li>TC调度XID下管辖的全部分支事务完成提交或回滚请求</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="c，Seata安装"><a href="#c，Seata安装" class="headerlink" title="c，Seata安装"></a>c，Seata安装</h4><ul>
<li><p>到官网下载tar包：<a href="http://seata.io/zh-ch" target="_blank" rel="noopener">Seata下载官网</a></p>
</li>
<li><p>解压压缩包并修改配置文件file.conf：主要修改自定义事务组名称，事务日志存储模式为db，数据库连接信息</p>
<blockquote>
<p>service语句块：</p>
<p>vgroup_mapping.my_test_tx_group = “xxx_tx_group”</p>
<p>store语句块：</p>
<p>mode = “db”</p>
<p>store语句块中的db语句块：</p>
<p>url = “xxx”</p>
<p>user = “xxx”</p>
<p>password = “xxx”</p>
</blockquote>
</li>
<li><p>建立seata数据库并在seata数据库下执行seata自带的sql文件：db_store.sql；用于查看分支事务，全局事务，和锁信息</p>
</li>
<li><p>在每个业务数据库下执行seata自带的sql文件：db_undo_log.sql ；用于追踪回滚日志信息</p>
</li>
<li><p>修改registry.conf配置文件</p>
<blockquote>
<p>registry语句块：</p>
<p>type = “nacos”</p>
<p>registry语句块下的nacos语句块：</p>
<p>serverAddr = “localhost:8848”</p>
</blockquote>
</li>
<li><p>先启动nacos8848，再启动seata-server</p>
</li>
</ul>
<h4 id="d，搭建业务微服务（订单，库存，账户）"><a href="#d，搭建业务微服务（订单，库存，账户）" class="headerlink" title="d，搭建业务微服务（订单，库存，账户）"></a>d，搭建业务微服务（订单，库存，账户）</h4><ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">2001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">seata-order-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="comment">#自定义事务组名称需要与seata-server中的对应</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">fsp_tx_group</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/seata_order</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">io:</span></span><br><span class="line">      <span class="attr">seata:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>file.conf：将seata自带的配置文件file.conf复制放在resou目录下</p>
</li>
<li><p>registry.conf：将seata自带的配置文件registry.conf复制放在resource目录下</p>
</li>
<li><p>编写日常业务MVC架构。。。</p>
</li>
<li><p>在消费者微服务的接口上面加上@GlobalTransactional(name = “xxx”,rollback=Exception.class)</p>
</li>
</ul>
<h4 id="e，Seata原理简介"><a href="#e，Seata原理简介" class="headerlink" title="e，Seata原理简介"></a>e，Seata原理简介</h4><ul>
<li><p>AT模式：提供无侵入自动补偿的事务模式</p>
<ul>
<li><p>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</p>
<blockquote>
<p>在一阶段，Seata会拦截“业务SQL”</p>
<ol>
<li>解析SQL语义，找到“业务SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”</li>
<li>执行“业务SQL”更新业务数据，在业务数据更新之后</li>
<li>其保存成“after image”，最后生成行锁</li>
</ol>
<p>以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</p>
</blockquote>
<p><img src="/2021/01/20/SpringCloud/30.png" alt="image-20210222104252975"></p>
</li>
<li><p>二阶段：</p>
<ul>
<li><p>提交异步化，非常快速地完成</p>
<blockquote>
<p>二阶段如果顺利提交的话，</p>
<p>因为“业务SQL”在一阶段已经提交至数据库，所以Seata框架只需要一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p>
</blockquote>
<p><img src="/2021/01/20/SpringCloud/31.png" alt="image-20210222104438698"></p>
</li>
<li><p>回滚通过一阶段的回滚日志进行反向补偿</p>
<blockquote>
<p>二阶段回滚：</p>
<p>二阶段如果是回滚的话，Seata就需要回滚一阶段已经执行的“业务SQL”，还原业务数据。</p>
<p>回滚方式便是用“before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据当前业务数据”和“after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理</p>
</blockquote>
<p><img src="/2021/01/20/SpringCloud/32.png" alt="image-20210222105008068"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/01/20/SpringCloud/" data-id="cklg57v3c000mb8uabl12aq2u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-远程部署项目" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/11/%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time datetime="2020-10-11T07:54:37.000Z" itemprop="datePublished">2020-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/11/%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/">远程部署项目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="maven项目配置Tomcat远程部署项目"><a href="#maven项目配置Tomcat远程部署项目" class="headerlink" title="maven项目配置Tomcat远程部署项目"></a>maven项目配置Tomcat远程部署项目</h1><ol>
<li><p><strong>配置Linux的Tomcat的配置文件</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 在tomcat目录中的conf目录下找到tomcat-users.xml配置文件，然后搜索tomcat-users，进行tomcat用户的角色和权限配置，如下：</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">tomcat-users</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;role rolename="manager-script"/&gt;</span></span><br><span class="line"><span class="code">    &lt;role rolename="manager-jmx"/&gt;</span></span><br><span class="line"><span class="code">    &lt;role rolename="manager-status"/&gt;</span></span><br><span class="line"><span class="code">    &lt;role rolename="manager"/&gt;</span></span><br><span class="line"><span class="code">    &lt;role rolename="manager-gui"/&gt;</span></span><br><span class="line"><span class="code">    &lt;user username="username" password="password" roles="manager,manager-gui,manager-script,manager-jmx,manager-status"/&gt;  </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">tomcat-users</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 配置说明：</span></span><br><span class="line">manager-gui：允许访问html接口(即URL路径为/manager/html/)</span><br><span class="line">manager-script：允许访问纯文本接口(即URL路径为/manager/text/)</span><br><span class="line">manager-jmx：允许访问JMX代理接口(即URL路径为/manager/jmxproxy/)</span><br><span class="line">manager-status：允许访问Tomcat只读状态页面(即URL路径为/manager/status/)</span><br><span class="line"></span><br><span class="line">从Tomcat Manager内部配置文件中可以得知，manager-gui、manager-script、manager-jmx均具备manager-status的权限，也就是说，manager-gui、manager-script、manager-jmx三种角色权限无需再额外添加manager-status权限，即可直接访问路径"/manager/status/*"。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>放开Tomcat对manager分支的调用权限</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 在/webapps/manager/META-INF目录中的context.xml文件中将&lt;context&gt;标签中的内容注释掉</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">antiResourceLocking</span>=<span class="string">"false"</span> <span class="attr">privileged</span>=<span class="string">"true"</span> &gt;</span></span></span><br><span class="line"> <span class="xml"><span class="comment">&lt;!--</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.RemoteAddrValve"</span></span></span></span><br><span class="line"><span class="xml">         allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1" /&gt;</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">sessionAttributeValueClassNameFilter</span>=<span class="string">"java\.lang\.(?:Boolean|Integer|Long|Number|String)|org\.apache\.catalina\.filters\.CsrfPreventionFilter\$LruCache(?:\$1)?|java\.util\.(?:Linked)?HashMap"</span>/&gt;</span></span></span><br><span class="line">--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对maven进行配置</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 在Maven的安装路径找到conf目录下的setting.xml文件，在&lt;servers&gt;节点中添加tomcat7下配置的用户信息，如下：</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span></span><br><span class="line"><span class="code">        &lt;id&gt;develope&lt;/id&gt;</span></span><br><span class="line"><span class="code">        &lt;username&gt;username&lt;/username&gt;</span></span><br><span class="line"><span class="code">        &lt;password&gt;password&lt;/password&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 配置说明：</span></span><br><span class="line"><span class="code">	配置中的id可以任意填写，但username和password必须和步骤1一致</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在项目工程中的pom中配置Tomcat插件</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://xxx.xxx.xxx.xxx:8080/manager/text<span class="tag">&lt;/<span class="name">url</span>&gt;</span> <span class="comment">&lt;!-- tomcat管理路径,即ip端口等信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span>develope<span class="tag">&lt;/<span class="name">server</span>&gt;</span> <span class="comment">&lt;!-- 与settings.xml文件中Server的id相同 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span>&gt;</span>/project<span class="tag">&lt;/<span class="name">path</span>&gt;</span> <span class="comment">&lt;!-- 应用的部署位置 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">update</span>&gt;</span>true<span class="tag">&lt;/<span class="name">update</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- &lt;username&gt;username&lt;/username&gt;--&gt;</span><span class="comment">&lt;!--可以省略--&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--&lt;password&gt;password&lt;/password&gt; --&gt;</span><span class="comment">&lt;!--可以省略--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置完成，接下来只需要maven build，然后在Goals中填上tomcat:deploy就可以run起来了（必须事先启动tomcat服务器）</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tomcat</span>:<span class="string">deploy 部署一个web war包 </span></span><br><span class="line"><span class="attr">tomcat</span>:<span class="string">reload 重新加载web war包 </span></span><br><span class="line"><span class="attr">tomcat</span>:<span class="string">start 启动tomcat </span></span><br><span class="line"><span class="attr">tomcat</span>:<span class="string">stop 停止tomcat </span></span><br><span class="line"><span class="attr">tomcat</span>:<span class="string">undeploy 停止一个war包 </span></span><br><span class="line"><span class="attr">tomcat</span>:<span class="string">run 启动嵌入式tomcat ，并运行当前项目</span></span><br></pre></td></tr></table></figure>



</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/11/%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/" data-id="cklg57v1i000kb8uacfo57csh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-加密算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/11/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-10-10T17:24:58.000Z" itemprop="datePublished">2020-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/11/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">RSA</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="一，加密算法的种类"><a href="#一，加密算法的种类" class="headerlink" title="一，加密算法的种类"></a>一，加密算法的种类</h3><ul>
<li><p><strong>对称加密</strong>：加密和解密都是用同一个密钥的算法，称作对称加密；</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）甲方选择某一种加密规则，对信息进行加密；</span><br><span class="line">（2）乙方使用同一种规则，对信息进行解密。</span><br><span class="line"><span class="section"># 优点：</span></span><br><span class="line"><span class="code">	算法公开，计算量小，加密速度快，加密效率高。</span></span><br><span class="line"><span class="section"># 缺点：</span></span><br><span class="line"><span class="code">	在数据传送前，发送方和接收方必须商定好密钥，然后使双方都能保存好密钥；其次如果一方的密钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一密钥，这会使得收，发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</span></span><br><span class="line"><span class="section"># 常见的对称加密算法有：DES,3DES,Blowfish，IDEA,RC4,RC5,RC6和AES</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>非对称加密算法</strong>：公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫做非对称加密算法。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）甲方生成一对密钥并将其中的一把作为公用密钥向其他方公开；</span><br><span class="line">（2）得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；</span><br><span class="line">（3）甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。</span><br><span class="line"><span class="section"># 优点：</span></span><br><span class="line"><span class="code">	安全</span></span><br><span class="line"><span class="section"># 缺点：</span></span><br><span class="line"><span class="code">	加密速度慢</span></span><br><span class="line"><span class="section"># 常见的非对称加密算法有：RSA,DSA,ECC</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
<h3 id="二，RSA加密"><a href="#二，RSA加密" class="headerlink" title="二，RSA加密"></a>二，RSA加密</h3><h5 id="一，RSA加密简介"><a href="#一，RSA加密简介" class="headerlink" title="一，RSA加密简介"></a>一，RSA加密简介</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSA加密是一种非对称加密，可以在不直接传递密钥的情况下，完成解密。这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。是由一对密钥来进行加解密的过程，分别称为公钥和私钥。两者之间有数字相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。通常个人保存私钥，公钥是公开的（可能同时多人持有）。</span><br></pre></td></tr></table></figure>

<h5 id="二，RSA加密、签名区别：公钥加密、私钥解密、私钥签名、公钥验签；"><a href="#二，RSA加密、签名区别：公钥加密、私钥解密、私钥签名、公钥验签；" class="headerlink" title="二，RSA加密、签名区别：公钥加密、私钥解密、私钥签名、公钥验签；"></a>二，RSA加密、签名区别：公钥加密、私钥解密、私钥签名、公钥验签；</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">	加密和签名都是为了安全性考虑，但略有不同。加密是为了防止信息被泄露，而签名是为防止信息被篡改。</span></span><br><span class="line"><span class="section"># 第一个场景：战场上，B要给A传递一条信息，内容为某一指令。（加密过程）</span></span><br><span class="line"><span class="code">	（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取</span></span><br><span class="line"><span class="code">	（2）A传递自己的公钥给B，B用A的公钥对信息进行加密。</span></span><br><span class="line"><span class="code">	（3）A接收到B加密的信息，利用A自己的私钥对信息进行解密</span></span><br><span class="line"><span class="code">	在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使能被敌方截获，也没有危险性，因为只有A的私钥才能对信息进行解密，防止了消息内容的泄露。</span></span><br><span class="line"><span class="section"># 第二个场景：A收到B发的信息后，需要进行回复“收到”（签名过程）</span></span><br><span class="line"><span class="code">	（1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。</span></span><br><span class="line"><span class="code">	（2）A用自己的私钥对消息加签，形成签名，并将加签的信息和信息本省一起传递给B。</span></span><br><span class="line"><span class="code">	（3）B收到信息后，在获取A的公钥进行验签，如果验签出来的内容与信息本身一致，证明消息是A回复的。</span></span><br><span class="line"><span class="code">	在这个过程中，只有2次传递过程，第一次是A传递加签的消息和消息本身给B，第二次是B获取A的公钥，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给B，防止了消息内容的篡改。</span></span><br><span class="line"></span><br><span class="line"><span class="code">	但是综合两个场景你会发现，第一个场景虽然被截获的消息没有泄露，但是可以利用截获的公钥，将假指令进行加密，然后传递给A。第二个场景虽然截获的消息不能被篡改，但是消息的内容可以利用公钥验签来获得，并不能防止泄露。所以在实际应用中，要根据情况使用，也可以同时使用加密和签名，比如A和B都有一套自己的公钥和私钥，当A要给B发送消息时，先用B的公钥对消息加密，在对加密的消息使用A的私钥加签名，达到既不泄露也不被篡改，更能保证消息的安全性。</span></span><br></pre></td></tr></table></figure>

<h5 id="三，RSA加密、签名的方法代码示例："><a href="#三，RSA加密、签名的方法代码示例：" class="headerlink" title="三，RSA加密、签名的方法代码示例："></a>三，RSA加密、签名的方法代码示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPairGenerator;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"><span class="keyword">import</span> java.security.Signature;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRSA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RSA最大加密明文大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENCRYPT_BLOCK = <span class="number">117</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RSA最大解密密文大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DECRYPT_BLOCK = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取密钥对</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 密钥对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">getKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator generator = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        generator.initialize(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">return</span> generator.generateKeyPair();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">getPrivateKey</span><span class="params">(String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] decodedKey = Base64.decodeBase64(privateKey.getBytes());</span><br><span class="line">        PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(decodedKey);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(keySpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">getPublicKey</span><span class="params">(String publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] decodedKey = Base64.decodeBase64(publicKey.getBytes());</span><br><span class="line">        X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(decodedKey);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePublic(keySpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RSA加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String data, PublicKey publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">int</span> inputLen = data.getBytes().length;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] cache;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对数据分段加密</span></span><br><span class="line">        <span class="keyword">while</span> (inputLen - offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputLen - offset &gt; MAX_ENCRYPT_BLOCK) &#123;</span><br><span class="line">                cache = cipher.doFinal(data.getBytes(), offset, MAX_ENCRYPT_BLOCK);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cache = cipher.doFinal(data.getBytes(), offset, inputLen - offset);</span><br><span class="line">            &#125;</span><br><span class="line">            out.write(cache, <span class="number">0</span>, cache.length);</span><br><span class="line">            i++;</span><br><span class="line">            offset = i * MAX_ENCRYPT_BLOCK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] encryptedData = out.toByteArray();</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="comment">// 获取加密内容使用base64进行编码,并以UTF-8为标准转化成字符串</span></span><br><span class="line">        <span class="comment">// 加密后的字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(Base64.encodeBase64String(encryptedData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RSA解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String data, PrivateKey privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] dataBytes = Base64.decodeBase64(data);</span><br><span class="line">        <span class="keyword">int</span> inputLen = dataBytes.length;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] cache;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对数据分段解密</span></span><br><span class="line">        <span class="keyword">while</span> (inputLen - offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputLen - offset &gt; MAX_DECRYPT_BLOCK) &#123;</span><br><span class="line">                cache = cipher.doFinal(dataBytes, offset, MAX_DECRYPT_BLOCK);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cache = cipher.doFinal(dataBytes, offset, inputLen - offset);</span><br><span class="line">            &#125;</span><br><span class="line">            out.write(cache, <span class="number">0</span>, cache.length);</span><br><span class="line">            i++;</span><br><span class="line">            offset = i * MAX_DECRYPT_BLOCK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] decryptedData = out.toByteArray();</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="comment">// 解密后的内容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(decryptedData, <span class="string">"UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待签名数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sign</span><span class="params">(String data, PrivateKey privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = privateKey.getEncoded();</span><br><span class="line">        PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PrivateKey key = keyFactory.generatePrivate(keySpec);</span><br><span class="line">        Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">        signature.initSign(key);</span><br><span class="line">        signature.update(data.getBytes());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(Base64.encodeBase64(signature.sign()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验签</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcData 原始字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sign 签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否验签通过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String srcData, PublicKey publicKey, String sign)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = publicKey.getEncoded();</span><br><span class="line">        X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PublicKey key = keyFactory.generatePublic(keySpec);</span><br><span class="line">        Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">        signature.initVerify(key);</span><br><span class="line">        signature.update(srcData.getBytes());</span><br><span class="line">        <span class="keyword">return</span> signature.verify(Base64.decodeBase64(sign.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生成密钥对</span></span><br><span class="line">            KeyPair keyPair = getKeyPair();</span><br><span class="line">            String privateKey = <span class="keyword">new</span> String(Base64.encodeBase64(keyPair.getPrivate().getEncoded()));</span><br><span class="line">            String publicKey = <span class="keyword">new</span> String(Base64.encodeBase64(keyPair.getPublic().getEncoded()));</span><br><span class="line">            System.out.println(<span class="string">"私钥:"</span> + privateKey);</span><br><span class="line">            System.out.println(<span class="string">"公钥:"</span> + publicKey);</span><br><span class="line">            <span class="comment">// RSA加密</span></span><br><span class="line">            String data = <span class="string">"待加密的文字内容"</span>;</span><br><span class="line">            String encryptData = encrypt(data, getPublicKey(publicKey));</span><br><span class="line">            System.out.println(<span class="string">"加密后内容:"</span> + encryptData);</span><br><span class="line">            <span class="comment">// RSA解密</span></span><br><span class="line">            String decryptData = decrypt(encryptData, getPrivateKey(privateKey));</span><br><span class="line">            System.out.println(<span class="string">"解密后内容:"</span> + decryptData);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// RSA签名</span></span><br><span class="line">            String sign = sign(data, getPrivateKey(privateKey));</span><br><span class="line">            <span class="comment">// RSA验签</span></span><br><span class="line">            <span class="keyword">boolean</span> result = verify(data, getPublicKey(publicKey), sign);</span><br><span class="line">            System.out.print(<span class="string">"验签结果:"</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.print(<span class="string">"加解密异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS:RSA加密对明文的长度有所限制，规定需加密的明文最大长度=密钥长度-11（单位是字节，即byte），所以在加密和解密的过程中需要分块进行。而密钥默认是1024位，即1024位/8位-11=128-11=117字节。所以默认加密前的明文最大长度117字节，解密密文最大长度为128字。那么为啥两者相差11字节呢？是因为RSA加密使用到了填充模式（padding），即内容不足117字节时会自动填满，用到填充模式自然会占用一定的字节，而且这部分字节也是参与加密的。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/11/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" data-id="cklg57v1g000jb8ua74p996hi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JWT" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/29/JWT/" class="article-date">
  <time datetime="2020-09-28T17:08:20.000Z" itemprop="datePublished">2020-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/29/JWT/">JWT</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="一，JWT的作用："><a href="#一，JWT的作用：" class="headerlink" title="一，JWT的作用："></a>一，JWT的作用：</h3><ul>
<li>​    <strong>授权</strong><ul>
<li>这是使用JWT的最常见方案。一旦用户登陆，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单点登陆时当今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。</li>
</ul>
</li>
<li><strong>信息交换</strong><ul>
<li>JSON Web Token是在各方之间安全地传输信息的好方法。因为可以对JWT进行签名（例如，使用公钥/私钥对），所以您可以确保发件人是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否遭到篡改。</li>
</ul>
</li>
</ul>
<h3 id="二，基于传统的Session认证"><a href="#二，基于传统的Session认证" class="headerlink" title="二，基于传统的Session认证"></a>二，基于传统的Session认证</h3><ul>
<li><strong>认证方式</strong>：<ul>
<li>HTTP协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据HTTP协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登陆的信息，这份登陆信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了，这样我们的应用就能识别请求来自哪个用户了，这就是传统的基于session认证。</li>
</ul>
</li>
<li><strong>暴露问题</strong>：<ul>
<li>每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</li>
<li>用户认证之后，服务端做认证记录，如果认证的巨鹿被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，响应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</li>
<li>因为是基于cookie来进行用户识别的，cookie如果来截获，用户就会很容易受到跨站请求伪造的攻击。</li>
<li>在前后端分离系统中就更加痛苦：也就是说前后端分离在应用解耦后增加了部署的复杂性。通常用户一次请求就要转发多次。如果用session每次携带sessionid到服务器，服务器还要查询用户信息。同时如果用户很多，这些信息存储在服务器内存中，给服务器增加负担。还有就是CSRF（跨站伪造请求攻击）攻击，session是基于cookie进行用户识别的，cookie如果被截获，用户就会很容易收到跨站请求伪造的攻击。还有就是sessionid就是一个特征值，表达的信息不够丰富，不容易扩展。而且如果你后端应用是多节点部署，那么就需要实现session共性机制，不方便集群应用。</li>
</ul>
</li>
</ul>
<h3 id="三，基于JWT认证"><a href="#三，基于JWT认证" class="headerlink" title="三，基于JWT认证"></a>三，基于JWT认证</h3><ul>
<li><strong>认证流程</strong>：    <ul>
<li>首先，前端通过Web表单将自定的用户名和密码发送到后端的接口，这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。</li>
<li>后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload(负载)，将其与头部分别进行Base64编码拼接后签名，形成一个JWT（Token）。形成的JWT就是一个形同111.zzz.xxx的字符串。token head.payload.signature</li>
<li>后端将JWT字符串作为登陆成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登陆时前端删除保存的JWT即可。</li>
<li>前端在每次请求是将JWT放入HTTP Header中的Authorization位，（解决XSS和XSRF问题）HEADER</li>
<li>后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收是否是自己（可选）</li>
<li>验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果</li>
</ul>
</li>
<li><strong>JWT优势</strong>：<ul>
<li>简介（Compact）:可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输的速度也很快。</li>
<li>自包含（Self-contained）：负载中包含了所用用户所需要的信息， 避免了多次查询数据库。</li>
<li>因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。</li>
<li>不需要在服务端保存会话信息。特备适用于分布式微服务。</li>
</ul>
</li>
</ul>
<h3 id="四，JWT的结构："><a href="#四，JWT的结构：" class="headerlink" title="四，JWT的结构："></a>四，JWT的结构：</h3><ul>
<li><p>​    Token的组成：</p>
<ul>
<li><p><strong>标头（Header）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标头通常由两部分组成：令牌的类型（即JWT）和所使用的签名算法，例如HMAC SHA256或RSA。它会使用Base64编码组成JWT结构的第一部分。</span><br><span class="line"></span><br><span class="line">- 注意：Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;alg&quot;:&quot;HS256&quot;,</span><br><span class="line">	&quot;typ&quot;:&quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>有效载荷（Payload）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">令牌的第二部分是有效负载，其中包含声明。声明是有关实体（通常是用户）和其他数据的声明。同样的，它会使用Base64编码组成JWT结构的第二部分</span><br><span class="line"></span><br><span class="line">- 注意：不要在Payload的内容中存放任何敏感信息。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;sub&quot;:&quot;123456789&quot;,</span><br><span class="line">	&quot;name&quot;:&quot;John Doe&quot;,</span><br><span class="line">	&quot;admin&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>签名（Signature）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前面两部分都是使用Base64进行编码的，即前端可以解开知道里面的信息。Signature需要使用编码后的header和payload以及我们提供的一个密钥，然后使用header中指定的签名算法（HS256）进行签名。签名的作用是保证JWT没有被篡改过</span><br><span class="line">- 如：</span><br><span class="line">	HAMCSHA256(base64UrlEncode(head) + &quot;.&quot; + base64UrlEncode(payload),secret);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 签名的目的：</span><br><span class="line">最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被篡改。如果有人对头部以及负载的内容解码之后进行修改，在进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 信息安全问题：</span><br><span class="line">由于Base64是一种编码，是可逆的，所以，在JWT中，不应该再负载里面加入任何敏感的数据，在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登陆。</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li>因此，JWT通常如下所示：xxxx.yyyy.zzzz Header.Payload.Signature</li>
</ul>
<h3 id="五，JWT的入门程序"><a href="#五，JWT的入门程序" class="headerlink" title="五，JWT的入门程序"></a>五，JWT的入门程序</h3><ol>
<li><p><strong>导入依赖</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生成token</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        Calendar instance = Calendar.getInstance();</span><br><span class="line">        instance.add(Calendar.SECOND,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//        生成令牌</span></span><br><span class="line">        String token = JWT.create()</span><br><span class="line">                .withClaim(<span class="string">"userId"</span>, <span class="number">20</span>)</span><br><span class="line">                .withClaim(<span class="string">"username"</span>, <span class="string">"lisi"</span>)  <span class="comment">//设置自定义的用户名</span></span><br><span class="line">                .withExpiresAt(instance.getTime())      <span class="comment">// 设置过期时间</span></span><br><span class="line">                .sign(Algorithm.HMAC256(<span class="string">"!#SWQSFF"</span>));  <span class="comment">// 设置签名 保密 复杂</span></span><br><span class="line">        System.out.println(token);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成结果</span><br><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2MDIyNDg0OTQsInVzZXJJZCI6MjAsInVzZXJuYW1lIjoibGlzaSJ9.kftQZ3OKmiHFzH1jvvuNZn1SRh8Onb2LElynsJFyd84</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据令牌和签名解析数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        创建验证对象</span></span><br><span class="line">        JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(<span class="string">"!#SWQSFF"</span>)).build();</span><br><span class="line">        DecodedJWT verify = jwtVerifier.verify(token);</span><br><span class="line">        System.out.println(verify.getClaim(<span class="string">"userId"</span>).asInt());</span><br><span class="line">        System.out.println(verify.getClaim(<span class="string">"username"</span>).asString());</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见异常信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- SignatureVerificationException：		签名不一致异常</span><br><span class="line">- TokenExpiredException:				 令牌过期异常</span><br><span class="line">- AlgorithmMismatchException:			 加密算法不匹配异常</span><br><span class="line">- InvalidClaimException:				 失效的payload异常</span><br></pre></td></tr></table></figure>






</li>
</ol>
<h3 id="六，封装JWT的工具类"><a href="#六，封装JWT的工具类" class="headerlink" title="六，封装JWT的工具类"></a>六，封装JWT的工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String SIGN = <span class="string">"token!E#DDW@32"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map // 传入payload</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> // 返回token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getToken</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        JWTCreator.Builder builder = JWT.create();</span><br><span class="line">        map.forEach((k, v) -&gt; &#123;</span><br><span class="line">            builder.withClaim(k,v);</span><br><span class="line">        &#125;);</span><br><span class="line">        Calendar instance = Calendar.getInstance();</span><br><span class="line">        instance.add(Calendar.DATE, <span class="number">7</span>);</span><br><span class="line">        builder.withExpiresAt(instance.getTime());</span><br><span class="line">        <span class="keyword">return</span> builder.sign(Algorithm.HMAC256(SIGN)).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        JWT.require(Algorithm.HMAC256(SIGN)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token的payload</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DecodedJWT <span class="title">getToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JWT.require(Algorithm.HMAC256(SIGN)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/29/JWT/" data-id="cklg57uz40002b8ua78pe1mm2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EasyExcel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/28/EasyExcel/" class="article-date">
  <time datetime="2020-09-28T08:55:07.000Z" itemprop="datePublished">2020-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/28/EasyExcel/">EasyExcel</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一，POI的简介："><a href="#一，POI的简介：" class="headerlink" title="一，POI的简介："></a>一，POI的简介：</h3><ul>
<li><p>POI提供API给Java程序对Microsoft Office格式档案读和写的功能</p>
</li>
<li><p><strong>基本功能</strong>：</p>
<ul>
<li><strong>HSSF</strong> –提供读写Microsoft <strong>Excel</strong>格式档案的功能</li>
<li><strong>XSSF</strong> –提供读写Microsoft <strong>Excel OOXML</strong>格式档案的功能</li>
<li><strong>HWPF</strong> – 提供读写Microsoft Word格式档案的功能</li>
<li><strong>HSLF</strong> –提供读写Microsoft <strong>PowerPoint</strong>格式档案的功能</li>
<li><strong>HDGF</strong> –提供读写Microsoft <strong>Visio</strong>格式档案的功能</li>
</ul>
</li>
<li><p><strong>Excel表的三种版本</strong>：</p>
<ul>
<li><p><strong>HSSF</strong>：</p>
<ul>
<li><p>缺点：最多只能处理65536行，否则会抛出异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegelArgumentException:Invalid row number(65536) outside allowable range (0..65535)</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：过程中写入缓存，不操作磁盘，最后一次写入磁盘，速度快</p>
</li>
</ul>
</li>
<li><p><strong>XSSF</strong>：</p>
<ul>
<li>缺点：写数据时速度非常慢，非常耗内存，也会发生内存溢出，如100万条</li>
<li>优点：可以写较大的数据量，如20万条</li>
</ul>
</li>
<li><p><strong>SXSSF</strong>：</p>
<ul>
<li>优点：可以写非常大的数据量，如100万条甚至更多条，写数据速度快，占用更少的内存</li>
<li>注意：<ul>
<li>过程中会产生临时文件，需要清理临时文件</li>
<li>默认由100条记录被保存在内存中，如果超过这数量，则最前面的数据被写入临时文件</li>
<li>如果想自定义内存中数据的数量，可以使用new SXSSFWorkbook（数量）</li>
<li>SXSSFWorkbook来至官方的解释：实现“BigGridDemo”策略的流式XSSFWorkbook版本，这允许写入非常大的文件而不会耗尽内存，因为任何时候只有可配置的行部分被保存在内存中</li>
<li>请注意，仍然可能会消耗大量内存，这些内存基于您正在使用的工呢，例如合并区域，注释…仍然只存储在内存中，因此如果广泛使用，可能需要大量内存。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二，EasyExcel的简介"><a href="#二，EasyExcel的简介" class="headerlink" title="二，EasyExcel的简介"></a>二，EasyExcel的简介</h3><ul>
<li><p>EasyExcel是阿里巴巴开源的一个Excel处理框架，以使用简单，节省内存著称</p>
</li>
<li><p>easyExcel能大大减少占用内存的主要原因是在解析Excel时没有将文件数据一次全部加载到内存中，而是从磁盘上一行行读取数据，逐个解析。</p>
</li>
<li><p>easyExcel与POI解析Excel时的对比图</p>
<p><img src="/2020/09/28/EasyExcel/easyExcel%E4%B8%8EPOI%E8%A7%A3%E6%9E%90Excel%E7%9A%84%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt="easyExcel与POI解析Excel的对比图"></p>
</li>
</ul>
<h3 id="三，POI的基本写操作"><a href="#三，POI的基本写操作" class="headerlink" title="三，POI的基本写操作"></a>三，POI的基本写操作</h3><ol>
<li><p>导入相关依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写创建表格与写入数据代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String PATH = <span class="string">"C:\\Users\\92540\\study\\easyExcel\\"</span>;</span><br><span class="line">   </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite03</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建工作簿</span></span><br><span class="line">    <span class="comment">//07版本则使用new XSSFWorkbook();</span></span><br><span class="line">    Workbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.创建工作表</span></span><br><span class="line">    Sheet sheet = workbook.createSheet(<span class="string">"03测试表"</span>);</span><br><span class="line">    <span class="comment">//3.创建一个行</span></span><br><span class="line">    Row row = sheet.createRow(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//4.创建一个单元格(0,0)</span></span><br><span class="line">    Cell cell = row.createCell(<span class="number">0</span>);</span><br><span class="line">    cell.setCellValue(<span class="string">"test data"</span>);</span><br><span class="line">    <span class="comment">//5. 使用IO流生成一张表,03版本Excel使用xls结尾;07版本Excel使用xlsx结尾</span></span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(PATH + <span class="string">"测试03表.xls"</span>);</span><br><span class="line">    workbook.write(fileOutputStream);</span><br><span class="line">    <span class="comment">//6.关闭IO流对象</span></span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







</li>
</ol>
<h3 id="四，POI的基本读操作"><a href="#四，POI的基本读操作" class="headerlink" title="四，POI的基本读操作"></a>四，POI的基本读操作</h3><ol>
<li><p>导入相关依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与基本的写操作导入相同的依赖</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写读取表格的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String PATH = <span class="string">"C:\\Users\\92540\\study\\easyExcel\\"</span>;</span><br><span class="line">   </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03Read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取文件流</span></span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">new</span>  FileInputStream(PATH + <span class="string">"测试03表.xls"</span>);</span><br><span class="line">    <span class="comment">//2. 创建一个工作簿</span></span><br><span class="line">    Workbook workbook = <span class="keyword">new</span> HSSFWorkbook(fileInputStream);</span><br><span class="line">    <span class="comment">//3. 得到表</span></span><br><span class="line">    Sheet sheetAt = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//4. 得到行</span></span><br><span class="line">    Row row = sheetAt.getRow(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//5. 得到单元格</span></span><br><span class="line">    Cell cell = row.getCell(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 读取值的时候,一定要注意类型</span></span><br><span class="line">    System.out.println(cell.getStringCellValue());</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3 id="五，计算公式"><a href="#五，计算公式" class="headerlink" title="五，计算公式"></a>五，计算公式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">String PATH = <span class="string">"C:\\Users\\92540\\study\\easyExcel\\"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFormula</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(PATH + <span class="string">"测试03表.xls"</span>);</span><br><span class="line">    Workbook workbook = <span class="keyword">new</span> HSSFWorkbook(fileInputStream);</span><br><span class="line">    Sheet sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">    Row row = sheet.getRow(<span class="number">2</span>);</span><br><span class="line">    Cell cell = row.getCell(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//拿到Excel的计算公式</span></span><br><span class="line">    FormulaEvaluator formulaEvaluator = <span class="keyword">new</span> HSSFFormulaEvaluator((HSSFWorkbook) workbook);</span><br><span class="line">    <span class="comment">//输出单元格的内容</span></span><br><span class="line">    <span class="keyword">int</span> cellType = cell.getCellType();</span><br><span class="line">    <span class="keyword">switch</span> (cellType) &#123;</span><br><span class="line">        <span class="keyword">case</span> Cell.CELL_TYPE_FORMULA:<span class="comment">//公式</span></span><br><span class="line">            String formula = cell.getCellFormula();</span><br><span class="line">            System.out.println(formula);</span><br><span class="line">            <span class="comment">//计算</span></span><br><span class="line">            CellValue evaluate = formulaEvaluator.evaluate(cell);</span><br><span class="line">            String cellValue = evaluate.formatAsString();</span><br><span class="line">            System.out.println(cellValue);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="六，EasyExcel操作"><a href="#六，EasyExcel操作" class="headerlink" title="六，EasyExcel操作"></a>六，EasyExcel操作</h3><ol>
<li><p>导入相关依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0-beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/28/EasyExcel/" data-id="cklg57uwl0000b8ua1qtxezwn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL深入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/" class="article-date">
  <time datetime="2020-09-11T12:36:13.629Z" itemprop="datePublished">2020-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/">MySQL深入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MySQL深入"><a href="#MySQL深入" class="headerlink" title="MySQL深入"></a>MySQL深入</h1><h3 id="一，MySQL支持的日期和时间类型"><a href="#一，MySQL支持的日期和时间类型" class="headerlink" title="一，MySQL支持的日期和时间类型"></a>一，MySQL支持的日期和时间类型</h3><p><img src="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/mysql%E6%94%AF%E6%8C%81%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B.png" alt="mysql支持日期和时间类型"></p>
<ul>
<li>如果要用来表示年月日，通常用 DATE 来表示</li>
<li>如果要用来表示年月日时分秒，通常用 DATETIME 表示。</li>
<li>如果只用来表示时分秒，通常用 TIME 来表示</li>
<li>如果需要经常插入或者更新日期为当前系统时间，则通常使用 TIMESTAMP 来表示。<br>TIMESTAMP 值返回后显示为“YYYY-MM-DD HH:MM:SS”格式的字符串，显示宽度固定<br>为 19 个字符。如果想要获得数字值，应在 TIMESTAMP 列添加+0。TIMESTAMP还有一个重要特点，就是和时区相关。当插入日期时，会先转换为本地时区后存放；而从数据库里面取出时，也同样需要将日期转换为本地时区后显示。</li>
<li>如果只是表示年份，可以用 YEAR 来表示，它比 DATE 占用更少的空间。YEAR 有 2 位或<br>4 位格式的年。默认是 4 位格式。在 4 位格式中，允许的值是 1901～2155 和 0000。在<br>2 位格式中，允许的值是 70～69，表示从 1970～2069 年。MySQL 以 YYYY 格式显示 YEAR<br>值。</li>
<li>TIMESTAMP和DATETIME的区别：<ul>
<li>TIMESTAMP支持的时间范围较小，其取值范围从19700101080001到2038年的某个<br>时间，而DATETIME是从1000-01-01 00:00:00到9999-12-31 23:59:59，范围更大。</li>
<li>表中的第一个TIMESTAMP列自动设置为系统时间。如果在一个TIMESTAMP列中插入<br>NULL，则该列值将自动设置为当前的日期和时间。在插入或更新一行但不明确给<br>TIMESTAMP列赋值时也会自动设置该列的值为当前的日期和时间，当插入的值超出<br>取值范围时，MySQL认为该值溢出，使用“0000-00-00 00:00:00”进行填补</li>
<li>TIMESTAMP的插入和查询都受当地时区的影响，更能反应出实际的日期。而<br>DATETIME则只能反应出插入时当地的时区，其他时区的人查看数据必然会有误差<br>的</li>
</ul>
</li>
</ul>
<h3 id="二，MySQL支持的字符串类型"><a href="#二，MySQL支持的字符串类型" class="headerlink" title="二，MySQL支持的字符串类型"></a>二，MySQL支持的字符串类型</h3><p><img src="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/mysql%E6%94%AF%E6%8C%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.png" alt="mysql支持的字符串类型"></p>
<ul>
<li><p>CHAR和VARCHAR类型的区别：</p>
<ul>
<li>主要区别在于<strong>存储方式</strong>的不同：CHAR 列的长度固定为创建表时声明的长度，长度可以为从 0～255 的任何值；而 VARCHAR 列中的值为可变长字符串，长度可以指定为 0～255（5.0.3 以前）或者65535（5.0.3以后）之间的值。<strong>在检索的时候，CHAR 列删除了尾部的空格，而 VARCHAR 则保留这些空格</strong></li>
</ul>
</li>
<li><p>ENUM类型：</p>
<ul>
<li>出 ENUM 类型是忽略大小写的，对’M’、’f’在存储的时候将它们都转<br>成了大写，还可以看出对于插入不在 ENUM 指定范围内的值时，并没有返回警告，而是插<br>入了 enum(‘M’,’F’)的第一值’M’</li>
<li>ENUM 类型只允许从值集合中选取单个值，而不能一次取多个值</li>
</ul>
</li>
<li><p>SET类型：</p>
<ul>
<li>SET 类型可以从允许值集合中选择任意 1 个或多个元素进行组合，所以对于输入的值只要是<br>在允许值的组合范围内，都可以正确地注入到 SET 类型的列中。</li>
<li>对于超出允许值范围的值例如（’a,d,f’）将不允许注入到上面例子中设置的 SET 类型列中，而对于（’a,d,a’）这样包含重复成员的集合将只取一次，写入后的结果为“a,d”。</li>
</ul>
</li>
</ul>
<h3 id="三，MySQL支持的比较运算符"><a href="#三，MySQL支持的比较运算符" class="headerlink" title="三，MySQL支持的比较运算符"></a>三，MySQL支持的比较运算符</h3><p><img src="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/mysql%E6%94%AF%E6%8C%81%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="mysql支持的比较运算符"></p>
<ul>
<li>“=”运算符，用于比较运算符两侧的操作数是否相等，如果两侧操作数相等返回值为 1，<br>否则为 0。注意 NULL 不能用于“=”比较。</li>
<li>“&lt;&gt;”运算符，和“=”相反，如果两侧操作数不等，则值为 1，否则为 0。NULL 不能用于“&lt;&gt;”比较</li>
<li>“&lt;=&gt;”安全的等于运算符，和“=”类似，在操作数相等时值为 1，不同之处在于即使<br>操作的值为 NULL 也可以正确比较。</li>
<li>“BETWEEN”运算符的使用格式为“a BETWEEN min AND max”，当 a 大于等于 min 并<br>且小于等于 max，则返回值为 1，否则返回 0；当操作数 a、min、max 类型相同时，此<br>表达式等价于（a&gt;=min and a&lt;=max），当操作数类型不同时，比较时会遵循类型转换原<br>则进行转换后，再进行比较运算。</li>
<li>“IN”运算符的使用格式为“a IN (value1,value2,…)”,当 a 的值存在于列表中时，则整<br>个比较表达式返回的值为 1，否则返回 0。</li>
<li>“REGEXP”运算符的使用格式为“str REGEXP str_pat”,当 str 字符串中含有 str_pat<br>相匹配的字符串时，则返回值为 1，否则返回 0。</li>
</ul>
<h3 id="四，MySQL支持的逻辑运算符"><a href="#四，MySQL支持的逻辑运算符" class="headerlink" title="四，MySQL支持的逻辑运算符"></a>四，MySQL支持的逻辑运算符</h3><p><img src="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/mysql%E6%94%AF%E6%8C%81%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="mysql支持的逻辑运算符"></p>
<ul>
<li>““NOT”或“！”表示逻辑非。返回和操作数相反的结果：当操作数为 0（假），则返回<br>值为 1，否则值为 0。但是有一点除外，那就是 NOT NULL 的返回值为 NULL。</li>
<li>““AND”或“&amp;&amp;”表示逻辑与运算。当所有操作数均为非零值并且不为 NULL 时，计<br>算所得结果为 1，当一个或多个操作数为 0 时，所得结果为 0，操作数中有任何一个为<br>NULL 则返回值为 NULL。</li>
<li>“OR”或“||”表示逻辑或运算。当两个操作数均为非 NULL 值时，如有任意一个操作<br>数为非零值，则结果为 1，否则结果为 0。当有一个操作数为 NULL 时，如另一个操作<br>数为非零值，则结果为 1，否则结果为 NULL。假如两个操作数均为 NULL，则所得结果<br>为 NULL。</li>
<li>“XOR”表示逻辑异或。当任意一个操作数为 NULL 时，返回值为 NULL。对于非 NULL 的<br>操作数，如果两个的逻辑真假值相异，则返回结果 1；否则返回 0。</li>
</ul>
<h3 id="五，MySQL常用的存储引擎"><a href="#五，MySQL常用的存储引擎" class="headerlink" title="五，MySQL常用的存储引擎"></a>五，MySQL常用的存储引擎</h3><p><img src="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/mysql%E5%B8%B8%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" alt="mysql常用存储引擎"></p>
<ul>
<li><strong>MyISAM（支持全文搜索）</strong>：是MySQL的默认存储引擎，MyISAM不支持事务，也不支持外键；<ul>
<li>优势：访问的速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用这个引擎来创建表</li>
<li>MyISAM 类型的表提供修复的工具，可以用 CHECK TABLE 语句来检查 MyISAM 表的健康，并用 REPAIR TABLE 语句修复一个损坏的 MyISAM 表</li>
<li>要指定索引文件和数据文件的路径，需要在创建表的时候通过 DATA DIRECTORY 和 INDEX<br>DIRECTORY 语句指定，也就是说不同 MyISAM 表的索引文件和数据文件可以放置到不同的路<br>径下。文件路径需要是绝对路径，并且具有访问权限。</li>
<li><strong>MyISAM 的表支持 3 种不同的存储格式</strong>：<ul>
<li><strong>静态（固定长度）表</strong>：静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。静态表的数据在存储的时候会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。</li>
<li><strong>动态表</strong>：动态表中包含变长字段，记录不是固定长度的，这样存储的优点是占用的空间相对较少，但是频繁地更新删除记录会产生碎片，需要定期执行 OPTIMIZE TABLE 语句或 myisamchk -r 命令来改善性能，并且出现故障的时候恢复相对比较困难</li>
<li><strong>压缩表</strong>：压缩表由 myisampack 工具创建，占据非常小的磁盘空间。因为每个记录是被单独压缩的，所以只有非常小的访问开支</li>
</ul>
</li>
</ul>
</li>
<li><strong>InnoDB（支持事务）</strong>：InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全<ul>
<li>MySQL 支持外键的存储引擎只有 InnoDB，在创建外键的时候，要求父表必须有对应的<br>索引，子表在创建外键的时候也会自动创建对应的索引</li>
<li><strong>InnoDB 存储表和索引有以下两种方式</strong>：<ul>
<li>使用共享表空间存储，这种方式创建的表的表结构保存在.frm 文件中，数据和索引<br>保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是<br>多个文件。</li>
<li>使用多表空间存储，这种方式创建的表的表结构仍然保存在.frm 文件中，但是每个<br>表的数据和索引单独保存在.ibd 中。如果是个分区表，则每个分区对应单独的.ibd<br>文件，文件名是“表名+分区名”，可以在创建分区的时候指定每个分区的数据文件<br>的位置，以此来将表的 IO 均匀分布在多个磁盘上。</li>
</ul>
</li>
</ul>
</li>
<li><strong>InnoDB和MyISAM的区别</strong>：<ul>
<li>对于 InnoDB 表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一<br>列，但是对于 MyISAM 表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增<br>长列是按照组合索引的前面几列进行排序后递增的</li>
<li>对比 MyISAM的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</li>
</ul>
</li>
</ul>
<h3 id="六，MySQL的事务控制"><a href="#六，MySQL的事务控制" class="headerlink" title="六，MySQL的事务控制"></a>六，MySQL的事务控制</h3><ul>
<li><strong>MySQL</strong> 是自动提交（Autocommit）的，如果需要通过明确的 Commit 和<br>Rollback 来提交和回滚事务，那么需要通过明确的事务控制命令来开始事务<ul>
<li><strong>START TRANSACTION</strong> 或 <strong>BEGIN</strong> 语句可以开始一项新的事务。如果在锁表期间，用 start transaction 命令开始一个新事务，会造成一个隐含的 unlock<br>tables 被执行</li>
<li><strong>COMMIT</strong> 和 <strong>ROLLBACK</strong> 用来提交或者回滚事务</li>
<li><strong>CHAIN</strong> 和 <strong>RELEASE</strong> 子句分别用来定义在事务提交或者回滚之后的操作，CHAIN 会立<br>即启动一个新事务，并且和刚才的事务具有相同的隔离级别，RELEASE 则会断开和客户端的<br>连接</li>
<li><strong>SET AUTOCOMMIT</strong> 可以修改当前连接的提交方式，如果设置了 SET AUTOCOMMIT=0，<br>则设置之后的所有事务都需要通过明确的命令进行提交或者回滚。</li>
</ul>
</li>
</ul>
<h3 id="七，LOCK-TABLE-和-UNLOCK-TABLE"><a href="#七，LOCK-TABLE-和-UNLOCK-TABLE" class="headerlink" title="七，LOCK TABLE 和 UNLOCK TABLE"></a>七，LOCK TABLE 和 UNLOCK TABLE</h3><ul>
<li><strong>LOCK TABLE</strong>：LOCK TABLES 可以锁定用于当前线程的表。如果表被其他线程锁定，则当前线程会等待，直<br>到可以获取所有锁定为止</li>
<li><strong>UNLOCK TABLE</strong>：UNLOCK TABLES 可以释放当前线程获得的任何锁定。当前线程执行另一个 LOCK TABLES 时，或当与服务器的连接被关闭时，所有由当前线程锁定的表被隐含地解锁；</li>
</ul>
<h3 id="八，MySQL的分布式事务"><a href="#八，MySQL的分布式事务" class="headerlink" title="八，MySQL的分布式事务"></a>八，MySQL的分布式事务</h3><ul>
<li><p>MySQL 从 5.0.3 开始支持分布式事务，当前分布式事务只支持 InnoDB 存储引擎</p>
</li>
<li><p>使用分布式事务的应用程序涉及一个或多个资源管理器和一个事务管理<br>器：</p>
<ul>
<li><strong>资源管理器（RM）</strong>用于提供通向事务资源的途径。数据库服务器是一种资源管理器。<br>该管理器必须可以提交或回滚由 RM 管理的事务。例如，多台 MySQL 数据库作为多台资源<br>管理器或者几台 Mysql 服务器和几台 Oracle 服务器作为资源管理器</li>
<li><strong>事务管理器（TM）</strong>用于协调作为一个分布式事务一部分的事务。TM 与管理每个事务<br>的 RMs 进行通讯。一个分布式事务中各个单个事务均是分布式事务的“分支事务”。分布式<br>事务和各分支通过一种命名方法进行标识</li>
</ul>
</li>
<li><p>用于执行分布式事务的过程使用两个阶段提交，发生时间在由分布式事务的各个分支需要进行的行动已经被执行之后</p>
<ul>
<li>在第一阶段，所有的分支被预备好。即它们被TM告知哟啊准备提交。通常 ，这意味着用于管理分支的每个RM会记录对于被稳定保存的分支的行动。分支指示是否它们可以这么做。这些结果被用于第二阶段。</li>
<li>在第二阶段，TM 告知 RMs 是否要提交或回滚。如果在预备分支时，所有的分支指<br>示它们将能够提交，则所有的分支被告知要提交。如果在预备时，有任何分支指示它将不能<br>提交，则所有分支被告知回滚。</li>
</ul>
</li>
<li><p>分布式事务（XA事务）的SQL语法主要包括：</p>
<p><code>XA {START|BEGOM} xid [JOIN|RESUME]</code></p>
<ul>
<li><p>XA START xid用于启动一个带给定xid值的XA事务。每个XA事务必须有一个唯一的xid值，因此该值当前不能被其他的XA事务使用</p>
</li>
<li><p>xid是一个XA事务标识符，用来唯一标识一个分布式事务。xid值由客户端提供，或由MySQL服务器生成。</p>
</li>
<li><p>xid值包括1~3个部分：</p>
<p><code>xid:gtrid [, bqual [, formatID ]]</code></p>
<ul>
<li><strong>gtrid</strong>是一个分布式事务标识符，相同的分布式事务应该使用相同的 gtrid，这样可以明确知道 xa 事务属于哪个分布式事务</li>
<li><strong>bqual</strong> 是一个分支限定符，默认值是空串。对于一个分布式事务中的每个分支事务，bqual 值必须是唯一的。</li>
<li><strong>formatID</strong> 是一个数字 ，用于标识由 gtrid 和 bqual 值使用的格式，默认值是 1。</li>
</ul>
</li>
<li><p>下面其他XA语法中用到的xid值，都必须和START操作使用的xid值相同，也就是表示对这个启动的XA事务进行操作</p>
<p><code>XA EMD xid [SUSPEND [FOR MIGRATE]]</code></p>
</li>
<li><p>使事务进入PREPARE状态，也就是两阶段提交的第一个提交阶段</p>
<p><code>XA PREPARE xid</code></p>
</li>
<li><p>这两个命令用来提交或者回滚具体的分支事务。也就是两阶段提交的第二个提交阶段，分支事务被实际的提交或者回滚</p>
<p><code>XA COMMIT xid [ONE PHASE]</code></p>
<p><code>XA ROLLBACK xid</code></p>
</li>
<li><p>XA RECOVER 返回当前数据库中处于 PREPARE 状态的分支事务的详细信息。</p>
<p><code>XA RECOVER</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="九，SQL注入"><a href="#九，SQL注入" class="headerlink" title="九，SQL注入"></a>九，SQL注入</h3><ul>
<li>简介：<ul>
<li>SQL Injection就是利用某些数据库的外部接口将用户数据插入到实际的数据库操作语言（SQL）当中，从而达到入侵数据库乃至操作系统给的目的。它的产生主要是由于程序对用户输入的数据没有进行严格的过滤，导致非法数据库查询语句的执行。</li>
</ul>
</li>
<li>应用开发中可以采取的应对措施：<ul>
<li><strong>PrepareStatement+Bind-variable</strong>：对于Java,JSP开发的应用，可以使用PrepareStatement+Bind-variable来防止SQL注入，而尽量不要使用拼接的SQL</li>
<li><strong>使用应用程序提供的转换函数</strong>：很多应用程序接口都提供了对特殊字符进行转换的函数，恰当地使用这些函数，可以防止应用程序用户输入使应用程序生成不期望的语句。</li>
<li><strong>自己定义函数进行校验</strong>：<ul>
<li>输入验证的途径可以分为以下几种：<ul>
<li>整理数据使之变得有</li>
<li>拒绝已知的非法输入；</li>
<li>只接受已知的合法输入</li>
</ul>
</li>
</ul>
</li>
<li>已知非法符：<code>“’”、“;”、“=”、“(”、“)”、“/*”、“*/”、“%”、“+”、“”、“&gt;”、“&lt;”、“--”、“[”、“]”</code><ul>
<li>只需要过滤非法的符号组合就可以阻止已知形式的攻击，并且如果发现更新的攻<br>击符号组合，也可以将这些符号组合增添进来，继续防范新的攻击。特别是空格符号和与其产生相同作用的分隔关键字的符号，例如“/**/”，如果能成功过滤这种符号，那么有很多注入攻击将不能发生，并且同时也要过滤它们的十六进制表示“％XX”。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="十，SQL-Mode-SQL-模式"><a href="#十，SQL-Mode-SQL-模式" class="headerlink" title="十，SQL Mode(SQL 模式)"></a>十，SQL Mode(SQL 模式)</h3><ul>
<li><p>SQL Mode常用来解决下面几类问题：</p>
<ul>
<li>通过设置SQL Mode，可以完成不同严格程序的数据校验，有效地保障数据准确性。</li>
<li>通过设置SQL Mode为ANSI模式，来保证大多数SQL符合标准的SQL语法，这样应用在不同数据库之间进行迁移时，则不需要对业务SQL进行较大的修改。</li>
<li>在不同数据库之间进行数据迁移之前，通过设置SQL Mode可以使MySQL上的数据更方便地迁移到目标数据库中。</li>
</ul>
</li>
<li><p>SQL Mode的命令：</p>
<ul>
<li>查看默认SQL Mode的命令：<code>select @@sql_mode;</code></li>
<li>sql_mode的一种修改方法：<code>SET [SESSION|GLOBAL] sql_mode=&#39;modes&#39;</code>其中SEESION选项表示只在本次连接中生效；而GLOBAL选项表示在本次连接中并不生效，而对于新的连接则生效</li>
<li>sql_mode的另一种修改方法：通过使用<code>--sql-mode=&quot;mode&quot;</code>选项，在MYSQL启动时设置sql_mode</li>
</ul>
</li>
<li><p>SQL Mode的常见功能：</p>
<ul>
<li><strong>校验日期数据合法性</strong>：在ANSI模式下，非法日期可以插入，但是插入值却变为“0000-00-00 00：00：00”，并且系统给出了warning；而在TRADITIONAL模式下，在直接提示日期非法，拒绝插入；</li>
<li><strong>在INSERT或UPDATE过程中，如果SQL MODE处于TRADITIONAL模式，运行MOD(X,0)会产生错误</strong>：因为TRADITIONAL也属于严格模式，在非严格模式下MOD(X,0)返回的结果是NULL，所以在含有MOD的运算中要根据实际情况设定好sql_mode。</li>
<li><strong>启用NO_BACKSLASH_ESCAPES模式，使反斜杠成为普通字符</strong>。在导入数据时，如果数据中含有反斜线字符，启用NO_BACKSLASH_ESCAPES模式保证数据的正确性，是个不错的选择。</li>
<li><strong>启用PIPES_AS_CONCAT模式。将“||”视为字符串连接操作符</strong>，在Oracle等数据库中，“||”被视为字符串的连接操作符，所以，在其他数据库中含有“||”操作符的SQL 在MySQL中将无法执行，为了解决这个问题，MySQL提供了PIPES_AS_CONCAT模式。ANSI模式中包含了PIPES_AS_CONCAT模式，所以默认情况下MySQL新版本支持将“||”视为字符串连接操作符。</li>
</ul>
<p><img src="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/sql_mode.png" alt="sql_mode"></p>
<ul>
<li>表格中第一列SQL Mode的值其实都是一些原子模式的组合，类似于角色和权限的关系。这样当实际应用时，只需要设置一个模式组合，就可以设置很多的原子模式，大大方便了用户的工作。</li>
</ul>
<p><img src="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/sql_mode%E7%BB%84%E5%90%88.png" alt="sql_mode组合"></p>
<ul>
<li>如果MySQL与其他异构数据库之间有数据迁移的需求的话，那么MySQL中提供的数据库组合模式则会对数据迁移过程中有所帮助。这些模式组合是由很多小的sql_mode组合而成，在异构数据库之间迁移数据时可以尝试使用这些模式来导出适合于目标数据库格式的数据，这样就使得导出数据更容易导入目标数据库。</li>
</ul>
</li>
</ul>
<h3 id="十一，常用SQL技巧和常见问题"><a href="#十一，常用SQL技巧和常见问题" class="headerlink" title="十一，常用SQL技巧和常见问题"></a>十一，常用SQL技巧和常见问题</h3><ul>
<li><p><strong>正则表达式的使用</strong></p>
<p>​    <img src="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="正则表达式"></p>
<ul>
<li>“^”在字符串的开始处进行匹配，返回结果为 1 表示匹配，返回结果为 0 表示不匹配。</li>
<li>“$”在字符串的末尾处进行匹配。</li>
<li>“.”匹配任意单个字符，包括换行符。</li>
<li>“[…]”匹配出括号内的任意字符。</li>
<li>“[ ^.. ]”匹配不出括号内的任意字符。和“[…]”刚好相反。</li>
</ul>
</li>
<li><p><strong>巧用 RAND()提取随机行</strong></p>
<ul>
<li>在MySQL中，产生随机数的方法是RAND()函数。可以利用这个函数与ORDER BY子句一起完成随机抽取某些行的功能。它的原理其实就是ORDER BY RAND()能够把数据随机排序。随机抽取样本对总体的统计具有十分重要的意义，因此这个函数非常有用。</li>
</ul>
</li>
<li><p><strong>利用GROUP BY的WITH ROLLUP子句做统计</strong></p>
<ul>
<li><p>在SQL语句中，使用GROUP BY的WITH ROLLUP字句可以检索出更多的分组聚合信息，它不仅仅能像一般的GROUP BY语句那样检索出各组的聚合信息，还能检索出本组类的整体聚合信息。</p>
<blockquote>
<p>1、当使用 ROLLUP 时, 不能同时使用 ORDER BY 子句进行结果排序。换言之， ROLLUP<br>和 ORDER BY 是互相排斥的</p>
</blockquote>
<blockquote>
<p>2、LIMIT 用在 ROLLUP 后面</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>用 BIT GROUP FUNCTIONS 做统计</strong></p>
<ul>
<li><p>需求：假设该超市只有面包，牛奶，饼干，啤酒4种商品，现只需要记录用户所购买的商品种类，而不需要知道所购买的商品的详细信息。</p>
</li>
<li><p>用一个字段表示顾客购买商品的信息，但是这个字段是数值型的而不是字符型的，该字段存储一个十进制数字，当它转换成二进制的时候，那么每一位代表一种商品，而且如果所在位是“1”那么表示顾客购买了该种商品，“0”表示没有购买该种商品。比如规定数值的第1位代表面包，第2位代表牛奶，第3位代表饼干，第4位代表啤酒</p>
<p>用户购物表</p>
<table>
<thead>
<tr>
<th>id</th>
<th>customer_id</th>
<th>kind</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>4</td>
</tr>
</tbody></table>
<p>其中customerid是顾客编号，kind是所购买的商品；</p>
<p>1号顾客购买的商品数值是5和4，转化为二进制分别为0101，0100，表示第一次购买了牛奶和啤酒，第二次购买了牛奶；</p>
<p>2 号顾客购买的商品数值是3和4，转化为二进制分别为0011，0100，表示第一次购买了饼干和啤酒，第二次购买了牛奶。</p>
</li>
<li><p>下面用BIT_OR()函数与GROUP BY子句联合起来，统计这两个顾客在这个超市一共都购买过什么商品</p>
<blockquote>
<p>mysql&gt;select customer_id,bit_or(kind) from order_rab group by customer_id;</p>
<table>
<thead>
<tr>
<th>customer_id</th>
<th>bit_or(kind)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>7</td>
</tr>
</tbody></table>
</blockquote>
<p>1号顾客的BIT_OR()结果是5即0101，表示这个顾客在本超市购买过牛奶和啤酒；</p>
<p>2号顾客的BIT_OR()结果是7即0111，表示这个顾客在本超市购买过牛奶，饼干，啤酒。    </p>
</li>
<li><p>可以用BIT_AND()统计每个顾客每次来本超市都会购买的商品</p>
<blockquote>
<p>mysql&gt;select customer_id,bit_and(kind) from order_rab group by customer_id;</p>
<table>
<thead>
<tr>
<th>customer_id</th>
<th>bit_and(kind)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
</blockquote>
<p>1号顾客的BIT_AND()结果是4即0100，表示1号顾客每次来本超市都会购买牛奶；</p>
<p>2号顾客的BIT_AND()结果是0即0000，表示2号顾客没有每次来本超市都会购买的商品。</p>
</li>
</ul>
</li>
<li><p><strong>数据库名、表名大小写问题</strong></p>
<ul>
<li>在大多数 UNIX 环境中，由于操作系统对大小写的敏感性导致了数据库名和表名对大小写敏感性，所以一般<strong>总是用小写创建并引用数据库名和表名</strong></li>
</ul>
</li>
<li><p><strong>使用外键需要注意的问题</strong></p>
<ul>
<li>在 MySQL 中，InnoDB 存储引擎支持对外部关键字约束条件的检查。而对于其他类型存储引擎的表，当使用 REFERENCES tbl_name(col_name)子句定义列时可以使用外部关键字，但是该子句没有实际的效果，只作为备忘录或注释来提醒用户目前正定义的列指向另一个表中的一个列。</li>
</ul>
</li>
</ul>
<h3 id="十二，优化SQL语句的一般步骤"><a href="#十二，优化SQL语句的一般步骤" class="headerlink" title="十二，优化SQL语句的一般步骤"></a>十二，优化SQL语句的一般步骤</h3><ol>
<li><p><strong>通过show status命令了解各种SQL的执行效率</strong></p>
<p><code>show [session|global] status</code></p>
<ul>
<li><p>通过<code>show [session|global] status</code>命令可以提供服务器状态信息</p>
</li>
<li><p>在操作系统上使用mysqladmin extended-status命令获得服务器状态消息</p>
<blockquote>
<p>show status like “Com_%”</p>
<table>
<thead>
<tr>
<th>Variable_name</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>Com_admin_commands</td>
<td>0</td>
</tr>
<tr>
<td>Com_alter_db</td>
<td>0</td>
</tr>
<tr>
<td>……..</td>
<td></td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p>Com_xxx表示每个xxx语句执行的次数，我们通常比较关心的是以下几个统计参数：</p>
<ul>
<li><p>Com_select：执行select操作的次数，一次查询只累加1；</p>
</li>
<li><p>Com_insert：执行insert操作的次数，对于批量插入的insert操作，只累加一次。</p>
</li>
<li><p>Com_update：执行update操作的次数。</p>
</li>
<li><p>Com_delete：执行delete操作的次数。</p>
<p>上面这些参数对于所有存储引擎的表操作都会进行累计。下面这几个参数只是针对InnoDB存储引擎的。累加的算法也略有不同；</p>
</li>
<li><p>Innodb_rows_read：select 查询返回的行数</p>
</li>
<li><p>Innodb_rows_inserted：执行 insert操作插入的行数。</p>
</li>
<li><p>__Innodb_rows_updated：执行 UPDATE 操作更新的行数</p>
</li>
<li><p>Innodb_rows_deleted：执行 DELETE 操作删除的行数操作更新的行数</p>
</li>
<li><p>Connections：试图连接 MySQL 服务器的次数</p>
</li>
<li><p>Uptime：服务器工作时间</p>
</li>
<li><p>Slow_queries：慢查询的次数</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>定位执行效率较低的 SQL 语句</strong></p>
<ul>
<li>通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。</li>
<li>慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化</li>
</ul>
</li>
<li><p><strong>通过 EXPLAIN 分析低效 SQL 的执行计划</strong></p>
<ul>
<li><p>​    通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN 或者 DESC 命令获取 MySQL<br>如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序</p>
<blockquote>
<p>计算 2006 年所有公司的销售额，需要关联 sales 表和 company 表，并且对 moneys 字段<br>做求和（sum）操作，相应 SQL 的执行计划如下：</p>
<p>mysql&gt; explain select sum(moneys) from sales a,company b where a.company_id = b.id and a.year<br>= 2006\G;</p>
<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>1.row<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>​                    id:1</p>
<p>​    select_type:SIMPLE</p>
<p>​                table:a</p>
<p>​                type:ALL</p>
<p>possible_keys:NULL</p>
<p>​                  key:NULL        </p>
<p>​           key_len:NULL</p>
<p>​                    ref:NULL</p>
<p>​                rows:1000</p>
<p>​                Extra:Using where</p>
<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>2.row<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<pre><code>                 id: 1
select_type: SIMPLE
            table: b
            type: ref</code></pre><p>  possible_keys: ind_company_id</p>
<pre><code>        key: ind_company_id
key_len: 5
        ref: sakila.a.company_id
    rows: 1
    Extra: Using where; Using index</code></pre><p>2 rows in set (0.00 sec)</p>
</blockquote>
<ul>
<li>select_type：表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等</li>
<li>table：输出结果集的表。</li>
<li>type：表示表的连接类型，性能由好到差的连接类型为 system（表中仅有一行，即常量表）、const（单表中最多有一个匹配行，例如 primary key 或者 unique index）、eq_ref（对于前面的一行，在此表中只查询一条记录，简单来说，就是多表连接中使用primary key或者unique index）、ref（与eq_ref类似，区别在于不是使用primary key 或者 unique index，而是使用普通的索引）、ref_or_null（与 ref 类似，区别在于条件中包含对 NULL 的查询）、index_merge(索引合并优化)、unique_subquery（in的后面是一个查询主键字段的子查询）、index_subquery（与 unique_subquery 类似，区别在于 in 的后面是查询非唯一索引字段的子查询）、range（单表中的范围查询）、index（对于前面的每一行，都通过查询索引来得到数据）、all（对于前面的每一行，都通过全表扫描来得到数据）。</li>
<li>possible_keys：表示查询时，可能使用的索引。</li>
<li>key：表示实际使用的索引。</li>
<li>key_len：索引字段的长度。</li>
<li>rows：扫描行的数量。</li>
<li>Extra：执行情况的说明和描述</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>确定问题并采取相应的优化措施</strong></p>
<ul>
<li><p>在上面的例子中，已经可以确认是对 a 表的全表扫描导致效率的不理想，那么对 a 表的year 字段创建索引，具体如下：</p>
<blockquote>
<p>mysql&gt; create index ind_sales2_year on sales2(year);</p>
<p>mysql&gt; explain select sum(moneys) from sales2 a,company2 b where a.company_id = b.id and<br>a.year = 2006\G;<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>a</td>
<td>ref</td>
<td>ind_sales2_year</td>
<td>ind_sales2_year</td>
<td>2</td>
<td>const</td>
<td>1</td>
<td>Using where</td>
</tr>
</tbody></table>
<p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 2. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>b</td>
<td>ref</td>
<td>ind_company2_id</td>
<td>ind_company2_id</td>
<td>5</td>
<td>sakila.a.company_id</td>
<td>1</td>
<td>Using where; Using index</td>
</tr>
</tbody></table>
<p>2 rows in set (0.00 sec)</p>
</blockquote>
<ul>
<li>发现建立索引后对 a 表需要扫描的行数明显减少（从 1000 行减少到 1 行），可见索引的<br>使用可以大大提高数据库的访问速度，尤其在表很庞大的时候这种优势更为明显。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="索引的使用以及常见问题"><a href="#索引的使用以及常见问题" class="headerlink" title="索引的使用以及常见问题"></a>索引的使用以及常见问题</h2><h3 id="十三，设计索引的原则"><a href="#十三，设计索引的原则" class="headerlink" title="十三，设计索引的原则"></a>十三，设计索引的原则</h3><ul>
<li>​    搜索的索引列，不一定是所要选择的列。换句话说，最适合索引的列是出现在 WHERE<br>子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。</li>
<li>使用惟一索引。考虑某列中值的分布。索引的列的基数越大，索引的效果越好。例<br>如，存放出生日期的列具有不同值，很容易区分各行。而用来记录性别的列，只含有“ M”<br>和“F”，则对此列进行索引没有多大用处，因为不管搜索哪个值，都会得出大约一半的行。</li>
<li>使用短索引。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应<br>该这样做。例如，如果有一个 CHAR(200)列，如果在前 10 个或 20 个字符内，多数值是惟一<br>的，那么就不要对整个列进行索引。对前10个或20个字符进行索引能够节省大量索引空间，<br>也可能会使查询更快。较小的索引涉及的磁盘 IO 较少，较短的值比较起来更快。更为重要<br>的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，因此，MySQL 也可以在<br>内存中容纳更多的值。这样就增加了找到行而不用读取索引中较多块的可能性。</li>
<li>利用最左前缀。在创建一个 n 列的索引时，实际是创建了 MySQL 可利用的 n 个索引。<br>多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为<br>最左前缀。</li>
<li>不要过度索引。不要以为索引“越多越好”，什么东西都用索引是错误的。每个额<br>外的索引都要占用额外的磁盘空间，并降低写操作的性能。在修改表的内容时，索引必须进<br>行更新，有时可能需要重构，因此，索引越多，所花的时间越长。如果有一个索引很少利用<br>或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，<br>要考虑各个索引，这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太<br>多，也可能会使 MySQL 选择不到所要使用的最好索引。只保持所需的索引有利于查询优化。</li>
<li>对于 InnoDB 存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主<br>键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序<br>保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺<br>序保存。按照主键或者内部列进行的访问是最快的，所以 InnoDB 表尽量自己指定主键，当<br>表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为<br>主键，提高查询的效率。另外，还需要注意，InnoDB 表的普通索引都会保存主键的键值，<br>所以主键要尽可能选择较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存<br>效果。</li>
</ul>
<h3 id="十四，索引的存储分类"><a href="#十四，索引的存储分类" class="headerlink" title="十四，索引的存储分类"></a>十四，索引的存储分类</h3><ul>
<li><p>MySAM存储引擎的表的数据和索引是自动分开存储的各自是独立的一个文件；</p>
</li>
<li><p>InnoDB存储引擎的表的数据和索引是存储在同一个表空间里面，但可以有多个文件组成</p>
</li>
<li><p>MySQL 中索引的存储类型:</p>
<ul>
<li>BTREE ：MyISAM 和 InnoDB 存储引擎都只支持 BTREE 索引；</li>
<li>HASH：MEMORY/HEAP 存储引擎可以支持 HASH和 BTREE 索引。</li>
</ul>
</li>
</ul>
<h3 id="十五，使用索引"><a href="#十五，使用索引" class="headerlink" title="十五，使用索引"></a>十五，使用索引</h3><ul>
<li><p>需要使用到索引的几种情况：</p>
<ul>
<li><p>对于创建的多列索引，只要查询的条件中用到了最左边的列，索引一般就会被使用，举例说明如下</p>
<blockquote>
<p>mysql&gt; create index ind_sales2_companyid_moneys on sales2(company_id,moneys);</p>
<p>mysql&gt; explain select * from sales2 where company_id = 2006;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>sales2</td>
<td>ref</td>
<td>ind_sales2_companyid_moneys</td>
<td>ind_sales2_companyid_moneys</td>
<td>5</td>
<td>const</td>
<td>1</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>可以发现即便 where 条件中不是用的 company_id 与 moneys 的组合条件，索引仍然能<br>用到，这就是索引的前缀特性。但是如果只按 moneys 条件查询表，那么索引就不会<br>被用到</p>
</blockquote>
</li>
<li><p>对于使用 like 的查询，后面如果是常量并且只有％号不在第一个字符，索引才可能会被使用，来看下面两个执行计划：</p>
<blockquote>
<p>mysql&gt; explain select * from company2 where name like ‘%3’;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>company2</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>1000</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>mysql&gt; explain select * from company2 where name like ‘3%’;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>company2</td>
<td>range</td>
<td>ind_company2_name</td>
<td>ind_company2_name</td>
<td>11</td>
<td>NULL</td>
<td>103</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>可以发现第一个例子没有使用索引，而第二例子就能够使用索引，区别就在于“%”的位置<br>不同，前者把“%”放到第一位就不能用到索引，而后者没有放到第一位就使用了索引。<br>另外，如果如果 like 后面跟的是一个列的名字，那么索引也不会被使用。</p>
</blockquote>
</li>
<li><p>如果对大的文本进行搜索，使用全文索引而不用使用 like ‘%…%’</p>
</li>
<li><p>如果列名是索引，使用 column_name is null 将使用索引。如下例中查询 name 为 null的记录就用到了索引：</p>
<blockquote>
<p>mysql&gt; explain select * from company2 where name is null;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>company2</td>
<td>ref</td>
<td>ind_company2_name</td>
<td>ind_company2_name</td>
<td>11</td>
<td>const</td>
<td>1</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="十六，存在索引但不使用索引"><a href="#十六，存在索引但不使用索引" class="headerlink" title="十六，存在索引但不使用索引"></a>十六，存在索引但不使用索引</h3><ul>
<li><p>在下列情况，虽然存在索引，但是MySQL并不会使用相应的索引：</p>
<ul>
<li><p>如果MySQL估计使用索引比全表扫描更慢，则不使用索引。例如如果列key_part1均匀分布在1和100之间，下列查询中使用索引就不是很好：</p>
<blockquote>
<p>SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90;</p>
</blockquote>
</li>
<li><p>如果使用MEMORY/HEAP表并且where条件中不使用“=”进行索引列，那么不会用到索引。heap表只有在“=”的条件下才会使用索引。</p>
</li>
<li><p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及到索引都不会被用到。例如</p>
<blockquote>
<p>mysql&gt; explain select * from sales where year = 2001 or country = ‘China’;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>sales</td>
<td>ALL</td>
<td>ind_sales_year</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>12</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
<p>可见虽然在year这个列上存在索引ind_sales_year，但是这个SQL语句并没有用到这个索引，<br>原因就是 or 中有一个条件中的列没有索引。</p>
</blockquote>
</li>
<li><p>如果不是索引列的第一部分，如下例子：</p>
<blockquote>
<p>mysql&gt; explain select * from sales2 where moneys = 1;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>sales2</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>1000</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
<p>可见虽然在 money 上面建有复合索引，但是由于 money 不是索引的第一列，那么在查询中<br>这个索引也不会被 MySQL 采用。</p>
</blockquote>
</li>
<li><p>如果like是以%开始，例如：</p>
<blockquote>
<p>mysql&gt; explain select * from company2 where name like ‘%3’;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>company2</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>1000</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
<p>可见虽然在 name 上建有索引，但是由于 where 条件中 like 的值的“%”在第一位了，那么<br>MySQL 也不会采用这个索引。</p>
</blockquote>
</li>
<li><p>如果列类型是字符串，那么一定记得在where条件中把字符常量值用引号引起来，否则的话即便这个列上有索引。如下面的例子中company2表中国的name字段是字符型的，但是SQL语句中的条件值294是一个数值型值，因此即便在name上有索引，MySQL也不能正确地用上索引，而是继续进行全表扫描</p>
<blockquote>
<p>mysql&gt; explain select * from company2 where name = 294;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>company2</td>
<td>ALL</td>
<td>ind_company2_name</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>1000</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>mysql&gt; explain select * from company2 where name = ‘294’;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>company2</td>
<td>ref</td>
<td>ind_company2_name</td>
<td>ind_company2_name</td>
<td>23</td>
<td>const</td>
<td>1</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
<p>从上面的例子中可以看到，第一个 SQL 语句中把一个数值型常量赋值给了一个字符型的列<br>name，那么虽然在 name 列上有索引，但是也没有用到；而第二个 SQL 语句就可以正确使<br>用索引。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="十七，查看索引使用情况"><a href="#十七，查看索引使用情况" class="headerlink" title="十七，查看索引使用情况"></a>十七，查看索引使用情况</h3><ul>
<li><p>如果索引正在工作，<strong>Handler_read_key</strong>的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。</p>
</li>
<li><p><strong>Handler_read_rnd_next</strong>的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中毒下一行的请求数。如果正进行大量的表扫描，<strong>Handler_read_rnd_next</strong>的值较高，则通常说明表索引不正确或写入的查询没有利用索引，具体如下：</p>
<blockquote>
<p>mysql&gt; show status like ‘Handler_read%’;</p>
<table>
<thead>
<tr>
<th>Variable_name</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>Handler_read_first</td>
<td>0</td>
</tr>
<tr>
<td>Handler_read_key</td>
<td>5</td>
</tr>
<tr>
<td>Handler_read_next</td>
<td>0</td>
</tr>
<tr>
<td>Handler_read_prev</td>
<td>0</td>
</tr>
<tr>
<td>Handler_read_rnd</td>
<td>0</td>
</tr>
<tr>
<td>Handler_read_rnd_next</td>
<td>2055</td>
</tr>
</tbody></table>
<p>6 rows in set (0.00 sec)</p>
</blockquote>
</li>
</ul>
<h2 id="SQL语句的优化"><a href="#SQL语句的优化" class="headerlink" title="SQL语句的优化"></a>SQL语句的优化</h2><h3 id="十八，两个简单实用的优化方法"><a href="#十八，两个简单实用的优化方法" class="headerlink" title="十八，两个简单实用的优化方法"></a>十八，两个简单实用的优化方法</h3><ul>
<li><p>定期分析表和检查表</p>
<ul>
<li><p>分析表的语法如下：</p>
<blockquote>
<p>ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ..</p>
<p>本语句用于分析和存储表的关键字分布，分析的结果将可以使得系统得到准确的统计信息，使得SQL能够生成正确的执行计划。如果用户感觉实际执行计划并不是预期的执行计划，执行一次分析表可能会解决问题。在分析期间，使用一个读取锁定对表进行锁定。这对 MyISAM, BDB 和 InnoDB 表有作用。对于 MyISAM 表，本语句与使用 myisamchk -a 相当，下例中对表 sales 做了表分析：</p>
<p>mysql&gt; analyze table sales;</p>
<table>
<thead>
<tr>
<th>Table</th>
<th>Op</th>
<th>Msg_type</th>
<th>Msg_text</th>
</tr>
</thead>
<tbody><tr>
<td>sakila.sales</td>
<td>analyze</td>
<td>status</td>
<td>OK</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
</blockquote>
</li>
<li><p>检查表的语法如下：</p>
<blockquote>
<p>CHECK TABLE tbl_name [, tbl_name] … [option] … option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED} </p>
<p>检查表的作用是检查一个或多个表是否有错误。CHECK TABLE对MyISAM和InnoDB表有作用。对于MyISAM表，关键字统计数据被更新。例如：</p>
<p>mysql&gt; check table sales;</p>
<table>
<thead>
<tr>
<th>Table</th>
<th>Op</th>
<th>Msg_type</th>
<th>Msg_text</th>
</tr>
</thead>
<tbody><tr>
<td>sakila.sales</td>
<td>check</td>
<td>status</td>
<td>OK</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
</blockquote>
</li>
<li><p>CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在，举例如下。</p>
<blockquote>
<p>（1）首先我们创建一个视图。</p>
<p>mysql&gt; create view sales_view3 as select * from sales3;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>（2）然后 CHECK 一下该视图，发现没有问题.</p>
<p>mysql&gt; check table sales_view3;</p>
<table>
<thead>
<tr>
<th>Table</th>
<th>Op</th>
<th>Msg_type</th>
<th>Msg_text</th>
</tr>
</thead>
<tbody><tr>
<td>sakila.sales_view3</td>
<td>check</td>
<td>status</td>
<td>OK</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
<p>（3）现在删除掉视图依赖的表。</p>
<p>mysql&gt; drop table sales3;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>（4）再来 CHECK 一下刚才的视图，发现报错了。</p>
<p>mysql&gt; check table salesview3;</p>
<table>
<thead>
<tr>
<th>Table</th>
<th>Op</th>
<th>Msg_type</th>
<th>Msg_text</th>
</tr>
</thead>
<tbody><tr>
<td>sakila.sales_view3</td>
<td>check</td>
<td>error</td>
<td>View ‘sakila.sales_view3’ references invalid table(s) or column(s) or function(s) <br>or definer/invoker of view lack rights to use them</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
</blockquote>
</li>
</ul>
</li>
<li><p>定期优化表</p>
<ul>
<li><p>优化表的语法如下:</p>
<blockquote>
<p>OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] …</p>
<p>如果已经删除了表的一大部分，或者如果已经对含有可变的长度的表（含有VARCHAR,BLOR或TEXT列的表）进行了很多的更改，则应使用OPTIMIZE TABLE命令来进行表优化。这个命令可以将表中的空间碎片进行合并，并且可以消除由于删除或者更新造成的空间浪费，但OPTIMIZE TABLE命令只对MyISAM,BDB和InnoDB表起作用。</p>
<p>以下例子显示了优化表sales的过程：</p>
<p>mysql&gt; optimize table sales;</p>
<table>
<thead>
<tr>
<th>Table</th>
<th>Op</th>
<th>Msg_type</th>
<th>Msg_text</th>
</tr>
</thead>
<tbody><tr>
<td>sakila.sales</td>
<td>optimize</td>
<td>status</td>
<td>OK</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
<p>注意：ANALYZE、CHECK、OPTIMIZE 执行期间将对表进行锁定，因此一定注意要在数据库不<br>繁忙的时候执行相关的操作。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="十九，常用的SQL的优化"><a href="#十九，常用的SQL的优化" class="headerlink" title="十九，常用的SQL的优化"></a>十九，常用的SQL的优化</h3><ul>
<li><p><strong>大批量插入数据</strong></p>
<ul>
<li><p>当用load命令导入数据的时候，适当的设置可以提高导入速度</p>
</li>
<li><p>对于 MyISAM 存储引擎的表，可以通过以下方式快速的导入大量的数据</p>
<blockquote>
<p>ALTER TABLE tbl_name DISABLE KEYS;<br>loading the data<br>ALTER TABLE tbl_name ENABLE KEYS;</p>
<p>DISABLE KEYS 和 ENABLE KEYS 用来打开或者关闭 MyISAM 表非唯一索引的更新。在导入大量的数据到一个非空的 MyISAM 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的 MyISAM 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。</p>
</blockquote>
</li>
<li><p>以下几种方式提高InnoDB表的导入效率</p>
<ul>
<li>因为 InnoDB 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效地提高导入数据的效率。</li>
<li>在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SETUNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。</li>
<li>如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>优化 INSERT 语句</strong></p>
<ul>
<li><p>如果同时从同一客户插入很多行，尽量使用多个值表的 INSERT 语句，这种方式将大大缩减客户端与数据库之间的连接、关闭等消耗，使得效率比分开执行的单个 INSERT 语句快(在一些情况中几倍)。下面是一次插入多值的一个例子：</p>
<blockquote>
<p>insert into test values(1,2),(1,3),(1,4)…</p>
</blockquote>
</li>
<li><p>如果从不同客户插入很多行，能通过使用 INSERT DELAYED 语句得到更高的速度。DELAYED 的含义是让 INSERT 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘，这比每条语句分别插入要快的多；LOW_PRIORITY 刚好相反，在所有其他用户对表的读写完后才进行插入；</p>
</li>
<li><p>将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）；</p>
</li>
<li><p>如果进行批量插入，可以增加 bulk_insert_buffer_size 变量值的方法来提高速度，但是，这只能对 MyISAM 表使用；</p>
</li>
<li><p>当从一个文本文件装载一个表时，使用 LOAD DATA INFILE。这通常比使用很多 INSERT 语句快 20 倍。</p>
</li>
</ul>
</li>
<li><p><strong>优化 GROUP BY 语句</strong></p>
<ul>
<li><p>如果查询包括 GROUP BY 但用户想要避免排序结果的消耗，则可以指定 ORDER BY NULL禁止排序，如下面的例子：</p>
<blockquote>
<p>mysql&gt; explain select id,sum(moneys) from sales2 group by id;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>sales2</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>1000</td>
<td>Using temporary; Using filesort</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
<p>mysql&gt; explain select id,sum(moneys) from sales2 group by id order by null;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>sales2</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>1000</td>
<td>Using temporary</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>优化ORDER BY语句</strong></p>
<ul>
<li><p>在某些情况中，MySQL 可以使用一个索引来满足 ORDER BY 子句，而不需要额外的排序。WHERE 条件和 ORDER BY 使用相同的索引，并且 ORDER BY 的顺序和索引顺序相同，并且ORDER BY 的字段都是升序或者都是降序。</p>
<blockquote>
<p>下列 SQL 可以使用索引</p>
<p>SELECT * FROM t1 ORDER BY key_part1,key_part2,… ;<br>SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2 DESC;<br>SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;</p>
<p>但是在以下几种情况下则不使用索引：</p>
<p>SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC；<br>–order by 的字段混合 ASC 和 DESC<br>SELECT * FROM t1 WHERE key2=constant ORDER BY key1；<br>–用于查询行的关键字与 ORDER BY 中所使用的不相同<br>SELECT * FROM t1 ORDER BY key1, key2；<br>–对不同的关键字使用 ORDER BY：</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>优化嵌套查询</strong></p>
<ul>
<li>MySQL 4.1 开始支持 SQL 的子查询。这个技术可以使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性地完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）替代。连接（JOIN）之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</li>
</ul>
</li>
<li><p><strong>优化 OR 条件</strong></p>
<ul>
<li><p>对于含有 OR 的查询子句，如果要利用索引，则 OR 之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。</p>
<blockquote>
<p>例如，首先使用 show index 命令查看表 sales2 的索引，可知它有 3 个索引，在 id、year两个字段上分别有 1 个独立的索引，在 company_id 和 year 字段上有 1 个复合索引。可以发现查询正确的用到了索引，并且从执行计划的描述中，发现 MySQL 在处理含有 OR字句的查询时，实际是对 OR 的各个字段分别查询后的结果进行了 UNION。但是当在建有复合索引的列 company_id 和 moneys 上面做 OR 操作的时候，却不能用到索引。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>使用 SQL 提示</strong></p>
<ul>
<li><p>SQL 提示（SQL HINT）是优化数据库的一个重要手段，简单来说就是在 SQL 语句中加入一些<br>人为的提示来达到优化操作的目的。<br>下面是一个使用 SQL 提示的例子：</p>
<blockquote>
<p>SELECT SQL_BUFFER_RESULTS * FROM…</p>
<p>这个语句将强制 MySQL 生成一个临时结果集。只要临时结果集生成后，所有表上的锁<br>定均被释放。这能在遇到表锁定问题时或要花很长时间将结果传给客户端时有所帮助，因为<br>可以尽快释放锁资源。</p>
</blockquote>
</li>
<li><p><strong>USE INDEX</strong></p>
<blockquote>
<p>在查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。</p>
<p>mysql&gt; explain select * from sales2 use index (ind_sales2_id) where id = 3;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>selcet_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>sales2</td>
<td>ref</td>
<td>ind_sales2_id</td>
<td>ind_sales2_id</td>
<td>5</td>
<td>const</td>
<td>1</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec).</p>
</blockquote>
</li>
<li><p><strong>IGNORE INDEX</strong></p>
<blockquote>
<p>mysql&gt; explain select * from sales2 ignore index (ind_sales2_id) where id = 3;</p>
<table>
<thead>
<tr>
<th>id</th>
<th>selcet_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>sales2</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>1000</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>1 row in set (0.00 sec)</p>
<p>从执行计划可以看出，系统忽略了指定的索引，而使用了全表扫描。</p>
</blockquote>
</li>
<li><p><strong>FORCE INDEX</strong></p>
<ul>
<li><p>为强制 MySQL 使用一个特定的索引，可在查询中使用 FORCE INDEX 作为 HINT。例如，当不强制使用索引的时候，因为 id 的值都是大于 0 的，因此 MySQL 会默认进行全表扫描，而不使用索引，但是，当使用 FORCE INDEX 进行提示时，即便使用索引的效率不是最高，MySQL 还是选择使用了索引，这是 MySQL 留给用户的一个自行选择执行计划的权力。加入 FORCE INDEX 提示后再次执行上面的 SQL：</p>
<blockquote>
<p>explain select * from sales2 force index (ind_sales2_id) where id &gt; 0 ;</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>SIMPLE</td>
<td>sales2</td>
<td>range</td>
<td>ind_sales2_id</td>
<td>ind_sales2_id</td>
<td>5</td>
<td>NULL</td>
<td>1000</td>
<td>Using where</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据库表对象的优化"><a href="#数据库表对象的优化" class="headerlink" title="数据库表对象的优化"></a>数据库表对象的优化</h2><h3 id="二十，优化数据库对象"><a href="#二十，优化数据库对象" class="headerlink" title="二十，优化数据库对象"></a>二十，优化数据库对象</h3><ul>
<li><p><strong>优化表的数据类型</strong></p>
<ul>
<li><p>在 MySQL 中，可以使用函数 PROCEDURE ANALYSE()对当前应用的表进行分析，该函数可<br>以对数据表中列的数据类型提出优化建议，用户可以根据应用的实际情况酌情考虑是否实施<br>优化。</p>
<blockquote>
<p>以下是函数 PROCEDURE ANALYSE()的使用方法：</p>
<p>SELECT * FROM tbl_name PROCEDURE ANALYSE();</p>
<p>SELECT * FROM tbl_name PROCEDURE ANALYSE(16,256);</p>
<p>输出的每一列信息都会对数据表中的列的数据类型提出优化建议。以上第二个语句告诉PROCEDURE ANALYSE()不要为那些包含的值多于16个或者256字节的ENUM类型提出建议。如果没有这样的限制，输出信息可能很长；ENUM 定义通常很难阅读。</p>
<p>根据 PROCEDURE ANALYSE()函数的输出信息，用户可能会发现，一些表中的字段可以修改为效率更高的数据类型。如果决定改变某个字段的类型，则需要使用 ALTER TABLE 语句，</p>
<p>（1）首先创建测试表 duck_cust，duck_cust 表中记录了客户的一些基本信息：</p>
<p>CREATE TABLE duck_cust(<br>cust_num MEDIUMINT AUTO_INCREMENT, –客户编号<br>cust_title TINYINT, –客户标题号</p>
<p>cust_last CHAR(20) NOT NULL, –客户姓氏<br>cust_first CHAR(15) NOT NULL, –客户名<br>cust_suffix ENUM(‘Jr.’, ‘II’, ‘III’,’IV’, ‘V’, ‘M.D.’,’PhD’), –附加码<br>cust_add1 CHAR(30) NOT NULL, –客户地址<br>cust_add2 CHAR(10), –客户地址<br>cust_city CHAR(18) NOT NULL, –客户所在城市<br>cust_state CHAR(2) NOT NULL, –客户所在州<br>cust_zip1 CHAR(5)NOT NULL, –客户邮编<br>cust_zip2 CHAR(4), –客户邮编<br>cust_duckname CHAR(25) NOT NULL, –客户名称<br>cust_duckbday DATE, –客户生日<br>PRIMARY KEY (cust_num)<br>)TYPE=MyISAM; </p>
<p>（2）然后生成一些测试数据：</p>
<p>INSERT INTO duck_cust VALUES(NULL, 1, ‘Irishlord’, ‘Red’, ‘III’, ‘1022 N.E. Sea of Rye’,<br>‘A207’, ‘Seacouver’, ‘WA’, ‘98601’, ‘3464’, ‘Netrek Rules’, ‘1967:10:21’);<br>INSERT INTO duck_cust VALUES(NULL, 4, ‘Thegreat’, ‘Vicki’, 0, ‘2004 Singleton Dr.’, 0,<br>‘Freedom’, ‘KS’, ‘67209’, ‘4321’, ‘Frida Kahlo de Tomayo’, ‘1948:03:21’);<br>INSERT INTO duck_cust VALUES(NULL, 9, ‘Montgomery’, ‘Chantel’, 0, ‘1567 Terra Cotta Way’,<br>0, ‘Chicago’, ‘IL’, ‘89129’, ‘4444’, ‘Bianca’, ‘1971:07:29’);<br>INSERT INTO duck_cust VALUES(NULL, 7, ‘Robert’, ‘David’, ‘Sr.’, ‘20113 Open Road Highway’,<br>‘#6’, ‘Blacktop’, ‘AZ’, ‘00606’, ‘1952’, ‘Harley’, ‘1949:08:00’);<br>INSERT INTO duck_cust VALUES(NULL, 5, ‘Kazui’, ‘Wonko’, ‘PhD’, ‘42 Cube Farm Lane’,<br>‘Gatehouse’, ‘Vlimpt’, ‘CA’, ‘45362’, 0, ‘Fitzwhistle’, ‘1961:12:04’);<br>INSERT INTO duck_cust VALUES(NULL, 6, ‘Gashlycrumb’, ‘Karen’, 0, ‘3113 Picket Fence Lane’,<br>0, ‘Fedora’, ‘VT’, ‘41927’, ‘5698’, ‘Tess D’’urberville’, ‘1948:08:19’);</p>
<p>desc duck_cust;</p>
<p>+———————-+———————————————-+——–+——-+———-+———+</p>
<p>| Field | Type | Null | Key | Default | Extra |</p>
<p>+———————-+———————————————-+——–+——-+———-+———+| </p>
<p>cust_num | mediumint(9) | | MUL | 0 | || </p>
<p>cust_title | tinyint(4) | YES | | NULL | || cust_last | char(20) | | | | || </p>
<p>cust_first | char(15) | | | | || </p>
<p>cust_suffix | enum(‘Jr.’,’II’,’III’,’IV’,’V’,’M.D.’,’PhD’) | YES | | NULL | || </p>
<p>cust_add1 | char(30) | | | | || cust_add2 | char(10) | YES | | NULL | || </p>
<p>cust_city | char(18) | | | | || </p>
<p>cust_state | char(2) | | | | || </p>
<p>cust_zip1 | char(5) | | | | || </p>
<p>cust_zip2 | char(4) | YES | | NULL | || </p>
<p>cust_duckname | char(25) | | | | |</p>
<p>cust_duckbday | date | YES | | NULL | </p>
<p>+———————-+———————————————-+——–+——-+———-+——–</p>
<p>（3）使用 PROCEDURE ANALYSE()函数确定要优化的列：</p>
<p>mysql&gt;SELECT * FROM duck_cust PROCEDURE ANALYSE();</p>
<table>
<thead>
<tr>
<th>Field_name</th>
<th>Min_value</th>
<th>Max_value</th>
<th>Min_length</th>
<th>Max_length</th>
<th>Empties_or_zeros</th>
<th>Nulls</th>
<th>Avg_value_or_avg_length</th>
<th>Std</th>
<th>Optimal_fieldtype:</th>
</tr>
</thead>
<tbody><tr>
<td>sakila.duck_cust.cust_num</td>
<td>1</td>
<td>6</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>3.5000</td>
<td>1.7078</td>
<td>ENUM(‘1’,’2’,’3’,’4’,’5’,’6’) NOT NULL</td>
</tr>
</tbody></table>
<p>从结果中，可以看到 test.duck_cust.cust_num 列的 Min_length、Max_length、<br>Avg_value_or_avg_length，根据这些统计值,可以对列进行优化，例如，插入的数据最大长度和最小长度都是 1，所以，可以优化字段 cust_num 为 mediumint(2)；同时，上面的结果也给出了优化建议“Optimal_fieldtype: ENUM(‘1’,’2’,’3’,’4’,’5’,’6’) NOT NULL”。看到这个建议读者可能会觉得很奇怪，怎么给出了枚举类型？而不是我们预期的整型。因为这时分析的测试表记录数太少，使得 cust_name 的唯一值太少，因此函数觉得用枚举类型会更合理。如果是对一个大表进行分析，提出的建议会更准确。</p>
<p>根据给出的统计信息和优化建议，可以使用如下语句进行字段类型的更改: </p>
<p>mysql&gt; alter table duck_cust modify cust_num mediumint(2);<br>Query OK, 6 rows affected (0.03 sec)<br>Records: 6 Duplicates: 0 Warnings: 0</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>通过拆分提高表的访问效率</strong></p>
<ul>
<li><p>这里所说的”拆分”，是指对数据表进行拆分。如果针对MyISAM类型的表进行，那么有两种拆分方法。</p>
<ul>
<li><p>第一种方法是垂直拆分，即吧主码和一些列放到一个表，然后把主码和另外的列放到另一个表中。</p>
<blockquote>
<p>如果一个表中某些列常用，而另外一些列不常用，则可以采用垂直拆分，另外垂直拆分可以使得数据行变小，一个数据页就能存放更多的数据，在查询时就会减少I/O次数。其缺点是需要管理冗余列，查询所有数据需要联合（JOIN）操作。</p>
</blockquote>
</li>
<li><p>第二种方法是水平拆分，即根据一列或多列数据的值把数据行放到两个独立的表中。水平拆分通常在以下几种情况下使用：</p>
<ul>
<li><p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度。</p>
</li>
<li><p>表中的数据本来就有独立性，例如，表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</p>
</li>
<li><p>需要把数据存放到多个介质上。</p>
<blockquote>
<p>例如，移动电话的账单表就可以分成两个表或多个表。最近 3 个月的账单数据存在一<br>个表中，3 个月前的历史账单存放在另外一个表中，超过 1 年的历史账单可以存储到<br>单独的存储介质上，这种拆分是最常使用的水平拆分方法。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>水平拆分会给应用增加复杂度，它通常在查询时需要多个表名，查询所有数据需<br>要 UNION 操作。在许多数据库应用中，这种复杂性会超过它带来的优点，因为只要<br>索引关键字不大，则在索引用于查询时，表中增加 2 至 3 倍数据量，查询时也就增加<br>读一个索引层的磁盘次数，所以水平拆分要考虑数据量的增长速度，根据实际情况决<br>定是否需要对表进行水平拆分。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>逆规范化</strong></p>
<ul>
<li><p>因为规范化越高，那么产生的关系就越多，关系过多的直接结果就是导致表之间的连接操作越频繁，而表之间的连接操作是性能较低的操作，直接影响到查询的速度，所以对于查询较多的应用就需要根据实际情况运用逆规范化对数据进行设计，通过逆规范化来提高查询的性能。</p>
<blockquote>
<p>例如，移动电话的用户每月都会查询自己的账单，账单信息一般包含用户的名字和本月消费总金额，设想一下，如果用户的姓名和属性信息存放在一个表中，假设表名为 A，而用户的编号和他对应的账单信息存放在另外一张 B 表中，那么，用户每次查询自己的月账单时，数据库查询时都要进行表连接，因为账单表 B 中并不包含用户的名字，所以必须通过关联 A 表取过来，如果在数据库设计时考虑到这一点，就可以在 B 表增加一个冗余字段存放用户的名字，这样在查询账单时就不用再做表关联，可以使查询有更好的性能。</p>
</blockquote>
</li>
<li><p>反规范的好处是降低连接操作的需求、降低外码和索引的数目，还可能减少表的数目，相应带来的问题是可能出现数据的完整性问题。加快查询速度，但会降低修改速度。因此决定做反规范时，一定要权衡利弊，仔细分析应用的数据存取需求和实际的性能特点，好的索引和其他方法经常能够解决性能问题，而不必采用反规范这种方法</p>
</li>
<li><p>在进行反规范操作之前，要充分考虑数据的存取需求、常用表的大小、一些特殊的计算（例如合计）、数据的物理存储位置等。常用的反规范技术有增加冗余列、增加派生列、重新组表和分割表。</p>
<ul>
<li>增加冗余列：指在多个表中具有相同的列，它常用来在查询时避免连接操作。</li>
<li>增加派生列：指增加的列来自其他表中的数据，由其他表中的数据巾帼计算生成。增加的派生类起作用是在查询时减少连接连接操作，避免使用集函数。</li>
<li>重新组表：指如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接而提高性能。</li>
<li>分割表：垂直拆分和水平拆分</li>
</ul>
</li>
<li><p>逆规范技术需要维护数据的完整性。无论使用何种反规范技术，都需要一定的管理来维护数据的完整性。常用的方法是批处理维护，应用逻辑和触发器。</p>
<ul>
<li>批处理维护是指对复制列或派生列的修改积累一定的时间后，运行一批处理作业或存储过程对复制或派生列进行修改，这只能在对实时性要求不高的情况下使用。</li>
<li>数据的完整性也可由应用逻辑来实现，这就要求必须在同一事务中对所有涉及的表进行增，删，改操作。用应用逻辑来实现数据的完整性风险较大，因为同一逻辑必须在所有的应用中使用和维护，容易遗漏，特别是在需求变化时，不易于维护。</li>
<li>另一种方式就是使用触发器，对数据的任何修改立即触发对复制列或派生列的相应修改。触发器是实时的，而且相应的处理逻辑只在一个地方出现，易于维护。一般来说，是解决这类问题比较好的办法。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用中间表提高统计查询速度。</strong></p>
<ul>
<li><p>对于数据量较大的表，在其上进行统计查询通常会效率很低，并且还要考虑统计查询是否会对在线的应用产生负面影响。通常在这种情况下，使用中间表可以提高统计查询的效率，下面通过对 session 表的统计来介绍中间表的使用：</p>
<blockquote>
<p>（1）session 表记录了客户每天的消费记录，表结构如下：</p>
<p>CREATE TABLE session (<br>cust_id varchar(10) , –客户编号<br>cust_amount DECIMAL(16,2), –客户消费金额<br>cust_date DATE, –客户消费时间<br>cust_ip varchar(20) –客户 IP 地址<br>)</p>
<p>（2）由于每天都会产生大量的客户消费记录,所以 session 表的数据量很大,现在业务部门有一具体的需求：希望了解最近一周客户的消费总金额和近一周每天不同时段用户的消费总金额。针对这一需求我们通过 2 种方法来得出业务部门想要的结果。</p>
<p>方法1：在session表上直接进行统计，得出想要的结果。</p>
<p>mysql&gt; select sum(cust_amount) from session where cust_date&gt;adddate(now(),-7);</p>
<table>
<thead>
<tr>
<th>sum(cust_amount)</th>
</tr>
</thead>
<tbody><tr>
<td>161699200.64</td>
</tr>
</tbody></table>
<p>方法 2：创建中间表 tmp_session，表结构和源表结构完全相同。</p>
<p>CREATE TABLE tmp_session (<br>cust_id varchar(10) , –客户编号<br>cust_amount DECIMAL(16,2), –客户消费金额<br>cust_date DATE, –客户消费时间<br>cust_ip varchar(20) –客户 IP 地址<br>) ;</p>
<p>转移要统计的数据到中间表,然后在中间表上进行统计，得出想要的结果。</p>
<p>mysql&gt; insert into tmp_session select * from session where cust_date&gt;adddate(now(),-7);<br>Query OK, 1573328 rows affected (6.67 sec)<br>Records: 1573328 Duplicates: 0 Warnings: 0</p>
<p>mysql&gt; select sum(cust_amount) from tmp_session;</p>
<table>
<thead>
<tr>
<th>sum(cust_amount)</th>
</tr>
</thead>
<tbody><tr>
<td>161699200.64</td>
</tr>
</tbody></table>
<p>1 row in set (0.73 sec)</p>
<p>从上面的 2 种实现方法上看,在中间表中做统计花费的时间很少(这里不计算转移数据花费的时间)，另外，针对业务部门想了解“近一周每天不同时段用户的消费总金额”这一需求，在中间表上给出统计结果更为合适,原因是源数据表(session 表) cust_date 字段没有索引并且源表的数据量较大，所以在按时间进行分时段统计时效率很低，这时可以在中间表上对 cust_date 字段创建单独的索引来提高统计查询的速度。</p>
</blockquote>
</li>
<li><p>中间表在统计查询中经常会用到，其优点如下：</p>
<ul>
<li>中间表复制源表部分数据，并且与源表相“隔离”，在中间表上做统计查询不会对在线应用产生负面影响。</li>
<li>中间表上可以灵活的添加索引或增加临时用的新字段，从而达到提高统计查询效率和辅助统计查询作用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h2><h3 id="二十一，MySQL锁概述"><a href="#二十一，MySQL锁概述" class="headerlink" title="二十一，MySQL锁概述"></a>二十一，MySQL锁概述</h3><ul>
<li>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</li>
<li>MySQL这3种锁的特性可大致归纳如下：<ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发送锁冲突的概率最高，并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li>页面锁：开销和加锁时间介于表锁和行锁之间：会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。</li>
<li>仅从锁的角度莱索：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</li>
</ul>
</li>
</ul>
<h3 id="二十二，MyISAM表锁"><a href="#二十二，MyISAM表锁" class="headerlink" title="二十二，MyISAM表锁"></a>二十二，MyISAM表锁</h3><ul>
<li><p>MyISAM 存储引擎只支持表锁，</p>
</li>
<li><p><strong>查询表级锁争用情况</strong></p>
<blockquote>
<p>可以通过检查table_locks_waited和table_lock_immediate状态变量来分析系统上的表锁定争夺：</p>
<p>mysql&gt;show status like ‘table%’;</p>
<table>
<thead>
<tr>
<th>Variable_name</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>Table_locks_immediate</td>
<td>2979</td>
</tr>
<tr>
<td>Table_locks_waited</td>
<td>0</td>
</tr>
</tbody></table>
<p>如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。</p>
</blockquote>
</li>
<li><p><strong>MySQL表级锁的锁模式</strong>：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。</p>
<ul>
<li><p><img src="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/%E9%94%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt="锁模式的兼容性"></p>
<blockquote>
<p> 可见，对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM 表的读操作与写操作之间，以及写操作之间是串行的！根据如表 20-2 所示的例子可以知道，当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>如何加表级锁</strong></p>
<ul>
<li><p>MyISAN在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更行操作（UPDATE、DELETE、INNSERT等）前，会自动给设计的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p>
</li>
<li><p>给 MyISAM 表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。</p>
<blockquote>
<p>例如，有一个订单表 orders，其中记录有各订单的总金额 total，同时还有一个订单明细表 order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相符，可能就需要执行如下两条 SQL：</p>
<p>Select sum(total) from orders;<br>Select sum(subtotal) from order_detail;</p>
<p>这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，<br>order_detail 表可能已经发生了改变。因此，正确的方法应该是：</p>
<p>Lock tables orders read local, order_detail read local;<br>Select sum(total) from orders;<br>Select sum(subtotal) from order_detail;<br>Unlock tables;</p>
<p>要特别说明以下两点内容：</p>
<ul>
<li>上面的例子在LOCK TABLES时加了“local”选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录。</li>
<li>在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因。</li>
</ul>
<p>当使用LOCK TABLES时，不仅需要一次锁定用到的所有表，而且，同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名表锁定多少次，否则也会出错！举例说明：</p>
<p>（1）对 actor 表获得读锁：</p>
<p>mysql&gt; lock table actor read;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>（2）但是通过别名访问会提示错误：</p>
<p>mysql&gt; select a.first_name,a.last_name,b.first_name,b.last_name from actor a,actor b where a.first_name = b.first_name and a.first_name = ‘Lisa’ and a.last_name = ‘Tom’ and a.last_name &lt;&gt; b.last_name;<br>ERROR 1100 (HY000): Table ‘a’ was not locked with LOCK TABLES</p>
<p>（3）需要对别名分别锁定：</p>
<p>mysql&gt; lock table actor as a read,actor as b read;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>（4）按照别名的查询可以正确执行：</p>
<p>mysql&gt; select a.first_name,a.last_name,b.first_name,b.last_name from actor a,actor b where<br>a.first_name = b.first_name and a.first_name = ‘Lisa’ and a.last_name = ‘Tom’ and a.last_name<br>&lt;&gt; b.last_name;</p>
<table>
<thead>
<tr>
<th>first_name</th>
<th>last_name</th>
<th>first_name</th>
<th>last_name</th>
</tr>
</thead>
<tbody><tr>
<td>Lisa</td>
<td>Tom</td>
<td>LISA</td>
<td>MONROE\</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
</li>
<li><p>并发插入（Concurrent Inserts）</p>
<ul>
<li><p>在一定条件下，MyISAM表也支持查询和插入操作的并发进行。</p>
</li>
<li><p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0，1或2.</p>
<ul>
<li>当concurrent_insert设置为0时，不允许并发插入。</li>
<li>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。</li>
<li>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</li>
</ul>
<blockquote>
<p>可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入的锁争用。例如，将concurrent_insert系统变量设为2，总是允许并发插入；同时，通过定期在系统空闲时段执行OPTIMIZE TABLE语句来整理空间碎片，收回因删除记录而产生的中间空洞。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>MyISAM的锁调度</p>
<ul>
<li>MyISAM 存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁，MySQL 如何处理呢？答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为 MySQL 认为写请求一般比读请求要重要。这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节 MyISAM 的调度行为。<ul>
<li>通过指定启动参数low-priority-updates,使MyISAM引擎默认给予读请求以优先的权利。</li>
<li>通过执行命令SET LOW_PRIORITY_UPDATES=1,使该连接发出的更新请求优先级降低。</li>
<li>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</li>
<li>另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二十三，InnoDB锁问题"><a href="#二十三，InnoDB锁问题" class="headerlink" title="二十三，InnoDB锁问题"></a>二十三，InnoDB锁问题</h3><ul>
<li><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）;二是采用了行级锁。行级锁与表级锁本来就有许多不同之处。</p>
</li>
<li><p><strong>事务（Transaction）及其ACID属性</strong></p>
<ul>
<li>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。<ul>
<li><strong>原子性（Atomicity）:</strong>事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li>
<li><strong>一致性（Consistent）</strong>:在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li>
<li><strong>隔离性（Isolation）</strong>：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li><strong>持久性（Durable）</strong>:事务完成之后，他对于数据的修改是永久性的 ，即使出现系统故障也能够保持。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>并发事件处理带来的问题</strong></p>
<ul>
<li>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况：<ul>
<li><strong>更新丢失（Lost Update）</strong>:当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免次问题</li>
<li><strong>脏读（Dirty Reads）</strong>：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些’脏’数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。</li>
<li><strong>不可重复读（Non-Repeatable Reads）</strong>:一个事务在读取某些数据后的某个时间再次读取以前读过的数据，却发现其读出的数据已经发生了改变，或某些记录已经被删除了！这种现象就叫做“不可重复读”。</li>
<li><strong>幻读（Phantom Reads）</strong>:一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为‘幻读’。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>事务隔离级别</strong></p>
<ul>
<li><p>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p>
</li>
<li><p>“脏读”、“不可重复读”和“幻读”，其实都是数据读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本上可分为以下两种：</p>
<ul>
<li>一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li>
<li>另一种是不用加任何锁，通过一定机制生成一个数据请求时间点来一致性数据快照（Snapshot）,并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（MultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。</li>
</ul>
</li>
<li><p>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力，为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，通过选择不同的隔离级别来平衡“隔离”与“并发”的矛盾。</p>
<p><img src="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="4种隔离级别的比较"></p>
<p>​    最后要说明的是：各具体数据库并不一定完全实现了上述4个隔离级别，例如，Oracle只提供Read committed和Serializable两个标准隔离级别，另外还提供自己定义的Read only隔离级别；SQL Server除支持上述ISO/ANSI SQL92定义的4个隔离级别外，还支持一个叫做“快照“的隔离级别，但严格来说它是一个用MVCC实现的Serializable隔离级别。MySQL支持全部4个隔离级别，但在具体实现时，有一些特点，比如在一些隔离级别下是采用MVCC一致性读，但某些情况下又不是。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>获取InnoDB行锁争用情况</strong></p>
<ul>
<li><p>可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：</p>
<blockquote>
<p>mysql&gt;show status like ‘innodb_row_lock%’;</p>
<table>
<thead>
<tr>
<th>Variable_name</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>InnoDB_row_lock_current_waits</td>
<td>0</td>
</tr>
<tr>
<td>InnoDB_row_lock_time</td>
<td>0</td>
</tr>
<tr>
<td>InnoDB_row_lock_time_avg</td>
<td>0</td>
</tr>
<tr>
<td>InnoDB_row_lock_time_max</td>
<td>0</td>
</tr>
<tr>
<td>InnoDB_row_lock_waits</td>
<td>0</td>
</tr>
</tbody></table>
<p>如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表，数据行等，并分析锁争用的原因。</p>
<p>具体方法如下：</p>
<p>mysql&gt; CREATE TABLE innodb_monitor(a INT) ENGINE=INNODB;<br>Query OK, 0 rows affected (0.14 sec)</p>
<p>mysql&gt; Show innodb status\G;</p>
<p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br> Type: InnoDB<br> Name:<br>Status:<br>…</p>
<p>…</p>
<hr>
<p>TRANSACTIONS</p>
<hr>
<p>Trx id counter 0 117472192<br>Purge done for trx’s n:o &lt; 0 117472190 undo n:o &lt; 0 0<br>History list length 17<br>Total number of lock structs in row lock hash table 0<br>LIST OF TRANSACTIONS FOR EACH SESSION:<br>—TRANSACTION 0 117472185, not started, process no 11052, OS thread id 1158191456<br>MySQL thread id 200610, query id 291197 localhost root<br>—TRANSACTION 0 117472183, not started, process no 11052, OS thread id 1158723936<br>MySQL thread id 199285, query id 291199 localhost root<br>Show innodb status<br>…</p>
<p>监视器可以通过发出下列语句来停止查看：</p>
<p>mysql&gt; DROP TABLE innodb_monitor;<br>Query OK, 0 rows affected (0.05 sec)</p>
<p>设置监视器后，在SHOW INNODB STATUS的显示内容中，会有详细的当前锁等待的信息，包括表名，锁类型，锁定记录的情况等，便于进行进一步的分析和问题的确定。打开监视器以后，默认情况下每15秒会向日志中记录监控的内容，如果长时间打开会导致.err文件变得非常的巨大，所以用户在确认问题原因之后，要记得删除监控表以关闭监视器，或者通过使用“–console”选项来启动服务器以关闭写日志文件。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>InnoDB的行锁模式及加锁方法</strong></p>
<ul>
<li><p><strong>共享锁（S）</strong>：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p>
</li>
<li><p><strong>排他锁（X）</strong>：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁</p>
<blockquote>
<p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（IntentionLocks）,这两种意向锁都是表锁。</p>
</blockquote>
</li>
<li><p><strong>意向共享锁（IS）</strong>：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p>
</li>
<li><p><strong>意向排他锁（IX）</strong>：事务打算给数据行加行排他锁，事务在给一行数据行加排他锁前必须先取得该表的IX锁。</p>
<p><img src="/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/InnoDB%E8%A1%8C%E9%94%81%E6%A8%A1%E5%BC%8F%E5%85%BC%E5%AE%B9%E6%80%A7%E5%88%97%E8%A1%A8.png" alt="InnoDB行锁模式兼容性列表"></p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/11/MySQL%E6%B7%B1%E5%85%A5/" data-id="cklg57v36000lb8uadcs827iz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Nginx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/07/Nginx/" class="article-date">
  <time datetime="2020-09-07T14:02:09.629Z" itemprop="datePublished">2020-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/07/Nginx/">Nginx</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="一，概述："><a href="#一，概述：" class="headerlink" title="一，概述："></a>一，概述：</h2><p>Nginx是一款高性能的http服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师伊戈尔.西索夫所开发，官方测试nginx能够支撑5万并发链接，并且CPU，内存等资源消耗却非常低，运行非常稳定。</p>
<h2 id="二，Nginx应用场景"><a href="#二，Nginx应用场景" class="headerlink" title="二，Nginx应用场景"></a>二，Nginx应用场景</h2><ul>
<li><strong>http服务器</strong>：Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</li>
<li><strong>虚拟主机</strong>：可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机</li>
<li><strong>反向代理，负载均衡</strong>：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</li>
</ul>
<h2 id="三，nginx的配置文件组成"><a href="#三，nginx的配置文件组成" class="headerlink" title="三，nginx的配置文件组成"></a>三，nginx的配置文件组成</h2><ol>
<li><strong>第一部分：全局块</strong>：</li>
</ol>
<ul>
<li>从配置文件开始到events块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令，主要包括配置运行nginx服务器的用户（组），允许生成的worker process数，进程PID存放路径，日志存放路径和类型以及配置文件的引入等：比如：          worker_processes 1;worker_processes 的值越大，可以支持的并发处理量也越多，但是会受到硬件，软件等设备的制约。</li>
</ul>
<ol start="2">
<li><strong>第二部分：events块</strong>：</li>
</ol>
<ul>
<li>events块涉及的指令主要影响nginx服务器与用户的网络连接，常用的设置包括是否开启对多work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个word process可以同时支持的最大连接数等。比如：worker_connections  1024;就表示每个work process支持的最大连接数为1024。</li>
</ul>
<ol start="3">
<li><p><strong>第三部分：http块</strong>：代理，缓存和日志定义等绝大多数功能和第三方模块的配置都在这里，其包括http全局块，server块；每个http块可以包括多个server块，而每个server块就相当于一个虚拟主机。</p>
<ol>
<li><p><strong>http全局块</strong>：</p>
<ul>
<li>http全局块配置的指令包括文件引入，MIME-TYPE定义，日志自定义，连接超时时间，单链接请求数上限等。</li>
</ul>
</li>
<li><p><strong>server块</strong>：每个server块也分为全局server块，以及可以同时包含多个location块。</p>
<ul>
<li>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。</li>
</ul>
<ol>
<li><strong>全局server块：</strong><ul>
<li>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。    </li>
</ul>
</li>
<li><strong>location块</strong>：<ul>
<li>这块的主要作用是基于nginx服务器接收到的请求字符串（例如server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如前面的/uri-string）进行匹配，对特定的请求进行处理，地址定向，数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</li>
<li><strong>location指令说明</strong>：该指令用于匹配URL<ul>
<li><strong>=</strong> ：用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</li>
<li><strong>~</strong>：用于表示uri包含正则表达式，并且区分大小写</li>
<li><strong>~*</strong>：用于表示uri包含正则表达式，并且不区分大小写</li>
<li><strong>^~</strong>：用于不含正则表达式的uri前，要求nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配。</li>
<li>注意：如果uri包含正则表达式，则必须要有 <strong>~</strong> 或者 <strong>~*</strong> 标识。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location [&#x3D; | ~ | ~* | ^~] uri&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四，Nginx的常用命令-需要在-usr-local-nginx-sbin目录下使用"><a href="#四，Nginx的常用命令-需要在-usr-local-nginx-sbin目录下使用" class="headerlink" title="四，Nginx的常用命令:需要在/usr/local/nginx/sbin目录下使用"></a>四，Nginx的常用命令:需要在/usr/local/nginx/sbin目录下使用</h2><ul>
<li>开启：./nginx</li>
<li>关闭：</li>
<li>./nginx -s stop（杀死进程，非正常退出）</li>
<li>./nginx -s quit（保存配置后在退出，正常退出）</li>
<li>重新加载：./nginx -s reload</li>
<li>查看版本号：./nginx -v</li>
</ul>
<h2 id="五，静态资源的部署"><a href="#五，静态资源的部署" class="headerlink" title="五，静态资源的部署"></a>五，静态资源的部署</h2><ul>
<li>修改/usr/local/nginx/conf目录下的nginx.conf配置文件<ul>
<li>listen：为访问的端口</li>
<li>server_name：为访问nginx的域名或IP地址</li>
<li>root：为nginx访问静态资源的目录。</li>
<li>index：为访问的资源名称</li>
</ul>
</li>
</ul>
<h2 id="六，nginx的反向代理和负载均衡"><a href="#六，nginx的反向代理和负载均衡" class="headerlink" title="六，nginx的反向代理和负载均衡"></a>六，nginx的反向代理和负载均衡</h2><ol>
<li><strong>反向代理的概念</strong>：反向代理方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接给的客户端，此时代理服务器对外就表现为一个反向代理服务器。正向代理是针对你的客户端，而反向代理是针对服务器的</li>
<li><strong>反向代理的配置</strong>：在nginx.conf中配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat-travel&#123;</span><br><span class="line">	server 47.92.139.26:8080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	listen 80; #默认端口号</span><br><span class="line">	server_name 47.92.139.26; #访问nginx的域名或端口号</span><br><span class="line">	location&#x2F;&#123;</span><br><span class="line">		#root index; #默认访问资源的目录</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;tomcat-travel;</span><br><span class="line">		index index.html index.html; #默认访问资源名称</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>负载均衡</strong>：nginx提供了几种分配方式（策略）</li>
</ol>
<ul>
<li><strong>轮询（默认）</strong>：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器dwon掉，能自动剔除。</li>
<li><strong>weight</strong>：weight代表权重，默认为1，权重越高被分配的客户端越多，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat-travel&#123;</span><br><span class="line">	server 47.92.139.26:8080 weight&#x3D;2;</span><br><span class="line">	server 192.168.177.129:8080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	listen 80; #默认端口号</span><br><span class="line">	server_name 47.92.139.26; #访问nginx的域名或端口号</span><br><span class="line">	location&#x2F;&#123;</span><br><span class="line">		#root index; #默认访问资源的目录</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;tomcat-travel;</span><br><span class="line">		index index.html index.html; #默认访问资源名称</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ip_hash</strong>：每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat-travel&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line"> 	server 47.92.139.26:8080;</span><br><span class="line">	server 192.168.177.129:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>fair（第三方）</strong>：按后端服务器的响应时间分配，响应时间短的优先分配。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcat-travel&#123;</span><br><span class="line">    server 47.92.139.26:8080;</span><br><span class="line">    server 192.168.177.129:8080;</span><br><span class="line">    fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七，nginx的动静分离"><a href="#七，nginx的动静分离" class="headerlink" title="七，nginx的动静分离"></a>七，nginx的动静分离</h2><ol>
<li>动静分离的概念理解：严格意义上说应该是动态请求和静态请求分开，可以理解成使用nginx来处理静态页面，Tomcat来处理动态页面；</li>
<li>动静分离从目前实现角度来讲大致可以分为两种：<ol>
<li>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；</li>
<li>另一种方法就是动态跟静态文件混合在一起发布，通过nginx来分开。</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/07/Nginx/" data-id="cklg57uzi0005b8ua16xp5h21" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3try-catch%E5%90%97%EF%BC%9F/" rel="tag">你真的了解try-catch吗？</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3try-catch%E5%90%97%EF%BC%9F/" style="font-size: 10px;">你真的了解try-catch吗？</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/03/java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/">java异常处理机制</a>
          </li>
        
          <li>
            <a href="/2021/01/30/screen/">screen</a>
          </li>
        
          <li>
            <a href="/2021/01/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2021/01/20/SpringCloud/">SpringCloud</a>
          </li>
        
          <li>
            <a href="/2020/10/11/%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/">远程部署项目</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 It-fang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>