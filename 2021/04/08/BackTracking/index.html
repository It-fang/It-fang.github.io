<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>BackTracking | It-fang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[TOC] 回溯算法（Back Tracking)一，回溯算法概念：· ​    回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个">
<meta property="og:type" content="article">
<meta property="og:title" content="BackTracking">
<meta property="og:url" content="http://yoursite.com/2021/04/08/BackTracking/index.html">
<meta property="og:site_name" content="It-fang">
<meta property="og:description" content="[TOC] 回溯算法（Back Tracking)一，回溯算法概念：· ​    回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个">
<meta property="article:published_time" content="2021-04-08T01:45:59.000Z">
<meta property="article:modified_time" content="2021-05-28T19:04:29.074Z">
<meta property="article:author" content="It-fang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="It-fang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">It-fang</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">It-fang</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-BackTracking" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/08/BackTracking/" class="article-date">
  <time datetime="2021-04-08T01:45:59.000Z" itemprop="datePublished">2021-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      BackTracking
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="回溯算法（Back-Tracking"><a href="#回溯算法（Back-Tracking" class="headerlink" title="回溯算法（Back Tracking)"></a>回溯算法（Back Tracking)</h1><h3 id="一，回溯算法概念：·"><a href="#一，回溯算法概念：·" class="headerlink" title="一，回溯算法概念：·"></a>一，回溯算法概念：·</h3><blockquote>
<p>​    回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优<a href="https://baike.baidu.com/item/搜索/2791632" target="_blank" rel="noopener">搜索</a>法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。                                                                                     ————百度百科</p>
</blockquote>
<h3 id="二，回溯算法思想："><a href="#二，回溯算法思想：" class="headerlink" title="二，回溯算法思想："></a>二，回溯算法思想：</h3><blockquote>
<p>​    回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。<a href="https://baike.baidu.com/item/八皇后问题" target="_blank" rel="noopener">八皇后问题</a>就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的<a href="https://baike.baidu.com/item/节点" target="_blank" rel="noopener">节点</a>，从而减少状态空间树节点的生成。</p>
<p>​    <a href="https://baike.baidu.com/item/回溯法" target="_blank" rel="noopener">回溯法</a>是一个既带有系统性又带有跳跃性的的<a href="https://baike.baidu.com/item/搜索算法" target="_blank" rel="noopener">搜索算法</a>。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而<a href="https://baike.baidu.com/item/回溯法" target="_blank" rel="noopener">回溯法</a>在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。</p>
</blockquote>
<h3 id="三，回溯算法一般解题步骤"><a href="#三，回溯算法一般解题步骤" class="headerlink" title="三，回溯算法一般解题步骤"></a>三，回溯算法一般解题步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 定义一个解空间，它包含问题的解</span><br><span class="line">2. 用适于搜索的方式组织该空间</span><br><span class="line">3. 用深度优先法(DFS)搜索该空间，利用限界函数避免移动到不可能产生解的子空间</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​    回溯算法的一个有趣的特性是在搜索执行的同时产生解空间。在搜索期间的任何时刻，仅保留从开始节点到当前节点的路径。因此，回溯算法的空间需求为O（从开始节点起最长路径的长度）。这个特性非常重要，因为解空间的大小通常是最长路径长度的指数或阶乘。所以如果要存储全部解空间的话，再多的空间也不够用。</p>
</blockquote>
<h3 id="四，回溯算法能解决的问题："><a href="#四，回溯算法能解决的问题：" class="headerlink" title="四，回溯算法能解决的问题："></a>四，回溯算法能解决的问题：</h3><ol>
<li><strong>组合问题</strong>：N个数里面按一定规则找出k个数的集合</li>
<li><strong>排列问题</strong>：N个数按一定规则全排列，有几种排列方式</li>
<li><strong>切割问题</strong>：一个字符串按一定规则有几种切割方式</li>
<li><strong>子集问题</strong>：一个N个数的集合里有多少符合条件的子集</li>
<li><strong>棋盘问题</strong>：N皇后，解数独等等</li>
</ol>
<h3 id="五，回溯算法模板"><a href="#五，回溯算法模板" class="headerlink" title="五，回溯算法模板"></a>五，回溯算法模板</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归：[for循环横向遍历，递归纵向遍历，回溯不断调整结果集]</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="回溯算法经典例题："><a href="#回溯算法经典例题：" class="headerlink" title="回溯算法经典例题："></a>回溯算法经典例题：</h2><h4 id="1，电话号码的字母组合："><a href="#1，电话号码的字母组合：" class="headerlink" title="1，电话号码的字母组合："></a>1，电话号码的字母组合：</h4><p><strong>题目</strong>：</p>
<blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：digits &#x3D; &quot;23&quot;</span><br><span class="line">&#x2F;&#x2F;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：digits &#x3D; &quot;&quot;</span><br><span class="line">&#x2F;&#x2F;输出：[]</span><br><span class="line">&#x2F;&#x2F; 示例 3： </span><br><span class="line">&#x2F;&#x2F;输入：digits &#x3D; &quot;2&quot;</span><br><span class="line">&#x2F;&#x2F;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>实现代码</strong>：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest1</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = letterCombinations(<span class="string">"23"</span>);</span><br><span class="line">     System.out.println(strings.toString());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//用来存放电话号码组合的字符串</span></span><br><span class="line">     List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> combinations;</span><br><span class="line">     &#125;</span><br><span class="line">     Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> HashMap&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">         put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">        put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">         put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">         put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">         put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">            put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">            put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backTracking(combinations,phoneMap,digits,<span class="number">0</span>,<span class="keyword">new</span> StringBuffer());</span><br><span class="line">     <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 回溯算法获得字母号码组合</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> combinations：存放字母号码组合</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> phoneMap：号码对应的字母</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> digits：输入的号码</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> startIndex：下次递归开始的位置</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> combination 每次到最深处的字母组合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(List&lt;String&gt; combinations,Map&lt;Character,String&gt; phoneMap, String digits,<span class="keyword">int</span> startIndex,StringBuffer combination)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//当递归到数字结束时为最大深度</span></span><br><span class="line">           <span class="keyword">if</span> (startIndex == digits.length() )&#123;</span><br><span class="line">               combinations.add(combination.toString());</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; phoneMap.get(digits.charAt(startIndex)).length(); i++) &#123;</span><br><span class="line">                   combination.append(phoneMap.get(digits.charAt(startIndex)).charAt(i));</span><br><span class="line">                   backTracking(combinations,phoneMap,digits,startIndex+<span class="number">1</span>,combination);</span><br><span class="line">                   combination.deleteCharAt(startIndex);</span><br><span class="line">            &#125;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2，括号生成"><a href="#2，括号生成" class="headerlink" title="2，括号生成"></a>2，括号生成</h4><p><strong>题目</strong></p>
<blockquote>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：n &#x3D; 3</span><br><span class="line">&#x2F;&#x2F;输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：n &#x3D; 1</span><br><span class="line">&#x2F;&#x2F;输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>实现代码</strong>：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backing(result, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backing</span><span class="params">(List&lt;String&gt; result, StringBuilder cur, <span class="keyword">int</span> right, <span class="keyword">int</span> left, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.length() == n * <span class="number">2</span>) &#123;</span><br><span class="line">            result.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; n) &#123;</span><br><span class="line">            cur.append(<span class="string">'('</span>);</span><br><span class="line">            backing(result, cur, right + <span class="number">1</span>, left, n);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            cur.append(<span class="string">')'</span>);</span><br><span class="line">            backing(result, cur, right, left + <span class="number">1</span>, n);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS1：如果使用回溯算法，每一层递归都需要在递归结束后递出的时候回溯到进入递归前的状态，即回溯——撤销之前的操作</p>
<p>PS2：连续递归即求出全排列</p>
</blockquote>
<h4 id="3，组合求和（1）"><a href="#3，组合求和（1）" class="headerlink" title="3，组合求和（1）"></a>3，组合求和（1）</h4><p><strong>题目</strong>；</p>
<blockquote>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; candidates 中的数字可以无限制重复被选取。 </span><br><span class="line">&#x2F;&#x2F; 说明： </span><br><span class="line">&#x2F;&#x2F; 所有数字（包括 target）都是正整数。 </span><br><span class="line">&#x2F;&#x2F; 解集不能包含重复的组合。 </span><br><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F; 输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">&#x2F;&#x2F;所求解集为：</span><br><span class="line">&#x2F;&#x2F;[</span><br><span class="line">&#x2F;&#x2F;  [7],</span><br><span class="line">&#x2F;&#x2F;  [2,2,3]</span><br><span class="line">&#x2F;&#x2F;]</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F; 输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">&#x2F;&#x2F;所求解集为：</span><br><span class="line">&#x2F;&#x2F;[</span><br><span class="line">&#x2F;&#x2F;  [2,2,2,2],</span><br><span class="line">&#x2F;&#x2F;  [2,3,3],</span><br><span class="line">&#x2F;&#x2F;  [3,5]</span><br><span class="line">&#x2F;&#x2F;] </span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; candidates.length &lt;&#x3D; 30 </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; candidates[i] &lt;&#x3D; 200 </span><br><span class="line">&#x2F;&#x2F; candidate 中的每个元素都是独一无二的。 </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; target &lt;&#x3D; 500 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong>：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Integer target = <span class="number">7</span>;</span><br><span class="line">        Integer[] candidates = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        combinationSum(combinations, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), target,candidates,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(combinations.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combinationSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; combinations, ArrayList&lt;Integer&gt; combination, Integer target, Integer[] candidates,Integer sum,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            combinations.add(<span class="keyword">new</span> ArrayList&lt;&gt;(combination));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = index;i&lt; candidates.length;i++) &#123;<span class="comment">//由于数组是有序的，所以可以通过i = index进行去重</span></span><br><span class="line">                sum = sum + candidates[i];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt;= target) &#123;<span class="comment">//由于数组是有序的，所以当sum&gt;target时就无需再往下递归了，同层次的数组也无需继续遍历</span></span><br><span class="line">                    combination.add(candidates[i]);</span><br><span class="line">                	 combinationSum(combinations,combination,target,candidates,sum,i);</span><br><span class="line">                    sum = sum - candidates[i];</span><br><span class="line">                    combination.remove(combination.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS1：由于递归回溯出来的结果是一个个全排列子集，所以当进行组合时需要去除重复的子集，这也是回溯算法解决组合问题的最大难点</p>
<p>PS2：当使用回溯时，需要找到一个合适的条件进行剪枝</p>
</blockquote>
<h4 id="4，组合求和（2）"><a href="#4，组合求和（2）" class="headerlink" title="4，组合求和（2）"></a>4，组合求和（2）</h4><p><strong>题目</strong>：</p>
<blockquote>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; candidates 中的每个数字在每个组合中只能使用一次。 </span><br><span class="line">&#x2F;&#x2F; 说明： </span><br><span class="line">&#x2F;&#x2F; 所有数字（包括目标数）都是正整数。 </span><br><span class="line">&#x2F;&#x2F; 解集不能包含重复的组合。 </span><br><span class="line">&#x2F;&#x2F; 示例 1: </span><br><span class="line">&#x2F;&#x2F; 输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">&#x2F;&#x2F;所求解集为:</span><br><span class="line">&#x2F;&#x2F;[</span><br><span class="line">&#x2F;&#x2F;  [1, 7],</span><br><span class="line">&#x2F;&#x2F;  [1, 2, 5],</span><br><span class="line">&#x2F;&#x2F;  [2, 6],</span><br><span class="line">&#x2F;&#x2F;  [1, 1, 6]</span><br><span class="line">&#x2F;&#x2F;]</span><br><span class="line">&#x2F;&#x2F; 示例 2: </span><br><span class="line">&#x2F;&#x2F; 输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">&#x2F;&#x2F;所求解集为:</span><br><span class="line">&#x2F;&#x2F;[</span><br><span class="line">&#x2F;&#x2F;  [1,2,2],</span><br><span class="line">&#x2F;&#x2F;  [5]</span><br><span class="line">&#x2F;&#x2F;] </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span>[] candidates = &#123;<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        combinationSum2(combinations, candidates, target, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        System.out.println(combinations.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combinationSum2</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; combinations, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;Integer&gt; combination, <span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            combinations.add(<span class="keyword">new</span> ArrayList&lt;&gt;(combination));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>])<span class="keyword">continue</span>;<span class="comment">//区别于组合求和（1），需要对同个树层的重复数字进行去重，对于同个树枝的重复数字则保留</span></span><br><span class="line">                sum += candidates[i];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt;= target ) &#123;</span><br><span class="line">                    combination.add(candidates[i]);</span><br><span class="line">                    combinationSum2(combinations, candidates,target, combination, sum, i + <span class="number">1</span>);<span class="comment">//index表示递归深入的树层数，i表示遍历集合的树枝数</span></span><br><span class="line">                    sum -= candidates[i];</span><br><span class="line">                    combination.remove(combination.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS1：求组合问题时有些时候需要进行树层去重，而树枝不去重</p>
<p>PS2：index表示当前递归层次，i表示当前遍历集合中第i个元素</p>
</blockquote>
<h4 id="5，全排列（1）"><a href="#5，全排列（1）" class="headerlink" title="5，全排列（1）"></a>5，全排列（1）</h4><p><strong>题目</strong>：</p>
<blockquote>
<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例: </span><br><span class="line">&#x2F;&#x2F; 输入: [1,2,3]</span><br><span class="line">&#x2F;&#x2F;输出:</span><br><span class="line">&#x2F;&#x2F;[</span><br><span class="line">&#x2F;&#x2F;  [1,2,3],</span><br><span class="line">&#x2F;&#x2F;  [1,3,2],</span><br><span class="line">&#x2F;&#x2F;  [2,1,3],</span><br><span class="line">&#x2F;&#x2F;  [2,3,1],</span><br><span class="line">&#x2F;&#x2F;  [3,1,2],</span><br><span class="line">&#x2F;&#x2F;  [3,2,1]</span><br><span class="line">&#x2F;&#x2F;] </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong>：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        arrange(arrayList, nums, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        System.out.println(arrayList.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrange</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; arrayList, <span class="keyword">int</span>[] nums, ArrayList&lt;Integer&gt; array, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            arrayList.add(<span class="keyword">new</span> ArrayList&lt;&gt;(array));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] == array.get(j)) &#123;</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                array.add(nums[i]);</span><br><span class="line">                arrange(arrayList, nums, array, index + <span class="number">1</span>);</span><br><span class="line">                array.remove(array.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：无重复数字序列时，全排列需要对树枝去重，而不对树层去重</p>
</blockquote>
<h4 id="6，全排列（2）"><a href="#6，全排列（2）" class="headerlink" title="6，全排列（2）"></a>6，全排列（2）</h4><p><strong>题目</strong></p>
<blockquote>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F;输入：nums &#x3D; [1,1,2]</span><br><span class="line">&#x2F;&#x2F;输出：</span><br><span class="line">&#x2F;&#x2F;[[1,1,2],</span><br><span class="line">&#x2F;&#x2F; [1,2,1],</span><br><span class="line">&#x2F;&#x2F; [2,1,1]]</span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F;输入：nums &#x3D; [1,2,3]</span><br><span class="line">&#x2F;&#x2F;输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; nums.length &lt;&#x3D; 8 </span><br><span class="line">&#x2F;&#x2F; -10 &lt;&#x3D; nums[i] &lt;&#x3D; 10 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        arrange(arrayList, nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>,visit);</span><br><span class="line">        System.out.println(arrayList.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrange</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; arrayList, <span class="keyword">int</span>[] nums, ArrayList&lt;Integer&gt; array, <span class="keyword">int</span> index, <span class="keyword">boolean</span>[] visit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            arrayList.add(<span class="keyword">new</span> ArrayList&lt;&gt;(array));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visit[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visit[i - <span class="number">1</span>])) &#123;<span class="comment">//对树层去重和对索引使用去重</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                array.add(nums[i]);</span><br><span class="line">                visit[i] = <span class="keyword">true</span>;</span><br><span class="line">                arrange(arrayList, nums, array, index + <span class="number">1</span>, visit);</span><br><span class="line">                visit[i] = <span class="keyword">false</span>;</span><br><span class="line">                array.remove(array.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PS1：在含重复数字的序列全排列时，需要进行树层去重，和使用索引去重</p>
<p>PS2：使用索引去重一般通过建立一个boolean[] visit数组记录每个被使用的索引</p>
</blockquote>
<h4 id="7，N皇后"><a href="#7，N皇后" class="headerlink" title="7，N皇后"></a>7，N皇后</h4><p><strong>题目</strong>：</p>
<blockquote>
<p>皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案</span><br><span class="line">&#x2F;&#x2F; 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。</span><br><span class="line">&#x2F;&#x2F; 示例 1：</span><br><span class="line">&#x2F;&#x2F;输入：n &#x3D; 4</span><br><span class="line">&#x2F;&#x2F;输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">&#x2F;&#x2F;解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br><span class="line">&#x2F;&#x2F; 示例 2：</span><br><span class="line">&#x2F;&#x2F;输入：n &#x3D; 1</span><br><span class="line">&#x2F;&#x2F;输出：[[&quot;Q&quot;]]</span><br><span class="line">&#x2F;&#x2F; 提示：</span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; n &lt;&#x3D; 9 </span><br><span class="line">&#x2F;&#x2F; 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码实现</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackingTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//存放解决方案</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; solution = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//存放每个棋子在其对应行的位置</span></span><br><span class="line">        <span class="keyword">int</span>[] queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(queens,-<span class="number">1</span>);</span><br><span class="line">        List&lt;Integer&gt; col = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; diagonals1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; diagonals2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        solvesQueen(solution,queens,<span class="number">0</span>,col,diagonals1,diagonals2,n);</span><br><span class="line">        System.out.println(solution.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solvesQueen</span><span class="params">(List&lt;List&lt;String&gt;&gt; solution, <span class="keyword">int</span>[] queens, <span class="keyword">int</span> row, List&lt;Integer&gt; col, List&lt;Integer&gt; diagonals1, List&lt;Integer&gt; diagonals2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            List&lt;String&gt; board = generate(queens, n);</span><br><span class="line">            solution.add(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col.contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当从右上到左下的行列之差,即为一条斜线的索引</span></span><br><span class="line">                <span class="keyword">int</span> diagonal1 = row - i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals1.contains(diagonal1)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当从左上到右下的行列之差,即为一条斜线的索引</span></span><br><span class="line">                <span class="keyword">int</span> diagonal2 = row + i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals2.contains(diagonal2)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queens[row] = i;</span><br><span class="line">                col.add(i);</span><br><span class="line">                diagonals1.add(diagonal1);</span><br><span class="line">                diagonals2.add(diagonal2);</span><br><span class="line">                solvesQueen(solution, queens, row + <span class="number">1</span>, col, diagonals1, diagonals2, n);</span><br><span class="line">                queens[row] = -<span class="number">1</span>;</span><br><span class="line">                col.remove(col.size() - <span class="number">1</span>);</span><br><span class="line">                diagonals1.remove(diagonals1.size() - <span class="number">1</span>);</span><br><span class="line">                diagonals2.remove(diagonals2.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span>[] queens, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; board = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] row = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">            Arrays.fill(row, <span class="string">'.'</span>);</span><br><span class="line">            row[queens[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            board.add(<span class="keyword">new</span> String(row));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：画图寻找出可以通过一个数值来表示一条斜线的规律</p>
</blockquote>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p>==<a href="https://blog.51cto.com/15069438/2575872" target="_blank" rel="noopener">一篇总结带你彻底搞透回溯算法！</a>==</p>
<p><a href="https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/9258495?fr=aladdin" target="_blank" rel="noopener">百度百科——回溯算法</a></p>
<p><a href="https://www.sohu.com/a/431494940_373022" target="_blank" rel="noopener">什么叫回溯算法，一看就会，一写就废</a></p>
<p><a href="https://my.oschina.net/u/3024426/blog/4689026" target="_blank" rel="noopener">简单易懂的回溯算法（Back Tracking)</a></p>
<p><a href="https://blog.csdn.net/weiyuefei/article/details/79316653" target="_blank" rel="noopener">[回溯算法] 五大常用算法之回溯法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/08/BackTracking/" data-id="cks69tfzo0004iwua3gkiadsi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/08/Greedy/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Greedy
        
      </div>
    </a>
  
  
    <a href="/2021/04/05/jvm/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">jvm</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3try-catch%E5%90%97%EF%BC%9F/" rel="tag">你真的了解try-catch吗？</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3try-catch%E5%90%97%EF%BC%9F/" style="font-size: 10px;">你真的了解try-catch吗？</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/08/JUC/">JUC</a>
          </li>
        
          <li>
            <a href="/2021/07/28/rocketMQ/">rocketMQ</a>
          </li>
        
          <li>
            <a href="/2021/07/16/netty/">netty</a>
          </li>
        
          <li>
            <a href="/2021/05/29/DynamicProgramming/">Dynamic Programming</a>
          </li>
        
          <li>
            <a href="/2021/05/08/Greedy/">Greedy</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 It-fang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>